<!doctype html>
<html>
<head>
	<meta charset="utf-8"/>

	<!--
	The OpenPaperWallet/SafePaperWallet projects are owned by and copyright RootEleven.
	The SafePaperWallet, OpenPaperWallet, RootEleven logos and names are not part of the open source license
		
	GitHub Repository: https://github.com/openpaperwallet/openpaperwallet
	Retail Kit: https://safepaperwallet.com/
	
	This project is derived from many open source projects and graphic design work by independent designers. 
	The individual copyrights are included adjacent to each contribution.
		
	Images, Graphic Design and documentation released under Creative Commons Attribution-ShareAlike 3.0 United States License
	(http://creativecommons.org/licenses/by-sa/3.0/us/deed.en_US)

	The OpenPaperWallet and SafePaperWallet software is available under The MIT License (MIT)
	Copyright (c) 2011-2013 RootEleven.com

	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
	associated documentation files (the "Software"), to deal in the Software without restriction, including 
	without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
	sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject 
	to the following conditions:

	The above copyright notice and this permission notice shall be included in all copies or substantial 
	portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
	LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		
	The notice below is preserved from the original bitaddress.org source.
	-->
		
		
	
	

	<!--
	Donation Address: 1NiNja1bUmhSoTXozBRBEtR8LeF9TGbZBN

	Notice of Copyrights and Licenses:
	***********************************
	The bitaddress.org project, software and embedded resources are copyright bitaddress.org. 
	The bitaddress.org name and logo are not part of the open source license.

	Portions of the all-in-one HTML document contain JavaScript codes that are the copyrights of others. 
	The individual copyrights are included throughout the document along with their licenses.
	Included JavaScript libraries are separated with HTML script tags.

	Summary of JavaScript functions with a redistributable license:
	JavaScript function		License
	*******************		***************
	Array.prototype.map		Public Domain
	window.Crypto			BSD License
	window.SecureRandom		BSD License
	window.EllipticCurve		BSD License
	window.BigInteger		BSD License
	window.QRCode			MIT License
	window.Bitcoin			MIT License

	The bitaddress.org software is available under The MIT License (MIT)
	Copyright (c) 2011-2012 bitaddress.org

	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
	associated documentation files (the "Software"), to deal in the Software without restriction, including 
	without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
	sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject 
	to the following conditions:

	The above copyright notice and this permission notice shall be included in all copies or substantial 
	portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
	LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	GitHub Repository: https://github.com/pointbiz/bitaddress.org
	-->

	<title>openpaperwallet</title>

	<script type="text/javascript">
	// Array.prototype.map function is in the public domain.
	// Production steps of ECMA-262, Edition 5, 15.4.4.19  
	// Reference: http://es5.github.com/#x15.4.4.19  
	if (!Array.prototype.map) {
		Array.prototype.map = function (callback, thisArg) {
			var T, A, k;
			if (this == null) {
				throw new TypeError(" this is null or not defined");
			}
			// 1. Let O be the result of calling ToObject passing the |this| value as the argument.  
			var O = Object(this);
			// 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".  
			// 3. Let len be ToUint32(lenValue).  
			var len = O.length >>> 0;
			// 4. If IsCallable(callback) is false, throw a TypeError exception.  
			// See: http://es5.github.com/#x9.11  
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}
			// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.  
			if (thisArg) {
				T = thisArg;
			}
			// 6. Let A be a new array created as if by the expression new Array(len) where Array is  
			// the standard built-in constructor with that name and len is the value of len.  
			A = new Array(len);
			// 7. Let k be 0  
			k = 0;
			// 8. Repeat, while k < len  
			while (k < len) {
				var kValue, mappedValue;
				// a. Let Pk be ToString(k).  
				//   This is implicit for LHS operands of the in operator  
				// b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.  
				//   This step can be combined with c  
				// c. If kPresent is true, then  
				if (k in O) {
					// i. Let kValue be the result of calling the Get internal method of O with argument Pk.  
					kValue = O[k];
					// ii. Let mappedValue be the result of calling the Call internal method of callback  
					// with T as the this value and argument list containing kValue, k, and O.  
					mappedValue = callback.call(T, kValue, k, O);
					// iii. Call the DefineOwnProperty internal method of A with arguments  
					// Pk, Property Descriptor {Value: mappedValue, Writable: true, Enumerable: true, Configurable: true},  
					// and false.  
					// In browsers that support Object.defineProperty, use the following:  
					// Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });  
					// For best browser support, use the following:  
					A[k] = mappedValue;
				}
				// d. Increase k by 1.  
				k++;
			}
			// 9. return A  
			return A;
		};
	}  
	</script>
	
	<script type="text/javascript">
	/*!
	* Crypto-JS v2.0.0
	* http://code.google.com/p/crypto-js/
	* Copyright (c) 2009, Jeff Mott. All rights reserved.
	* http://code.google.com/p/crypto-js/wiki/License
	*/
	(function () {

		var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

		// Global Crypto object
		var Crypto = window.Crypto = {};

		// Crypto utilities
		var util = Crypto.util = {

			// Bit-wise rotate left
			rotl: function (n, b) {
				return (n << b) | (n >>> (32 - b));
			},

			// Bit-wise rotate right
			rotr: function (n, b) {
				return (n << (32 - b)) | (n >>> b);
			},

			// Swap big-endian to little-endian and vice versa
			endian: function (n) {

				// If number given, swap endian
				if (n.constructor == Number) {
					return util.rotl(n, 8) & 0x00FF00FF |
			util.rotl(n, 24) & 0xFF00FF00;
				}

				// Else, assume array and swap all items
				for (var i = 0; i < n.length; i++)
					n[i] = util.endian(n[i]);
				return n;

			},

			// Generate an array of any length of random bytes
			randomBytes: function (n) {
				for (var bytes = []; n > 0; n--)
					bytes.push(Math.floor(Math.random() * 256));
				return bytes;
			},

			// Convert a byte array to big-endian 32-bit words
			bytesToWords: function (bytes) {
				for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
					words[b >>> 5] |= bytes[i] << (24 - b % 32);
				return words;
			},

			// Convert big-endian 32-bit words to a byte array
			wordsToBytes: function (words) {
				for (var bytes = [], b = 0; b < words.length * 32; b += 8)
					bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
				return bytes;
			},

			// Convert a byte array to a hex string
			bytesToHex: function (bytes) {
				for (var hex = [], i = 0; i < bytes.length; i++) {
					hex.push((bytes[i] >>> 4).toString(16));
					hex.push((bytes[i] & 0xF).toString(16));
				}
				return hex.join("");
			},

			// Convert a hex string to a byte array
			hexToBytes: function (hex) {
				for (var bytes = [], c = 0; c < hex.length; c += 2)
					bytes.push(parseInt(hex.substr(c, 2), 16));
				return bytes;
			},

			// Convert a byte array to a base-64 string
			bytesToBase64: function (bytes) {

				// Use browser-native function if it exists
				if (typeof btoa == "function") return btoa(Binary.bytesToString(bytes));

				for (var base64 = [], i = 0; i < bytes.length; i += 3) {
					var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
					for (var j = 0; j < 4; j++) {
						if (i * 8 + j * 6 <= bytes.length * 8)
							base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
						else base64.push("=");
					}
				}

				return base64.join("");

			},

			// Convert a base-64 string to a byte array
			base64ToBytes: function (base64) {

				// Use browser-native function if it exists
				if (typeof atob == "function") return Binary.stringToBytes(atob(base64));

				// Remove non-base-64 characters
				base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");

				for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
					if (imod4 == 0) continue;
					bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) |
				(base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
				}

				return bytes;

			}

		};

		// Crypto mode namespace
		Crypto.mode = {};

		// Crypto character encodings
		var charenc = Crypto.charenc = {};

		// UTF-8 encoding
		var UTF8 = charenc.UTF8 = {

			// Convert a string to a byte array
			stringToBytes: function (str) {
				return Binary.stringToBytes(unescape(encodeURIComponent(str)));
			},

			// Convert a byte array to a string
			bytesToString: function (bytes) {
				return decodeURIComponent(escape(Binary.bytesToString(bytes)));
			}

		};

		// Binary encoding
		var Binary = charenc.Binary = {

			// Convert a string to a byte array
			stringToBytes: function (str) {
				for (var bytes = [], i = 0; i < str.length; i++)
					bytes.push(str.charCodeAt(i));
				return bytes;
			},

			// Convert a byte array to a string
			bytesToString: function (bytes) {
				for (var str = [], i = 0; i < bytes.length; i++)
					str.push(String.fromCharCode(bytes[i]));
				return str.join("");
			}

		};

	})();



		/*!
		* Crypto-JS v2.0.0
		* http://code.google.com/p/crypto-js/
		* Copyright (c) 2009, Jeff Mott. All rights reserved.
		* http://code.google.com/p/crypto-js/wiki/License
		*/
		(function () {

			// Shortcuts
			var C = Crypto,
	util = C.util,
	charenc = C.charenc,
	UTF8 = charenc.UTF8,
	Binary = charenc.Binary;

			// Constants
			var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
		  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
		  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
		  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
		  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
		  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
		  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
		  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
		  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
		  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
		  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
		  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
		  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
		  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
		  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
		  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

			// Public API
			var SHA256 = C.SHA256 = function (message, options) {
				var digestbytes = util.wordsToBytes(SHA256._sha256(message));
				return options && options.asBytes ? digestbytes :
		   options && options.asString ? Binary.bytesToString(digestbytes) :
		   util.bytesToHex(digestbytes);
			};

			// The core
			SHA256._sha256 = function (message) {

				// Convert to byte array
				if (message.constructor == String) message = UTF8.stringToBytes(message);
				/* else, assume byte array already */

				var m = util.bytesToWords(message),
		l = message.length * 8,
		H = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
			  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19],
		w = [],
		a, b, c, d, e, f, g, h, i, j,
		t1, t2;

				// Padding
				m[l >> 5] |= 0x80 << (24 - l % 32);
				m[((l + 64 >> 9) << 4) + 15] = l;

				for (var i = 0; i < m.length; i += 16) {

					a = H[0];
					b = H[1];
					c = H[2];
					d = H[3];
					e = H[4];
					f = H[5];
					g = H[6];
					h = H[7];

					for (var j = 0; j < 64; j++) {

						if (j < 16) w[j] = m[j + i];
						else {

							var gamma0x = w[j - 15],
					gamma1x = w[j - 2],
					gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
							  ((gamma0x << 14) | (gamma0x >>> 18)) ^
							   (gamma0x >>> 3),
					gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
							  ((gamma1x << 13) | (gamma1x >>> 19)) ^
							   (gamma1x >>> 10);

							w[j] = gamma0 + (w[j - 7] >>> 0) +
					   gamma1 + (w[j - 16] >>> 0);

						}

						var ch = e & f ^ ~e & g,
				maj = a & b ^ a & c ^ b & c,
				sigma0 = ((a << 30) | (a >>> 2)) ^
						 ((a << 19) | (a >>> 13)) ^
						 ((a << 10) | (a >>> 22)),
				sigma1 = ((e << 26) | (e >>> 6)) ^
						 ((e << 21) | (e >>> 11)) ^
						 ((e << 7) | (e >>> 25));


						t1 = (h >>> 0) + sigma1 + ch + (K[j]) + (w[j] >>> 0);
						t2 = sigma0 + maj;

						h = g;
						g = f;
						f = e;
						e = d + t1;
						d = c;
						c = b;
						b = a;
						a = t1 + t2;

					}

					H[0] += a;
					H[1] += b;
					H[2] += c;
					H[3] += d;
					H[4] += e;
					H[5] += f;
					H[6] += g;
					H[7] += h;

				}

				return H;

			};

			// Package private blocksize
			SHA256._blocksize = 16;

		})();






		/*!
		* Crypto-JS v2.0.0
		* http://code.google.com/p/crypto-js/
		* Copyright (c) 2009, Jeff Mott. All rights reserved.
		* http://code.google.com/p/crypto-js/wiki/License
		*
		* A JavaScript implementation of the RIPEMD-160 Algorithm
		* Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
		* Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
		* Distributed under the BSD License
		* See http://pajhome.org.uk/crypt/md5 for details.
		* Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
		* Ported to Crypto-JS by Stefan Thomas.
		*/

		(function () {
			// Shortcuts
			var C = Crypto,
	util = C.util,
	charenc = C.charenc,
	UTF8 = charenc.UTF8,
	Binary = charenc.Binary;

			// Convert a byte array to little-endian 32-bit words
			util.bytesToLWords = function (bytes) {

				var output = Array(bytes.length >> 2);
				for (var i = 0; i < output.length; i++)
					output[i] = 0;
				for (var i = 0; i < bytes.length * 8; i += 8)
					output[i >> 5] |= (bytes[i / 8] & 0xFF) << (i % 32);
				return output;
			};

			// Convert little-endian 32-bit words to a byte array
			util.lWordsToBytes = function (words) {
				var output = [];
				for (var i = 0; i < words.length * 32; i += 8)
					output.push((words[i >> 5] >>> (i % 32)) & 0xff);
				return output;
			};

			// Public API
			var RIPEMD160 = C.RIPEMD160 = function (message, options) {
				var digestbytes = util.lWordsToBytes(RIPEMD160._rmd160(message));
				return options && options.asBytes ? digestbytes :
			options && options.asString ? Binary.bytesToString(digestbytes) :
			util.bytesToHex(digestbytes);
			};

			// The core
			RIPEMD160._rmd160 = function (message) {
				// Convert to byte array
				if (message.constructor == String) message = UTF8.stringToBytes(message);

				var x = util.bytesToLWords(message),
			len = message.length * 8;

				/* append padding */
				x[len >> 5] |= 0x80 << (len % 32);
				x[(((len + 64) >>> 9) << 4) + 14] = len;

				var h0 = 0x67452301;
				var h1 = 0xefcdab89;
				var h2 = 0x98badcfe;
				var h3 = 0x10325476;
				var h4 = 0xc3d2e1f0;

				for (var i = 0; i < x.length; i += 16) {
					var T;
					var A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4;
					var A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4;
					for (var j = 0; j <= 79; ++j) {
						T = safe_add(A1, rmd160_f(j, B1, C1, D1));
						T = safe_add(T, x[i + rmd160_r1[j]]);
						T = safe_add(T, rmd160_K1(j));
						T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
						A1 = E1; E1 = D1; D1 = bit_rol(C1, 10); C1 = B1; B1 = T;
						T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));
						T = safe_add(T, x[i + rmd160_r2[j]]);
						T = safe_add(T, rmd160_K2(j));
						T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
						A2 = E2; E2 = D2; D2 = bit_rol(C2, 10); C2 = B2; B2 = T;
					}
					T = safe_add(h1, safe_add(C1, D2));
					h1 = safe_add(h2, safe_add(D1, E2));
					h2 = safe_add(h3, safe_add(E1, A2));
					h3 = safe_add(h4, safe_add(A1, B2));
					h4 = safe_add(h0, safe_add(B1, C2));
					h0 = T;
				}
				return [h0, h1, h2, h3, h4];
			}

			function rmd160_f(j, x, y, z) {
				return (0 <= j && j <= 15) ? (x ^ y ^ z) :
			(16 <= j && j <= 31) ? (x & y) | (~x & z) :
			(32 <= j && j <= 47) ? (x | ~y) ^ z :
			(48 <= j && j <= 63) ? (x & z) | (y & ~z) :
			(64 <= j && j <= 79) ? x ^ (y | ~z) :
			"rmd160_f: j out of range";
			}
			function rmd160_K1(j) {
				return (0 <= j && j <= 15) ? 0x00000000 :
			(16 <= j && j <= 31) ? 0x5a827999 :
			(32 <= j && j <= 47) ? 0x6ed9eba1 :
			(48 <= j && j <= 63) ? 0x8f1bbcdc :
			(64 <= j && j <= 79) ? 0xa953fd4e :
			"rmd160_K1: j out of range";
			}
			function rmd160_K2(j) {
				return (0 <= j && j <= 15) ? 0x50a28be6 :
			(16 <= j && j <= 31) ? 0x5c4dd124 :
			(32 <= j && j <= 47) ? 0x6d703ef3 :
			(48 <= j && j <= 63) ? 0x7a6d76e9 :
			(64 <= j && j <= 79) ? 0x00000000 :
			"rmd160_K2: j out of range";
			}
			var rmd160_r1 = [
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
		7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
		3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
		1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
		4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];
			var rmd160_r2 = [
		5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
		6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
		15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
		8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
		12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];
			var rmd160_s1 = [
		11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
		7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
		11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
		11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
		9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];
			var rmd160_s2 = [
		8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
		9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
		9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
		15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
		8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

			/*
			* Add integers, wrapping at 2^32. This uses 16-bit operations internally
			* to work around bugs in some JS interpreters.
			*/
			function safe_add(x, y) {
				var lsw = (x & 0xFFFF) + (y & 0xFFFF);
				var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
				return (msw << 16) | (lsw & 0xFFFF);
			}

			/*
			* Bitwise rotate a 32-bit number to the left.
			*/
			function bit_rol(num, cnt) {
				return (num << cnt) | (num >>> (32 - cnt));
			}
		})();

		/*!
		* Crypto-JS v2.0.0
		* http://code.google.com/p/crypto-js/
		* Copyright (c) 2009, Jeff Mott. All rights reserved.
		* http://code.google.com/p/crypto-js/wiki/License
		*/
		(function(){
		
		// Shortcuts
		var C = Crypto,
		    util = C.util,
		    charenc = C.charenc,
		    UTF8 = charenc.UTF8,
		    Binary = charenc.Binary;
		
		C.PBKDF2 = function (password, salt, keylen, options) {
		
			// Convert to byte arrays
			if (password.constructor == String) password = UTF8.stringToBytes(password);
			if (salt.constructor == String) salt = UTF8.stringToBytes(salt);
			/* else, assume byte arrays already */
		
			// Defaults
			var hasher = options && options.hasher || C.SHA1,
			    iterations = options && options.iterations || 1;
		
			// Pseudo-random function
			function PRF(password, salt) {
				return C.HMAC(hasher, salt, password, { asBytes: true });
			}
		
			// Generate key
			var derivedKeyBytes = [],
			    blockindex = 1;
			while (derivedKeyBytes.length < keylen) {
				var block = PRF(password, salt.concat(util.wordsToBytes([blockindex])));
				for (var u = block, i = 1; i < iterations; i++) {
					u = PRF(password, u);
					for (var j = 0; j < block.length; j++) block[j] ^= u[j];
				}
				derivedKeyBytes = derivedKeyBytes.concat(block);
				blockindex++;
			}
		
			// Truncate excess bytes
			derivedKeyBytes.length = keylen;
		
			return options && options.asBytes ? derivedKeyBytes :
			       options && options.asString ? Binary.bytesToString(derivedKeyBytes) :
			       util.bytesToHex(derivedKeyBytes);
		
		};
		
		})();

		(function(){
		
		// Shortcuts
		var C = Crypto,
		    util = C.util,
		    charenc = C.charenc,
		    UTF8 = charenc.UTF8,
		    Binary = charenc.Binary;
		
		C.HMAC = function (hasher, message, key, options) {
		
			// Convert to byte arrays
			if (message.constructor == String) message = UTF8.stringToBytes(message);
			if (key.constructor == String) key = UTF8.stringToBytes(key);
			/* else, assume byte arrays already */
		
			// Allow arbitrary length keys
			if (key.length > hasher._blocksize * 4)
				key = hasher(key, { asBytes: true });
		
			// XOR keys with pad constants
			var okey = key.slice(0),
			    ikey = key.slice(0);
			for (var i = 0; i < hasher._blocksize * 4; i++) {
				okey[i] ^= 0x5C;
				ikey[i] ^= 0x36;
			}
		
			var hmacbytes = hasher(okey.concat(hasher(ikey.concat(message), { asBytes: true })), { asBytes: true });
		
			return options && options.asBytes ? hmacbytes :
			       options && options.asString ? Binary.bytesToString(hmacbytes) :
			       util.bytesToHex(hmacbytes);
		
		};
		
		})();

		/*!
		* Crypto-JS v2.0.0
		* http://code.google.com/p/crypto-js/
		* Copyright (c) 2009, Jeff Mott. All rights reserved.
		* http://code.google.com/p/crypto-js/wiki/License
		*/
		(function(){
		
		// Shortcuts
		var C = Crypto,
		    util = C.util,
		    charenc = C.charenc,
		    UTF8 = charenc.UTF8;
		
		// Precomputed SBOX
		var SBOX = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		             0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		             0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		             0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		             0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		             0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		             0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		             0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		             0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		             0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		             0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		             0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		             0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		             0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		             0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		             0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		             0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		             0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		             0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		             0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		             0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		             0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		             0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		             0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		             0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		             0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		             0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		             0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		             0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		             0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		             0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		             0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 ];
		
		// Compute inverse SBOX lookup table
		for (var INVSBOX = [], i = 0; i < 256; i++) INVSBOX[SBOX[i]] = i;
		
		// Compute multiplication in GF(2^8) lookup tables
		var MULT2 = [],
		    MULT3 = [],
		    MULT9 = [],
		    MULTB = [],
		    MULTD = [],
		    MULTE = [];
		
		function xtime(a, b) {
			for (var result = 0, i = 0; i < 8; i++) {
				if (b & 1) result ^= a;
				var hiBitSet = a & 0x80;
				a = (a << 1) & 0xFF;
				if (hiBitSet) a ^= 0x1b;
				b >>>= 1;
			}
			return result;
		}
		
		for (var i = 0; i < 256; i++) {
			MULT2[i] = xtime(i,2);
			MULT3[i] = xtime(i,3);
			MULT9[i] = xtime(i,9);
			MULTB[i] = xtime(i,0xB);
			MULTD[i] = xtime(i,0xD);
			MULTE[i] = xtime(i,0xE);
		}
		
		// Precomputed RCon lookup
		var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
		
		// Inner state
		var state = [[], [], [], []],
		    keylength,
		    nrounds,
		    keyschedule;
		
		var AES = C.AES = {
		
			/**
			 * Public API
			 */
		
			encrypt: function (message, password, options) {
		
				options = options || {};
		
				// Determine mode
				var mode = options.mode;
		
				// Allow mode to override options
				if (mode.fixOptions) mode.fixOptions(options);
		
				var
		
					// Convert to bytes if message is a string
					m = (
						message.constructor == String ?
						UTF8.stringToBytes(message) :
						message
					),
		
					// Generate random IV
					iv = options.iv || util.randomBytes(AES._blocksize * 4),
		
					// Generate key
					k = (
						password.constructor == String ?
						// Derive key from pass-phrase
						C.PBKDF2(password, iv, 32, { asBytes: true }) :
						// else, assume byte array representing cryptographic key
						password
					);
		
				// Encrypt
				AES._init(k);
				mode.encrypt(AES, m, iv);
		
				// Return ciphertext
				m = options.iv ? m : iv.concat(m);
				return (options && options.asBytes) ? m : util.bytesToBase64(m);
		
			},
		
			decrypt: function (ciphertext, password, options) {
		
				options = options || {};
		
				// Determine mode
				var mode = options.mode;
		
				// Allow mode to override options
				if (mode.fixOptions) mode.fixOptions(options);
		
				var
		
					// Convert to bytes if ciphertext is a string
					c = (
						ciphertext.constructor == String ?
						util.base64ToBytes(ciphertext):
					    ciphertext
					),
		
					// Separate IV and message
					iv = options.iv || null /*c.splice(0, AES._blocksize * 4)*/,
		
					// Generate key
					k = (
						password.constructor == String ?
						// Derive key from pass-phrase
						C.PBKDF2(password, iv, 32, { asBytes: true }) :
						// else, assume byte array representing cryptographic key
						password
					);
		
				// Decrypt
				AES._init(k);
				mode.decrypt(AES, c, iv);
		
				// Return plaintext
				return (options && options.asBytes) ? c : UTF8.bytesToString(c);
		
			},
		
		
			/**
			 * Package private methods and properties
			 */
		
			_blocksize: 4,
		
			_encryptblock: function (m, offset) {
		
				// Set input
				for (var row = 0; row < AES._blocksize; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] = m[offset + col * 4 + row];
				}
		
				// Add round key
				for (var row = 0; row < 4; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] ^= keyschedule[col][row];
				}
		
				for (var round = 1; round < nrounds; round++) {
		
					// Sub bytes
					for (var row = 0; row < 4; row++) {
						for (var col = 0; col < 4; col++)
							state[row][col] = SBOX[state[row][col]];
					}
		
					// Shift rows
					state[1].push(state[1].shift());
					state[2].push(state[2].shift());
					state[2].push(state[2].shift());
					state[3].unshift(state[3].pop());
		
					// Mix columns
					for (var col = 0; col < 4; col++) {
		
						var s0 = state[0][col],
						    s1 = state[1][col],
						    s2 = state[2][col],
						    s3 = state[3][col];
		
						state[0][col] = MULT2[s0] ^ MULT3[s1] ^ s2 ^ s3;
						state[1][col] = s0 ^ MULT2[s1] ^ MULT3[s2] ^ s3;
						state[2][col] = s0 ^ s1 ^ MULT2[s2] ^ MULT3[s3];
						state[3][col] = MULT3[s0] ^ s1 ^ s2 ^ MULT2[s3];
		
					}
		
					// Add round key
					for (var row = 0; row < 4; row++) {
						for (var col = 0; col < 4; col++)
							state[row][col] ^= keyschedule[round * 4 + col][row];
					}
		
				}
		
				// Sub bytes
				for (var row = 0; row < 4; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] = SBOX[state[row][col]];
				}
		
				// Shift rows
				state[1].push(state[1].shift());
				state[2].push(state[2].shift());
				state[2].push(state[2].shift());
				state[3].unshift(state[3].pop());
		
				// Add round key
				for (var row = 0; row < 4; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] ^= keyschedule[nrounds * 4 + col][row];
				}
		
				// Set output
				for (var row = 0; row < AES._blocksize; row++) {
					for (var col = 0; col < 4; col++)
						m[offset + col * 4 + row] = state[row][col];
				}
		
			},
		
			_decryptblock: function (c, offset) {
		
				// Set input
				for (var row = 0; row < AES._blocksize; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] = c[offset + col * 4 + row];
				}
		
				// Add round key
				for (var row = 0; row < 4; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] ^= keyschedule[nrounds * 4 + col][row];
				}
		
				for (var round = 1; round < nrounds; round++) {
		
					// Inv shift rows
					state[1].unshift(state[1].pop());
					state[2].push(state[2].shift());
					state[2].push(state[2].shift());
					state[3].push(state[3].shift());
		
					// Inv sub bytes
					for (var row = 0; row < 4; row++) {
						for (var col = 0; col < 4; col++)
							state[row][col] = INVSBOX[state[row][col]];
					}
		
					// Add round key
					for (var row = 0; row < 4; row++) {
						for (var col = 0; col < 4; col++)
							state[row][col] ^= keyschedule[(nrounds - round) * 4 + col][row];
					}
		
					// Inv mix columns
					for (var col = 0; col < 4; col++) {
		
						var s0 = state[0][col],
						    s1 = state[1][col],
						    s2 = state[2][col],
						    s3 = state[3][col];
		
						state[0][col] = MULTE[s0] ^ MULTB[s1] ^ MULTD[s2] ^ MULT9[s3];
						state[1][col] = MULT9[s0] ^ MULTE[s1] ^ MULTB[s2] ^ MULTD[s3];
						state[2][col] = MULTD[s0] ^ MULT9[s1] ^ MULTE[s2] ^ MULTB[s3];
						state[3][col] = MULTB[s0] ^ MULTD[s1] ^ MULT9[s2] ^ MULTE[s3];
		
					}
		
				}
		
				// Inv shift rows
				state[1].unshift(state[1].pop());
				state[2].push(state[2].shift());
				state[2].push(state[2].shift());
				state[3].push(state[3].shift());
		
				// Inv sub bytes
				for (var row = 0; row < 4; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] = INVSBOX[state[row][col]];
				}
		
				// Add round key
				for (var row = 0; row < 4; row++) {
					for (var col = 0; col < 4; col++)
						state[row][col] ^= keyschedule[col][row];
				}
		
				// Set output
				for (var row = 0; row < AES._blocksize; row++) {
					for (var col = 0; col < 4; col++)
						c[offset + col * 4 + row] = state[row][col];
				}
		
			},
		
		
			/**
			 * Private methods
			 */
		
			_init: function (k) {
				keylength = k.length / 4;
				nrounds = keylength + 6;
				AES._keyexpansion(k);
			},
		
			// Generate a key schedule
			_keyexpansion: function (k) {
		
				keyschedule = [];
		
				for (var row = 0; row < keylength; row++) {
					keyschedule[row] = [
						k[row * 4],
						k[row * 4 + 1],
						k[row * 4 + 2],
						k[row * 4 + 3]
					];
				}
		
				for (var row = keylength; row < AES._blocksize * (nrounds + 1); row++) {
		
					var temp = [
						keyschedule[row - 1][0],
						keyschedule[row - 1][1],
						keyschedule[row - 1][2],
						keyschedule[row - 1][3]
					];
		
					if (row % keylength == 0) {
		
						// Rot word
						temp.push(temp.shift());
		
						// Sub word
						temp[0] = SBOX[temp[0]];
						temp[1] = SBOX[temp[1]];
						temp[2] = SBOX[temp[2]];
						temp[3] = SBOX[temp[3]];
		
						temp[0] ^= RCON[row / keylength];
		
					} else if (keylength > 6 && row % keylength == 4) {
		
						// Sub word
						temp[0] = SBOX[temp[0]];
						temp[1] = SBOX[temp[1]];
						temp[2] = SBOX[temp[2]];
						temp[3] = SBOX[temp[3]];
		
					}
		
					keyschedule[row] = [
						keyschedule[row - keylength][0] ^ temp[0],
						keyschedule[row - keylength][1] ^ temp[1],
						keyschedule[row - keylength][2] ^ temp[2],
						keyschedule[row - keylength][3] ^ temp[3]
					];
		
				}
		
			}
		
		};
		
		})();

		/*!
		 * Crypto-JS contribution from Simon Greatrix
		 */
		
		(function(C){
		
		// Create pad namespace
		var C_pad = C.pad = {};
		
		// No-operation padding, used for stream ciphers
		C_pad.NoPadding = {
		        pad : function (cipher,message) {},
		        unpad : function (cipher,message) {}
		    };
		
		// Create mode namespace
		var C_mode = C.mode = {};
		
		/**
		 * Mode base "class".
		 */
		var Mode = C_mode.Mode = function (padding) {
		    if (padding) {
		        this._padding = padding;
		    }
		};
		
		Mode.prototype = {
		    encrypt: function (cipher, m, iv) {
		        this._padding.pad(cipher, m);
		        this._doEncrypt(cipher, m, iv);
		    },
		
		    decrypt: function (cipher, m, iv) {
		        this._doDecrypt(cipher, m, iv);
		        this._padding.unpad(cipher, m);
		    },
		
		    // Default padding
		    _padding: C_pad.iso7816
		};
		
		
		/**
		 * Electronic Code Book mode.
		 * 
		 * ECB applies the cipher directly against each block of the input.
		 * 
		 * ECB does not require an initialization vector.
		 */
		var ECB = C_mode.ECB = function () {
		    // Call parent constructor
		    Mode.apply(this, arguments);
		};
		
		// Inherit from Mode
		var ECB_prototype = ECB.prototype = new Mode;
		
		// Concrete steps for Mode template
		ECB_prototype._doEncrypt = function (cipher, m, iv) {
		    var blockSizeInBytes = cipher._blocksize * 4;
		    // Encrypt each block
		    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {
		        cipher._encryptblock(m, offset);
		    }
		};
		ECB_prototype._doDecrypt = function (cipher, c, iv) {
		    var blockSizeInBytes = cipher._blocksize * 4;
		    // Decrypt each block
		    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {
		        cipher._decryptblock(c, offset);
		    }
		};
		
		// ECB never uses an IV
		ECB_prototype.fixOptions = function (options) {
		    options.iv = [];
		};
		
		})(Crypto);
	</script>
	
	<script type="text/javascript">
	/*!
	* Random number generator with ArcFour PRNG
	* 
	* NOTE: For best results, put code like
	* <body onclick='SecureRandom.seedTime();' onkeypress='SecureRandom.seedTime();'>
	* in your main HTML document.
	* 
	* Copyright Tom Wu, bitaddress.org  BSD License.
	* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
	*/
	(function () {

		// Constructor function of Global SecureRandom object
		var sr = window.SecureRandom = function () { };

		// Properties
		sr.state;
		sr.pool;
		sr.pptr;

		// Pool size must be a multiple of 4 and greater than 32.
		// An array of bytes the size of the pool will be passed to init()
		sr.poolSize = 256;


		// --- object methods ---

		// public method
		// ba: byte array
		sr.prototype.nextBytes = function (ba) {
			var i;
			for (i = 0; i < ba.length; ++i) ba[i] = sr.getByte();
		};


		// --- static methods ---

		// Mix in the current time (w/milliseconds) into the pool
		// NOTE: this method should be called from body click/keypress event handlers to increase entropy
		sr.seedTime = function () {
			sr.seedInt(new Date().getTime());
		}

		sr.getByte = function () {
			if (sr.state == null) {
				sr.seedTime();
				sr.state = sr.ArcFour(); // Plug in your RNG constructor here
				sr.state.init(sr.pool);
				for (sr.pptr = 0; sr.pptr < sr.pool.length; ++sr.pptr)
					sr.pool[sr.pptr] = 0;
				sr.pptr = 0;
			}
			// TODO: allow reseeding after first request
			return sr.state.next();
		}

		// Mix in a 32-bit integer into the pool
		sr.seedInt = function (x) {
			sr.pool[sr.pptr++] ^= x & 255;
			sr.pool[sr.pptr++] ^= (x >> 8) & 255;
			sr.pool[sr.pptr++] ^= (x >> 16) & 255;
			sr.pool[sr.pptr++] ^= (x >> 24) & 255;
			if (sr.pptr >= sr.poolSize) sr.pptr -= sr.poolSize;
		}


		// Arcfour is a PRNG
		sr.ArcFour = function () {
			function Arcfour() {
				this.i = 0;
				this.j = 0;
				this.S = new Array();
			}

			// Initialize arcfour context from key, an array of ints, each from [0..255]
			function ARC4init(key) {
				var i, j, t;
				for (i = 0; i < 256; ++i)
					this.S[i] = i;
				j = 0;
				for (i = 0; i < 256; ++i) {
					j = (j + this.S[i] + key[i % key.length]) & 255;
					t = this.S[i];
					this.S[i] = this.S[j];
					this.S[j] = t;
				}
				this.i = 0;
				this.j = 0;
			}

			function ARC4next() {
				var t;
				this.i = (this.i + 1) & 255;
				this.j = (this.j + this.S[this.i]) & 255;
				t = this.S[this.i];
				this.S[this.i] = this.S[this.j];
				this.S[this.j] = t;
				return this.S[(t + this.S[this.i]) & 255];
			}

			Arcfour.prototype.init = ARC4init;
			Arcfour.prototype.next = ARC4next;

			return new Arcfour();
		};


		// Initialize the pool with junk if needed.
		if (sr.pool == null) {
			sr.pool = new Array();
			sr.pptr = 0;
			var t;
			if (navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) {
				// Extract entropy (256 bits) from NS4 RNG if available
				var z = window.crypto.random(32);
				for (t = 0; t < z.length; ++t)
					sr.pool[sr.pptr++] = z.charCodeAt(t) & 255;
			}
			while (sr.pptr < sr.poolSize) {  // extract some randomness from Math.random()
				t = Math.floor(65536 * Math.random());
				sr.pool[sr.pptr++] = t >>> 8;
				sr.pool[sr.pptr++] = t & 255;
			}
			sr.pptr = 0;
			sr.seedTime();
			// entropy
			sr.seedInt(window.screenX);
			sr.seedInt(window.screenY);
		}
	})();
	</script>

	<script type="text/javascript">
	//https://raw.github.com/bitcoinjs/bitcoinjs-lib/faa10f0f6a1fff0b9a99fffb9bc30cee33b17212/src/ecdsa.js
	/*!
	* Basic Javascript Elliptic Curve implementation
	* Ported loosely from BouncyCastle's Java EC code
	* Only Fp curves implemented for now
	* 
	* Copyright Tom Wu, bitaddress.org  BSD License.
	* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
	*/
	(function () {

		// Constructor function of Global EllipticCurve object
		var ec = window.EllipticCurve = function () { };


		// ----------------
		// ECFieldElementFp constructor
		// q instanceof BigInteger
		// x instanceof BigInteger
		ec.FieldElementFp = function (q, x) {
			this.x = x;
			// TODO if(x.compareTo(q) >= 0) error
			this.q = q;
		};

		ec.FieldElementFp.prototype.equals = function (other) {
			if (other == this) return true;
			return (this.q.equals(other.q) && this.x.equals(other.x));
		};

		ec.FieldElementFp.prototype.toBigInteger = function () {
			return this.x;
		};

		ec.FieldElementFp.prototype.negate = function () {
			return new ec.FieldElementFp(this.q, this.x.negate().mod(this.q));
		};

		ec.FieldElementFp.prototype.add = function (b) {
			return new ec.FieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
		};

		ec.FieldElementFp.prototype.subtract = function (b) {
			return new ec.FieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
		};

		ec.FieldElementFp.prototype.multiply = function (b) {
			return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
		};

		ec.FieldElementFp.prototype.square = function () {
			return new ec.FieldElementFp(this.q, this.x.square().mod(this.q));
		};

		ec.FieldElementFp.prototype.divide = function (b) {
			return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
		};

		ec.FieldElementFp.prototype.getByteLength = function () {
			return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
		};

		// D.1.4 91
		/**
		* return a sqrt root - the routine verifies that the calculation
		* returns the right value - if none exists it returns null.
		* 
		* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
		* Ported to JavaScript by bitaddress.org
		*/
		ec.FieldElementFp.prototype.sqrt = function () {
			if (!this.q.testBit(0)) throw new Error("even value of q");

			// p mod 4 == 3
			if (this.q.testBit(1)) {
				// z = g^(u+1) + p, p = 4u + 3
				var z = new ec.FieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
				return z.square().equals(this) ? z : null;
			}

			// p mod 4 == 1
			var qMinusOne = this.q.subtract(BigInteger.ONE);
			var legendreExponent = qMinusOne.shiftRight(1);
			if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE))) return null;
			var u = qMinusOne.shiftRight(2);
			var k = u.shiftLeft(1).add(BigInteger.ONE);
			var Q = this.x;
			var fourQ = Q.shiftLeft(2).mod(this.q);
			var U, V;

			do {
				var rand = new SecureRandom();
				var P;
				do {
					P = new BigInteger(this.q.bitLength(), rand);
				}
				while (P.compareTo(this.q) >= 0 || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

				var result = ec.FieldElementFp.fastLucasSequence(this.q, P, Q, k);

				U = result[0];
				V = result[1];
				if (V.multiply(V).mod(this.q).equals(fourQ)) {
					// Integer division by 2, mod q
					if (V.testBit(0)) {
						V = V.add(this.q);
					}
					V = V.shiftRight(1);
					return new ec.FieldElementFp(this.q, V);
				}
			}
			while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

			return null;
		};

		/*
		* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
		* Ported to JavaScript by bitaddress.org
		*/
		ec.FieldElementFp.fastLucasSequence = function (p, P, Q, k) {
			// TODO Research and apply "common-multiplicand multiplication here"

			var n = k.bitLength();
			var s = k.getLowestSetBit();
			var Uh = BigInteger.ONE;
			var Vl = BigInteger.TWO;
			var Vh = P;
			var Ql = BigInteger.ONE;
			var Qh = BigInteger.ONE;

			for (var j = n - 1; j >= s + 1; --j) {
				Ql = Ql.multiply(Qh).mod(p);
				if (k.testBit(j)) {
					Qh = Ql.multiply(Q).mod(p);
					Uh = Uh.multiply(Vh).mod(p);
					Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
					Vh = Vh.multiply(Vh).subtract(Qh.shiftLeft(1)).mod(p);
				}
				else {
					Qh = Ql;
					Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
					Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
					Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
				}
			}

			Ql = Ql.multiply(Qh).mod(p);
			Qh = Ql.multiply(Q).mod(p);
			Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
			Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
			Ql = Ql.multiply(Qh).mod(p);

			for (var j = 1; j <= s; ++j) {
				Uh = Uh.multiply(Vl).mod(p);
				Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
				Ql = Ql.multiply(Ql).mod(p);
			}

			return [Uh, Vl];
		};

		// ----------------
		// ECPointFp constructor
		ec.PointFp = function (curve, x, y, z, compressed) {
			this.curve = curve;
			this.x = x;
			this.y = y;
			// Projective coordinates: either zinv == null or z * zinv == 1
			// z and zinv are just BigIntegers, not fieldElements
			if (z == null) {
				this.z = BigInteger.ONE;
			}
			else {
				this.z = z;
			}
			this.zinv = null;
			// compression flag
			this.compressed = !!compressed;
		};

		ec.PointFp.prototype.getX = function () {
			if (this.zinv == null) {
				this.zinv = this.z.modInverse(this.curve.q);
			}
			return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
		};

		ec.PointFp.prototype.getY = function () {
			if (this.zinv == null) {
				this.zinv = this.z.modInverse(this.curve.q);
			}
			return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
		};

		ec.PointFp.prototype.equals = function (other) {
			if (other == this) return true;
			if (this.isInfinity()) return other.isInfinity();
			if (other.isInfinity()) return this.isInfinity();
			var u, v;
			// u = Y2 * Z1 - Y1 * Z2
			u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
			if (!u.equals(BigInteger.ZERO)) return false;
			// v = X2 * Z1 - X1 * Z2
			v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
			return v.equals(BigInteger.ZERO);
		};

		ec.PointFp.prototype.isInfinity = function () {
			if ((this.x == null) && (this.y == null)) return true;
			return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
		};

		ec.PointFp.prototype.negate = function () {
			return new ec.PointFp(this.curve, this.x, this.y.negate(), this.z);
		};

		ec.PointFp.prototype.add = function (b) {
			if (this.isInfinity()) return b;
			if (b.isInfinity()) return this;

			// u = Y2 * Z1 - Y1 * Z2
			var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
			// v = X2 * Z1 - X1 * Z2
			var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);


			if (BigInteger.ZERO.equals(v)) {
				if (BigInteger.ZERO.equals(u)) {
					return this.twice(); // this == b, so double
				}
				return this.curve.getInfinity(); // this = -b, so infinity
			}

			var THREE = new BigInteger("3");
			var x1 = this.x.toBigInteger();
			var y1 = this.y.toBigInteger();
			var x2 = b.x.toBigInteger();
			var y2 = b.y.toBigInteger();

			var v2 = v.square();
			var v3 = v2.multiply(v);
			var x1v2 = x1.multiply(v2);
			var zu2 = u.square().multiply(this.z);

			// x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
			var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
			// y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
			var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
			// z3 = v^3 * z1 * z2
			var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

			return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
		};

		ec.PointFp.prototype.twice = function () {
			if (this.isInfinity()) return this;
			if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

			// TODO: optimized handling of constants
			var THREE = new BigInteger("3");
			var x1 = this.x.toBigInteger();
			var y1 = this.y.toBigInteger();

			var y1z1 = y1.multiply(this.z);
			var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
			var a = this.curve.a.toBigInteger();

			// w = 3 * x1^2 + a * z1^2
			var w = x1.square().multiply(THREE);
			if (!BigInteger.ZERO.equals(a)) {
				w = w.add(this.z.square().multiply(a));
			}
			w = w.mod(this.curve.q);
			// x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
			var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
			// y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
			var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
			// z3 = 8 * (y1 * z1)^3
			var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

			return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
		};

		// Simple NAF (Non-Adjacent Form) multiplication algorithm
		// TODO: modularize the multiplication algorithm
		ec.PointFp.prototype.multiply = function (k) {
			if (this.isInfinity()) return this;
			if (k.signum() == 0) return this.curve.getInfinity();

			var e = k;
			var h = e.multiply(new BigInteger("3"));

			var neg = this.negate();
			var R = this;

			var i;
			for (i = h.bitLength() - 2; i > 0; --i) {
				R = R.twice();

				var hBit = h.testBit(i);
				var eBit = e.testBit(i);

				if (hBit != eBit) {
					R = R.add(hBit ? this : neg);
				}
			}

			return R;
		};

		// Compute this*j + x*k (simultaneous multiplication)
		ec.PointFp.prototype.multiplyTwo = function (j, x, k) {
			var i;
			if (j.bitLength() > k.bitLength())
				i = j.bitLength() - 1;
			else
				i = k.bitLength() - 1;

			var R = this.curve.getInfinity();
			var both = this.add(x);
			while (i >= 0) {
				R = R.twice();
				if (j.testBit(i)) {
					if (k.testBit(i)) {
						R = R.add(both);
					}
					else {
						R = R.add(this);
					}
				}
				else {
					if (k.testBit(i)) {
						R = R.add(x);
					}
				}
				--i;
			}

			return R;
		};

		// patched by bitaddress.org and Casascius for use with Bitcoin.ECKey
		// patched by coretechs to support compressed public keys
		ec.PointFp.prototype.getEncoded = function (compressed) {
			var x = this.getX().toBigInteger();
			var y = this.getY().toBigInteger();
			var len = 32; // integerToBytes will zero pad if integer is less than 32 bytes. 32 bytes length is required by the Bitcoin protocol.
			var enc = ec.integerToBytes(x, len);

			// when compressed prepend byte depending if y point is even or odd 
			if (compressed) {
				if (y.isEven()) {
					enc.unshift(0x02);
				}
				else {
					enc.unshift(0x03);
				}
			}
			else {
				enc.unshift(0x04);
				enc = enc.concat(ec.integerToBytes(y, len)); // uncompressed public key appends the bytes of the y point
			}
			return enc;
		};

		ec.PointFp.decodeFrom = function (curve, enc) {
			var type = enc[0];
			var dataLen = enc.length - 1;

			// Extract x and y as byte arrays
			var xBa = enc.slice(1, 1 + dataLen / 2);
			var yBa = enc.slice(1 + dataLen / 2, 1 + dataLen);

			// Prepend zero byte to prevent interpretation as negative integer
			xBa.unshift(0);
			yBa.unshift(0);

			// Convert to BigIntegers
			var x = new BigInteger(xBa);
			var y = new BigInteger(yBa);

			// Return point
			return new ec.PointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
		};

		ec.PointFp.prototype.add2D = function (b) {
			if (this.isInfinity()) return b;
			if (b.isInfinity()) return this;

			if (this.x.equals(b.x)) {
				if (this.y.equals(b.y)) {
					// this = b, i.e. this must be doubled
					return this.twice();
				}
				// this = -b, i.e. the result is the point at infinity
				return this.curve.getInfinity();
			}

			var x_x = b.x.subtract(this.x);
			var y_y = b.y.subtract(this.y);
			var gamma = y_y.divide(x_x);

			var x3 = gamma.square().subtract(this.x).subtract(b.x);
			var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

			return new ec.PointFp(this.curve, x3, y3);
		};

		ec.PointFp.prototype.twice2D = function () {
			if (this.isInfinity()) return this;
			if (this.y.toBigInteger().signum() == 0) {
				// if y1 == 0, then (x1, y1) == (x1, -y1)
				// and hence this = -this and thus 2(x1, y1) == infinity
				return this.curve.getInfinity();
			}

			var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
			var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
			var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));

			var x3 = gamma.square().subtract(this.x.multiply(TWO));
			var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

			return new ec.PointFp(this.curve, x3, y3);
		};

		ec.PointFp.prototype.multiply2D = function (k) {
			if (this.isInfinity()) return this;
			if (k.signum() == 0) return this.curve.getInfinity();

			var e = k;
			var h = e.multiply(new BigInteger("3"));

			var neg = this.negate();
			var R = this;

			var i;
			for (i = h.bitLength() - 2; i > 0; --i) {
				R = R.twice();

				var hBit = h.testBit(i);
				var eBit = e.testBit(i);

				if (hBit != eBit) {
					R = R.add2D(hBit ? this : neg);
				}
			}

			return R;
		};

		ec.PointFp.prototype.isOnCurve = function () {
			var x = this.getX().toBigInteger();
			var y = this.getY().toBigInteger();
			var a = this.curve.getA().toBigInteger();
			var b = this.curve.getB().toBigInteger();
			var n = this.curve.getQ();
			var lhs = y.multiply(y).mod(n);
			var rhs = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);
			return lhs.equals(rhs);
		};

		ec.PointFp.prototype.toString = function () {
			return '(' + this.getX().toBigInteger().toString() + ',' + this.getY().toBigInteger().toString() + ')';
		};

		/**
		* Validate an elliptic curve point.
		*
		* See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
		*/
		ec.PointFp.prototype.validate = function () {
			var n = this.curve.getQ();

			// Check Q != O
			if (this.isInfinity()) {
				throw new Error("Point is at infinity.");
			}

			// Check coordinate bounds
			var x = this.getX().toBigInteger();
			var y = this.getY().toBigInteger();
			if (x.compareTo(BigInteger.ONE) < 0 || x.compareTo(n.subtract(BigInteger.ONE)) > 0) {
				throw new Error('x coordinate out of bounds');
			}
			if (y.compareTo(BigInteger.ONE) < 0 || y.compareTo(n.subtract(BigInteger.ONE)) > 0) {
				throw new Error('y coordinate out of bounds');
			}

			// Check y^2 = x^3 + ax + b (mod n)
			if (!this.isOnCurve()) {
				throw new Error("Point is not on the curve.");
			}

			// Check nQ = 0 (Q is a scalar multiple of G)
			if (this.multiply(n).isInfinity()) {
				// TODO: This check doesn't work - fix.
				throw new Error("Point is not a scalar multiple of G.");
			}

			return true;
		};




		// ----------------
		// ECCurveFp constructor
		ec.CurveFp = function (q, a, b) {
			this.q = q;
			this.a = this.fromBigInteger(a);
			this.b = this.fromBigInteger(b);
			this.infinity = new ec.PointFp(this, null, null);
		}

		ec.CurveFp.prototype.getQ = function () {
			return this.q;
		};

		ec.CurveFp.prototype.getA = function () {
			return this.a;
		};

		ec.CurveFp.prototype.getB = function () {
			return this.b;
		};

		ec.CurveFp.prototype.equals = function (other) {
			if (other == this) return true;
			return (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
		};

		ec.CurveFp.prototype.getInfinity = function () {
			return this.infinity;
		};

		ec.CurveFp.prototype.fromBigInteger = function (x) {
			return new ec.FieldElementFp(this.q, x);
		};

		// for now, work with hex strings because they're easier in JS
		// compressed support added by bitaddress.org
		ec.CurveFp.prototype.decodePointHex = function (s) {
			var firstByte = parseInt(s.substr(0, 2), 16);
			switch (firstByte) { // first byte
				case 0:
					return this.infinity;
				case 2: // compressed
				case 3: // compressed
					var yTilde = firstByte & 1;
					var xHex = s.substr(2, s.length - 2);
					var X1 = new BigInteger(xHex, 16);
					return this.decompressPoint(yTilde, X1);
				case 4: // uncompressed
				case 6: // hybrid
				case 7: // hybrid
					var len = (s.length - 2) / 2;
					var xHex = s.substr(2, len);
					var yHex = s.substr(len + 2, len);

					return new ec.PointFp(this,
					this.fromBigInteger(new BigInteger(xHex, 16)),
					this.fromBigInteger(new BigInteger(yHex, 16)));

				default: // unsupported
					return null;
			}
		};

		/*
		* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
		* Ported to JavaScript by bitaddress.org
		*
		* Number yTilde
		* BigInteger X1
		*/
		ec.CurveFp.prototype.decompressPoint = function (yTilde, X1) {
			var x = this.fromBigInteger(X1);
			var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
			var beta = alpha.sqrt();
			// if we can't find a sqrt we haven't got a point on the curve - run!
			if (beta == null) throw new Error("Invalid point compression");
			var betaValue = beta.toBigInteger();
			var bit0 = betaValue.testBit(0) ? 1 : 0;
			if (bit0 != yTilde) {
				// Use the other root
				beta = this.fromBigInteger(this.getQ().subtract(betaValue));
			}
			return new ec.PointFp(this, x, beta, null, true);
		};


		ec.fromHex = function (s) { return new BigInteger(s, 16); };

		ec.integerToBytes = function (i, len) {
			var bytes = i.toByteArrayUnsigned();
			if (len < bytes.length) {
				bytes = bytes.slice(bytes.length - len);
			} else while (len > bytes.length) {
				bytes.unshift(0);
			}
			return bytes;
		};


		// Named EC curves
		// ----------------
		// X9ECParameters constructor
		ec.X9Parameters = function (curve, g, n, h) {
			this.curve = curve;
			this.g = g;
			this.n = n;
			this.h = h;
		}
		ec.X9Parameters.prototype.getCurve = function () { return this.curve; };
		ec.X9Parameters.prototype.getG = function () { return this.g; };
		ec.X9Parameters.prototype.getN = function () { return this.n; };
		ec.X9Parameters.prototype.getH = function () { return this.h; };

		// secp256k1 is the Curve used by Bitcoin
		ec.secNamedCurves = {
			// used by Bitcoin
			"secp256k1": function () {
				// p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
				var p = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
				var a = BigInteger.ZERO;
				var b = ec.fromHex("7");
				var n = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
				var h = BigInteger.ONE;
				var curve = new ec.CurveFp(p, a, b);
				var G = curve.decodePointHex("04"
					+ "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
					+ "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");
				return new ec.X9Parameters(curve, G, n, h);
			}
		};

		// secp256k1 called by Bitcoin's ECKEY
		ec.getSECCurveByName = function (name) {
			if (ec.secNamedCurves[name] == undefined) return null;
			return ec.secNamedCurves[name]();
		}
	})();
	</script>

	<script type="text/javascript">
		/*!
		* Basic JavaScript BN library - subset useful for RSA encryption. v1.3
		* 
		* Copyright (c) 2005  Tom Wu
		* All Rights Reserved.
		* BSD License
		* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
		*
		* Copyright Stephan Thomas
		* Copyright bitaddress.org
		*/

		(function () {

			// (public) Constructor function of Global BigInteger object
			var BigInteger = window.BigInteger = function BigInteger(a, b, c) {
				if (a != null)
					if ("number" == typeof a) this.fromNumber(a, b, c);
					else if (b == null && "string" != typeof a) this.fromString(a, 256);
					else this.fromString(a, b);
			};

			// Bits per digit
			var dbits;

			// JavaScript engine analysis
			var canary = 0xdeadbeefcafe;
			var j_lm = ((canary & 0xffffff) == 0xefcafe);

			// return new, unset BigInteger
			function nbi() { return new BigInteger(null); }

			// am: Compute w_j += (x*this_i), propagate carries,
			// c is initial carry, returns final carry.
			// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
			// We need to select the fastest one that works in this environment.

			// am1: use a single mult and divide to get the high bits,
			// max digit bits should be 26 because
			// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
			function am1(i, x, w, j, c, n) {
				while (--n >= 0) {
					var v = x * this[i++] + w[j] + c;
					c = Math.floor(v / 0x4000000);
					w[j++] = v & 0x3ffffff;
				}
				return c;
			}
			// am2 avoids a big mult-and-extract completely.
			// Max digit bits should be <= 30 because we do bitwise ops
			// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
			function am2(i, x, w, j, c, n) {
				var xl = x & 0x7fff, xh = x >> 15;
				while (--n >= 0) {
					var l = this[i] & 0x7fff;
					var h = this[i++] >> 15;
					var m = xh * l + h * xl;
					l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
					c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
					w[j++] = l & 0x3fffffff;
				}
				return c;
			}
			// Alternately, set max digit bits to 28 since some
			// browsers slow down when dealing with 32-bit numbers.
			function am3(i, x, w, j, c, n) {
				var xl = x & 0x3fff, xh = x >> 14;
				while (--n >= 0) {
					var l = this[i] & 0x3fff;
					var h = this[i++] >> 14;
					var m = xh * l + h * xl;
					l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
					c = (l >> 28) + (m >> 14) + xh * h;
					w[j++] = l & 0xfffffff;
				}
				return c;
			}
			if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
				BigInteger.prototype.am = am2;
				dbits = 30;
			}
			else if (j_lm && (navigator.appName != "Netscape")) {
				BigInteger.prototype.am = am1;
				dbits = 26;
			}
			else { // Mozilla/Netscape seems to prefer am3
				BigInteger.prototype.am = am3;
				dbits = 28;
			}

			BigInteger.prototype.DB = dbits;
			BigInteger.prototype.DM = ((1 << dbits) - 1);
			BigInteger.prototype.DV = (1 << dbits);

			var BI_FP = 52;
			BigInteger.prototype.FV = Math.pow(2, BI_FP);
			BigInteger.prototype.F1 = BI_FP - dbits;
			BigInteger.prototype.F2 = 2 * dbits - BI_FP;

			// Digit conversions
			var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
			var BI_RC = new Array();
			var rr, vv;
			rr = "0".charCodeAt(0);
			for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
			rr = "a".charCodeAt(0);
			for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
			rr = "A".charCodeAt(0);
			for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

			function int2char(n) { return BI_RM.charAt(n); }
			function intAt(s, i) {
				var c = BI_RC[s.charCodeAt(i)];
				return (c == null) ? -1 : c;
			}



			// return bigint initialized to value
			function nbv(i) { var r = nbi(); r.fromInt(i); return r; }


			// returns bit length of the integer x
			function nbits(x) {
				var r = 1, t;
				if ((t = x >>> 16) != 0) { x = t; r += 16; }
				if ((t = x >> 8) != 0) { x = t; r += 8; }
				if ((t = x >> 4) != 0) { x = t; r += 4; }
				if ((t = x >> 2) != 0) { x = t; r += 2; }
				if ((t = x >> 1) != 0) { x = t; r += 1; }
				return r;
			}







			// (protected) copy this to r
			BigInteger.prototype.copyTo = function (r) {
				for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
				r.t = this.t;
				r.s = this.s;
			};


			// (protected) set from integer value x, -DV <= x < DV
			BigInteger.prototype.fromInt = function (x) {
				this.t = 1;
				this.s = (x < 0) ? -1 : 0;
				if (x > 0) this[0] = x;
				else if (x < -1) this[0] = x + DV;
				else this.t = 0;
			};

			// (protected) set from string and radix
			BigInteger.prototype.fromString = function (s, b) {
				var k;
				if (b == 16) k = 4;
				else if (b == 8) k = 3;
				else if (b == 256) k = 8; // byte array
				else if (b == 2) k = 1;
				else if (b == 32) k = 5;
				else if (b == 4) k = 2;
				else { this.fromRadix(s, b); return; }
				this.t = 0;
				this.s = 0;
				var i = s.length, mi = false, sh = 0;
				while (--i >= 0) {
					var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
					if (x < 0) {
						if (s.charAt(i) == "-") mi = true;
						continue;
					}
					mi = false;
					if (sh == 0)
						this[this.t++] = x;
					else if (sh + k > this.DB) {
						this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
						this[this.t++] = (x >> (this.DB - sh));
					}
					else
						this[this.t - 1] |= x << sh;
					sh += k;
					if (sh >= this.DB) sh -= this.DB;
				}
				if (k == 8 && (s[0] & 0x80) != 0) {
					this.s = -1;
					if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
				}
				this.clamp();
				if (mi) BigInteger.ZERO.subTo(this, this);
			};


			// (protected) clamp off excess high words
			BigInteger.prototype.clamp = function () {
				var c = this.s & this.DM;
				while (this.t > 0 && this[this.t - 1] == c) --this.t;
			};

			// (protected) r = this << n*DB
			BigInteger.prototype.dlShiftTo = function (n, r) {
				var i;
				for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
				for (i = n - 1; i >= 0; --i) r[i] = 0;
				r.t = this.t + n;
				r.s = this.s;
			};

			// (protected) r = this >> n*DB
			BigInteger.prototype.drShiftTo = function (n, r) {
				for (var i = n; i < this.t; ++i) r[i - n] = this[i];
				r.t = Math.max(this.t - n, 0);
				r.s = this.s;
			};


			// (protected) r = this << n
			BigInteger.prototype.lShiftTo = function (n, r) {
				var bs = n % this.DB;
				var cbs = this.DB - bs;
				var bm = (1 << cbs) - 1;
				var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
				for (i = this.t - 1; i >= 0; --i) {
					r[i + ds + 1] = (this[i] >> cbs) | c;
					c = (this[i] & bm) << bs;
				}
				for (i = ds - 1; i >= 0; --i) r[i] = 0;
				r[ds] = c;
				r.t = this.t + ds + 1;
				r.s = this.s;
				r.clamp();
			};


			// (protected) r = this >> n
			BigInteger.prototype.rShiftTo = function (n, r) {
				r.s = this.s;
				var ds = Math.floor(n / this.DB);
				if (ds >= this.t) { r.t = 0; return; }
				var bs = n % this.DB;
				var cbs = this.DB - bs;
				var bm = (1 << bs) - 1;
				r[0] = this[ds] >> bs;
				for (var i = ds + 1; i < this.t; ++i) {
					r[i - ds - 1] |= (this[i] & bm) << cbs;
					r[i - ds] = this[i] >> bs;
				}
				if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
				r.t = this.t - ds;
				r.clamp();
			};


			// (protected) r = this - a
			BigInteger.prototype.subTo = function (a, r) {
				var i = 0, c = 0, m = Math.min(a.t, this.t);
				while (i < m) {
					c += this[i] - a[i];
					r[i++] = c & this.DM;
					c >>= this.DB;
				}
				if (a.t < this.t) {
					c -= a.s;
					while (i < this.t) {
						c += this[i];
						r[i++] = c & this.DM;
						c >>= this.DB;
					}
					c += this.s;
				}
				else {
					c += this.s;
					while (i < a.t) {
						c -= a[i];
						r[i++] = c & this.DM;
						c >>= this.DB;
					}
					c -= a.s;
				}
				r.s = (c < 0) ? -1 : 0;
				if (c < -1) r[i++] = this.DV + c;
				else if (c > 0) r[i++] = c;
				r.t = i;
				r.clamp();
			};


			// (protected) r = this * a, r != this,a (HAC 14.12)
			// "this" should be the larger one if appropriate.
			BigInteger.prototype.multiplyTo = function (a, r) {
				var x = this.abs(), y = a.abs();
				var i = x.t;
				r.t = i + y.t;
				while (--i >= 0) r[i] = 0;
				for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
				r.s = 0;
				r.clamp();
				if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
			};


			// (protected) r = this^2, r != this (HAC 14.16)
			BigInteger.prototype.squareTo = function (r) {
				var x = this.abs();
				var i = r.t = 2 * x.t;
				while (--i >= 0) r[i] = 0;
				for (i = 0; i < x.t - 1; ++i) {
					var c = x.am(i, x[i], r, 2 * i, 0, 1);
					if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
						r[i + x.t] -= x.DV;
						r[i + x.t + 1] = 1;
					}
				}
				if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
				r.s = 0;
				r.clamp();
			};



			// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
			// r != q, this != m.  q or r may be null.
			BigInteger.prototype.divRemTo = function (m, q, r) {
				var pm = m.abs();
				if (pm.t <= 0) return;
				var pt = this.abs();
				if (pt.t < pm.t) {
					if (q != null) q.fromInt(0);
					if (r != null) this.copyTo(r);
					return;
				}
				if (r == null) r = nbi();
				var y = nbi(), ts = this.s, ms = m.s;
				var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
				if (nsh > 0) { pm.lShiftTo(nsh, y); pt.lShiftTo(nsh, r); }
				else { pm.copyTo(y); pt.copyTo(r); }
				var ys = y.t;
				var y0 = y[ys - 1];
				if (y0 == 0) return;
				var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
				var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
				var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
				y.dlShiftTo(j, t);
				if (r.compareTo(t) >= 0) {
					r[r.t++] = 1;
					r.subTo(t, r);
				}
				BigInteger.ONE.dlShiftTo(ys, t);
				t.subTo(y, y); // "negative" y so we can replace sub with am later
				while (y.t < ys) y[y.t++] = 0;
				while (--j >= 0) {
					// Estimate quotient digit
					var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
					if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {	// Try it out
						y.dlShiftTo(j, t);
						r.subTo(t, r);
						while (r[i] < --qd) r.subTo(t, r);
					}
				}
				if (q != null) {
					r.drShiftTo(ys, q);
					if (ts != ms) BigInteger.ZERO.subTo(q, q);
				}
				r.t = ys;
				r.clamp();
				if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
				if (ts < 0) BigInteger.ZERO.subTo(r, r);
			};


			// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
			// justification:
			//         xy == 1 (mod m)
			//         xy =  1+km
			//   xy(2-xy) = (1+km)(1-km)
			// x[y(2-xy)] = 1-k^2m^2
			// x[y(2-xy)] == 1 (mod m^2)
			// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
			// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
			// JS multiply "overflows" differently from C/C++, so care is needed here.
			BigInteger.prototype.invDigit = function () {
				if (this.t < 1) return 0;
				var x = this[0];
				if ((x & 1) == 0) return 0;
				var y = x & 3; 	// y == 1/x mod 2^2
				y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
				y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
				y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
				// last step - calculate inverse mod DV directly;
				// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
				y = (y * (2 - x * y % this.DV)) % this.DV; 	// y == 1/x mod 2^dbits
				// we really want the negative inverse, and -DV < y < DV
				return (y > 0) ? this.DV - y : -y;
			};


			// (protected) true iff this is even
			BigInteger.prototype.isEven = function () { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0; };


			// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
			BigInteger.prototype.exp = function (e, z) {
				if (e > 0xffffffff || e < 1) return BigInteger.ONE;
				var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
				g.copyTo(r);
				while (--i >= 0) {
					z.sqrTo(r, r2);
					if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
					else { var t = r; r = r2; r2 = t; }
				}
				return z.revert(r);
			};


			// (public) return string representation in given radix
			BigInteger.prototype.toString = function (b) {
				if (this.s < 0) return "-" + this.negate().toString(b);
				var k;
				if (b == 16) k = 4;
				else if (b == 8) k = 3;
				else if (b == 2) k = 1;
				else if (b == 32) k = 5;
				else if (b == 4) k = 2;
				else return this.toRadix(b);
				var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
				var p = this.DB - (i * this.DB) % k;
				if (i-- > 0) {
					if (p < this.DB && (d = this[i] >> p) > 0) { m = true; r = int2char(d); }
					while (i >= 0) {
						if (p < k) {
							d = (this[i] & ((1 << p) - 1)) << (k - p);
							d |= this[--i] >> (p += this.DB - k);
						}
						else {
							d = (this[i] >> (p -= k)) & km;
							if (p <= 0) { p += this.DB; --i; }
						}
						if (d > 0) m = true;
						if (m) r += int2char(d);
					}
				}
				return m ? r : "0";
			};


			// (public) -this
			BigInteger.prototype.negate = function () { var r = nbi(); BigInteger.ZERO.subTo(this, r); return r; };

			// (public) |this|
			BigInteger.prototype.abs = function () { return (this.s < 0) ? this.negate() : this; };

			// (public) return + if this > a, - if this < a, 0 if equal
			BigInteger.prototype.compareTo = function (a) {
				var r = this.s - a.s;
				if (r != 0) return r;
				var i = this.t;
				r = i - a.t;
				if (r != 0) return (this.s < 0) ? -r : r;
				while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
				return 0;
			}

			// (public) return the number of bits in "this"
			BigInteger.prototype.bitLength = function () {
				if (this.t <= 0) return 0;
				return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
			};

			// (public) this mod a
			BigInteger.prototype.mod = function (a) {
				var r = nbi();
				this.abs().divRemTo(a, null, r);
				if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
				return r;
			}

			// (public) this^e % m, 0 <= e < 2^32
			BigInteger.prototype.modPowInt = function (e, m) {
				var z;
				if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
				return this.exp(e, z);
			};

			// "constants"
			BigInteger.ZERO = nbv(0);
			BigInteger.ONE = nbv(1);







			// Copyright (c) 2005-2009  Tom Wu
			// All Rights Reserved.
			// See "LICENSE" for details.
			// Extended JavaScript BN functions, required for RSA private ops.
			// Version 1.1: new BigInteger("0", 10) returns "proper" zero
			// Version 1.2: square() API, isProbablePrime fix


			// return index of lowest 1-bit in x, x < 2^31
			function lbit(x) {
				if (x == 0) return -1;
				var r = 0;
				if ((x & 0xffff) == 0) { x >>= 16; r += 16; }
				if ((x & 0xff) == 0) { x >>= 8; r += 8; }
				if ((x & 0xf) == 0) { x >>= 4; r += 4; }
				if ((x & 3) == 0) { x >>= 2; r += 2; }
				if ((x & 1) == 0) ++r;
				return r;
			}

			// return number of 1 bits in x
			function cbit(x) {
				var r = 0;
				while (x != 0) { x &= x - 1; ++r; }
				return r;
			}

			var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
			var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];



			// (protected) return x s.t. r^x < DV
			BigInteger.prototype.chunkSize = function (r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)); };

			// (protected) convert to radix string
			BigInteger.prototype.toRadix = function (b) {
				if (b == null) b = 10;
				if (this.signum() == 0 || b < 2 || b > 36) return "0";
				var cs = this.chunkSize(b);
				var a = Math.pow(b, cs);
				var d = nbv(a), y = nbi(), z = nbi(), r = "";
				this.divRemTo(d, y, z);
				while (y.signum() > 0) {
					r = (a + z.intValue()).toString(b).substr(1) + r;
					y.divRemTo(d, y, z);
				}
				return z.intValue().toString(b) + r;
			};

			// (protected) convert from radix string
			BigInteger.prototype.fromRadix = function (s, b) {
				this.fromInt(0);
				if (b == null) b = 10;
				var cs = this.chunkSize(b);
				var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
				for (var i = 0; i < s.length; ++i) {
					var x = intAt(s, i);
					if (x < 0) {
						if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
						continue;
					}
					w = b * w + x;
					if (++j >= cs) {
						this.dMultiply(d);
						this.dAddOffset(w, 0);
						j = 0;
						w = 0;
					}
				}
				if (j > 0) {
					this.dMultiply(Math.pow(b, j));
					this.dAddOffset(w, 0);
				}
				if (mi) BigInteger.ZERO.subTo(this, this);
			};

			// (protected) alternate constructor
			BigInteger.prototype.fromNumber = function (a, b, c) {
				if ("number" == typeof b) {
					// new BigInteger(int,int,RNG)
					if (a < 2) this.fromInt(1);
					else {
						this.fromNumber(a, c);
						if (!this.testBit(a - 1))	// force MSB set
							this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
						if (this.isEven()) this.dAddOffset(1, 0); // force odd
						while (!this.isProbablePrime(b)) {
							this.dAddOffset(2, 0);
							if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
						}
					}
				}
				else {
					// new BigInteger(int,RNG)
					var x = new Array(), t = a & 7;
					x.length = (a >> 3) + 1;
					b.nextBytes(x);
					if (t > 0) x[0] &= ((1 << t) - 1); else x[0] = 0;
					this.fromString(x, 256);
				}
			};

			// (protected) r = this op a (bitwise)
			BigInteger.prototype.bitwiseTo = function (a, op, r) {
				var i, f, m = Math.min(a.t, this.t);
				for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
				if (a.t < this.t) {
					f = a.s & this.DM;
					for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
					r.t = this.t;
				}
				else {
					f = this.s & this.DM;
					for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
					r.t = a.t;
				}
				r.s = op(this.s, a.s);
				r.clamp();
			};

			// (protected) this op (1<<n)
			BigInteger.prototype.changeBit = function (n, op) {
				var r = BigInteger.ONE.shiftLeft(n);
				this.bitwiseTo(r, op, r);
				return r;
			};

			// (protected) r = this + a
			BigInteger.prototype.addTo = function (a, r) {
				var i = 0, c = 0, m = Math.min(a.t, this.t);
				while (i < m) {
					c += this[i] + a[i];
					r[i++] = c & this.DM;
					c >>= this.DB;
				}
				if (a.t < this.t) {
					c += a.s;
					while (i < this.t) {
						c += this[i];
						r[i++] = c & this.DM;
						c >>= this.DB;
					}
					c += this.s;
				}
				else {
					c += this.s;
					while (i < a.t) {
						c += a[i];
						r[i++] = c & this.DM;
						c >>= this.DB;
					}
					c += a.s;
				}
				r.s = (c < 0) ? -1 : 0;
				if (c > 0) r[i++] = c;
				else if (c < -1) r[i++] = this.DV + c;
				r.t = i;
				r.clamp();
			};

			// (protected) this *= n, this >= 0, 1 < n < DV
			BigInteger.prototype.dMultiply = function (n) {
				this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
				++this.t;
				this.clamp();
			};

			// (protected) this += n << w words, this >= 0
			BigInteger.prototype.dAddOffset = function (n, w) {
				if (n == 0) return;
				while (this.t <= w) this[this.t++] = 0;
				this[w] += n;
				while (this[w] >= this.DV) {
					this[w] -= this.DV;
					if (++w >= this.t) this[this.t++] = 0;
					++this[w];
				}
			};

			// (protected) r = lower n words of "this * a", a.t <= n
			// "this" should be the larger one if appropriate.
			BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
				var i = Math.min(this.t + a.t, n);
				r.s = 0; // assumes a,this >= 0
				r.t = i;
				while (i > 0) r[--i] = 0;
				var j;
				for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
				for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
				r.clamp();
			};


			// (protected) r = "this * a" without lower n words, n > 0
			// "this" should be the larger one if appropriate.
			BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
				--n;
				var i = r.t = this.t + a.t - n;
				r.s = 0; // assumes a,this >= 0
				while (--i >= 0) r[i] = 0;
				for (i = Math.max(n - this.t, 0); i < a.t; ++i)
					r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
				r.clamp();
				r.drShiftTo(1, r);
			};

			// (protected) this % n, n < 2^26
			BigInteger.prototype.modInt = function (n) {
				if (n <= 0) return 0;
				var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
				if (this.t > 0)
					if (d == 0) r = this[0] % n;
					else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
				return r;
			};


			// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
			BigInteger.prototype.millerRabin = function (t) {
				var n1 = this.subtract(BigInteger.ONE);
				var k = n1.getLowestSetBit();
				if (k <= 0) return false;
				var r = n1.shiftRight(k);
				t = (t + 1) >> 1;
				if (t > lowprimes.length) t = lowprimes.length;
				var a = nbi();
				for (var i = 0; i < t; ++i) {
					//Pick bases at random, instead of starting at 2
					a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
					var y = a.modPow(r, this);
					if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
						var j = 1;
						while (j++ < k && y.compareTo(n1) != 0) {
							y = y.modPowInt(2, this);
							if (y.compareTo(BigInteger.ONE) == 0) return false;
						}
						if (y.compareTo(n1) != 0) return false;
					}
				}
				return true;
			};



			// (public)
			BigInteger.prototype.clone = function () { var r = nbi(); this.copyTo(r); return r; };

			// (public) return value as integer
			BigInteger.prototype.intValue = function () {
				if (this.s < 0) {
					if (this.t == 1) return this[0] - this.DV;
					else if (this.t == 0) return -1;
				}
				else if (this.t == 1) return this[0];
				else if (this.t == 0) return 0;
				// assumes 16 < DB < 32
				return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
			};


			// (public) return value as byte
			BigInteger.prototype.byteValue = function () { return (this.t == 0) ? this.s : (this[0] << 24) >> 24; };

			// (public) return value as short (assumes DB>=16)
			BigInteger.prototype.shortValue = function () { return (this.t == 0) ? this.s : (this[0] << 16) >> 16; };

			// (public) 0 if this == 0, 1 if this > 0
			BigInteger.prototype.signum = function () {
				if (this.s < 0) return -1;
				else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
				else return 1;
			};


			// (public) convert to bigendian byte array
			BigInteger.prototype.toByteArray = function () {
				var i = this.t, r = new Array();
				r[0] = this.s;
				var p = this.DB - (i * this.DB) % 8, d, k = 0;
				if (i-- > 0) {
					if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
						r[k++] = d | (this.s << (this.DB - p));
					while (i >= 0) {
						if (p < 8) {
							d = (this[i] & ((1 << p) - 1)) << (8 - p);
							d |= this[--i] >> (p += this.DB - 8);
						}
						else {
							d = (this[i] >> (p -= 8)) & 0xff;
							if (p <= 0) { p += this.DB; --i; }
						}
						if ((d & 0x80) != 0) d |= -256;
						if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
						if (k > 0 || d != this.s) r[k++] = d;
					}
				}
				return r;
			};

			BigInteger.prototype.equals = function (a) { return (this.compareTo(a) == 0); };
			BigInteger.prototype.min = function (a) { return (this.compareTo(a) < 0) ? this : a; };
			BigInteger.prototype.max = function (a) { return (this.compareTo(a) > 0) ? this : a; };

			// (public) this & a
			function op_and(x, y) { return x & y; }
			BigInteger.prototype.and = function (a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r; };

			// (public) this | a
			function op_or(x, y) { return x | y; }
			BigInteger.prototype.or = function (a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r; };

			// (public) this ^ a
			function op_xor(x, y) { return x ^ y; }
			BigInteger.prototype.xor = function (a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r; };

			// (public) this & ~a
			function op_andnot(x, y) { return x & ~y; }
			BigInteger.prototype.andNot = function (a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r; };

			// (public) ~this
			BigInteger.prototype.not = function () {
				var r = nbi();
				for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
				r.t = this.t;
				r.s = ~this.s;
				return r;
			};

			// (public) this << n
			BigInteger.prototype.shiftLeft = function (n) {
				var r = nbi();
				if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
				return r;
			};

			// (public) this >> n
			BigInteger.prototype.shiftRight = function (n) {
				var r = nbi();
				if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
				return r;
			};

			// (public) returns index of lowest 1-bit (or -1 if none)
			BigInteger.prototype.getLowestSetBit = function () {
				for (var i = 0; i < this.t; ++i)
					if (this[i] != 0) return i * this.DB + lbit(this[i]);
				if (this.s < 0) return this.t * this.DB;
				return -1;
			};

			// (public) return number of set bits
			BigInteger.prototype.bitCount = function () {
				var r = 0, x = this.s & this.DM;
				for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
				return r;
			};

			// (public) true iff nth bit is set
			BigInteger.prototype.testBit = function (n) {
				var j = Math.floor(n / this.DB);
				if (j >= this.t) return (this.s != 0);
				return ((this[j] & (1 << (n % this.DB))) != 0);
			};

			// (public) this | (1<<n)
			BigInteger.prototype.setBit = function (n) { return this.changeBit(n, op_or); };
			// (public) this & ~(1<<n)
			BigInteger.prototype.clearBit = function (n) { return this.changeBit(n, op_andnot); };
			// (public) this ^ (1<<n)
			BigInteger.prototype.flipBit = function (n) { return this.changeBit(n, op_xor); };
			// (public) this + a
			BigInteger.prototype.add = function (a) { var r = nbi(); this.addTo(a, r); return r; };
			// (public) this - a
			BigInteger.prototype.subtract = function (a) { var r = nbi(); this.subTo(a, r); return r; };
			// (public) this * a
			BigInteger.prototype.multiply = function (a) { var r = nbi(); this.multiplyTo(a, r); return r; };
			// (public) this / a
			BigInteger.prototype.divide = function (a) { var r = nbi(); this.divRemTo(a, r, null); return r; };
			// (public) this % a
			BigInteger.prototype.remainder = function (a) { var r = nbi(); this.divRemTo(a, null, r); return r; };
			// (public) [this/a,this%a]
			BigInteger.prototype.divideAndRemainder = function (a) {
				var q = nbi(), r = nbi();
				this.divRemTo(a, q, r);
				return new Array(q, r);
			};

			// (public) this^e % m (HAC 14.85)
			BigInteger.prototype.modPow = function (e, m) {
				var i = e.bitLength(), k, r = nbv(1), z;
				if (i <= 0) return r;
				else if (i < 18) k = 1;
				else if (i < 48) k = 3;
				else if (i < 144) k = 4;
				else if (i < 768) k = 5;
				else k = 6;
				if (i < 8)
					z = new Classic(m);
				else if (m.isEven())
					z = new Barrett(m);
				else
					z = new Montgomery(m);

				// precomputation
				var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
				g[1] = z.convert(this);
				if (k > 1) {
					var g2 = nbi();
					z.sqrTo(g[1], g2);
					while (n <= km) {
						g[n] = nbi();
						z.mulTo(g2, g[n - 2], g[n]);
						n += 2;
					}
				}

				var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
				i = nbits(e[j]) - 1;
				while (j >= 0) {
					if (i >= k1) w = (e[j] >> (i - k1)) & km;
					else {
						w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
						if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
					}

					n = k;
					while ((w & 1) == 0) { w >>= 1; --n; }
					if ((i -= n) < 0) { i += this.DB; --j; }
					if (is1) {	// ret == 1, don't bother squaring or multiplying it
						g[w].copyTo(r);
						is1 = false;
					}
					else {
						while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2; }
						if (n > 0) z.sqrTo(r, r2); else { t = r; r = r2; r2 = t; }
						z.mulTo(r2, g[w], r);
					}

					while (j >= 0 && (e[j] & (1 << i)) == 0) {
						z.sqrTo(r, r2); t = r; r = r2; r2 = t;
						if (--i < 0) { i = this.DB - 1; --j; }
					}
				}
				return z.revert(r);
			};

			// (public) 1/this % m (HAC 14.61)
			BigInteger.prototype.modInverse = function (m) {
				var ac = m.isEven();
				if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
				var u = m.clone(), v = this.clone();
				var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
				while (u.signum() != 0) {
					while (u.isEven()) {
						u.rShiftTo(1, u);
						if (ac) {
							if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(m, b); }
							a.rShiftTo(1, a);
						}
						else if (!b.isEven()) b.subTo(m, b);
						b.rShiftTo(1, b);
					}
					while (v.isEven()) {
						v.rShiftTo(1, v);
						if (ac) {
							if (!c.isEven() || !d.isEven()) { c.addTo(this, c); d.subTo(m, d); }
							c.rShiftTo(1, c);
						}
						else if (!d.isEven()) d.subTo(m, d);
						d.rShiftTo(1, d);
					}
					if (u.compareTo(v) >= 0) {
						u.subTo(v, u);
						if (ac) a.subTo(c, a);
						b.subTo(d, b);
					}
					else {
						v.subTo(u, v);
						if (ac) c.subTo(a, c);
						d.subTo(b, d);
					}
				}
				if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
				if (d.compareTo(m) >= 0) return d.subtract(m);
				if (d.signum() < 0) d.addTo(m, d); else return d;
				if (d.signum() < 0) return d.add(m); else return d;
			};


			// (public) this^e
			BigInteger.prototype.pow = function (e) { return this.exp(e, new NullExp()); };

			// (public) gcd(this,a) (HAC 14.54)
			BigInteger.prototype.gcd = function (a) {
				var x = (this.s < 0) ? this.negate() : this.clone();
				var y = (a.s < 0) ? a.negate() : a.clone();
				if (x.compareTo(y) < 0) { var t = x; x = y; y = t; }
				var i = x.getLowestSetBit(), g = y.getLowestSetBit();
				if (g < 0) return x;
				if (i < g) g = i;
				if (g > 0) {
					x.rShiftTo(g, x);
					y.rShiftTo(g, y);
				}
				while (x.signum() > 0) {
					if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
					if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
					if (x.compareTo(y) >= 0) {
						x.subTo(y, x);
						x.rShiftTo(1, x);
					}
					else {
						y.subTo(x, y);
						y.rShiftTo(1, y);
					}
				}
				if (g > 0) y.lShiftTo(g, y);
				return y;
			};

			// (public) test primality with certainty >= 1-.5^t
			BigInteger.prototype.isProbablePrime = function (t) {
				var i, x = this.abs();
				if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
					for (i = 0; i < lowprimes.length; ++i)
						if (x[0] == lowprimes[i]) return true;
					return false;
				}
				if (x.isEven()) return false;
				i = 1;
				while (i < lowprimes.length) {
					var m = lowprimes[i], j = i + 1;
					while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
					m = x.modInt(m);
					while (i < j) if (m % lowprimes[i++] == 0) return false;
				}
				return x.millerRabin(t);
			};


			// JSBN-specific extension

			// (public) this^2
			BigInteger.prototype.square = function () { var r = nbi(); this.squareTo(r); return r; };


			// NOTE: BigInteger interfaces not implemented in jsbn:
			// BigInteger(int signum, byte[] magnitude)
			// double doubleValue()
			// float floatValue()
			// int hashCode()
			// long longValue()
			// static BigInteger valueOf(long val)



			// Copyright Stephan Thomas (start) --- //
			// https://raw.github.com/bitcoinjs/bitcoinjs-lib/07f9d55ccb6abd962efb6befdd37671f85ea4ff9/src/util.js
			// BigInteger monkey patching
			BigInteger.valueOf = nbv;

			/**
			* Returns a byte array representation of the big integer.
			*
			* This returns the absolute of the contained value in big endian
			* form. A value of zero results in an empty array.
			*/
			BigInteger.prototype.toByteArrayUnsigned = function () {
				var ba = this.abs().toByteArray();
				if (ba.length) {
					if (ba[0] == 0) {
						ba = ba.slice(1);
					}
					return ba.map(function (v) {
						return (v < 0) ? v + 256 : v;
					});
				} else {
					// Empty array, nothing to do
					return ba;
				}
			};

			/**
			* Turns a byte array into a big integer.
			*
			* This function will interpret a byte array as a big integer in big
			* endian notation and ignore leading zeros.
			*/
			BigInteger.fromByteArrayUnsigned = function (ba) {
				if (!ba.length) {
					return ba.valueOf(0);
				} else if (ba[0] & 0x80) {
					// Prepend a zero so the BigInteger class doesn't mistake this
					// for a negative integer.
					return new BigInteger([0].concat(ba));
				} else {
					return new BigInteger(ba);
				}
			};

			/**
			* Converts big integer to signed byte representation.
			*
			* The format for this value uses a the most significant bit as a sign
			* bit. If the most significant bit is already occupied by the
			* absolute value, an extra byte is prepended and the sign bit is set
			* there.
			*
			* Examples:
			*
			*      0 =>     0x00
			*      1 =>     0x01
			*     -1 =>     0x81
			*    127 =>     0x7f
			*   -127 =>     0xff
			*    128 =>   0x0080
			*   -128 =>   0x8080
			*    255 =>   0x00ff
			*   -255 =>   0x80ff
			*  16300 =>   0x3fac
			* -16300 =>   0xbfac
			*  62300 => 0x00f35c
			* -62300 => 0x80f35c
			*/
			BigInteger.prototype.toByteArraySigned = function () {
				var val = this.abs().toByteArrayUnsigned();
				var neg = this.compareTo(BigInteger.ZERO) < 0;

				if (neg) {
					if (val[0] & 0x80) {
						val.unshift(0x80);
					} else {
						val[0] |= 0x80;
					}
				} else {
					if (val[0] & 0x80) {
						val.unshift(0x00);
					}
				}

				return val;
			};

			/**
			* Parse a signed big integer byte representation.
			*
			* For details on the format please see BigInteger.toByteArraySigned.
			*/
			BigInteger.fromByteArraySigned = function (ba) {
				// Check for negative value
				if (ba[0] & 0x80) {
					// Remove sign bit
					ba[0] &= 0x7f;

					return BigInteger.fromByteArrayUnsigned(ba).negate();
				} else {
					return BigInteger.fromByteArrayUnsigned(ba);
				}
			};
			// Copyright Stephan Thomas (end) --- //




			// ****** REDUCTION ******* //

			// Modular reduction using "classic" algorithm
			function Classic(m) { this.m = m; }
			Classic.prototype.convert = function (x) {
				if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
				else return x;
			};
			Classic.prototype.revert = function (x) { return x; };
			Classic.prototype.reduce = function (x) { x.divRemTo(this.m, null, x); };
			Classic.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
			Classic.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };





			// Montgomery reduction
			function Montgomery(m) {
				this.m = m;
				this.mp = m.invDigit();
				this.mpl = this.mp & 0x7fff;
				this.mph = this.mp >> 15;
				this.um = (1 << (m.DB - 15)) - 1;
				this.mt2 = 2 * m.t;
			}
			// xR mod m
			Montgomery.prototype.convert = function (x) {
				var r = nbi();
				x.abs().dlShiftTo(this.m.t, r);
				r.divRemTo(this.m, null, r);
				if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
				return r;
			}
			// x/R mod m
			Montgomery.prototype.revert = function (x) {
				var r = nbi();
				x.copyTo(r);
				this.reduce(r);
				return r;
			};
			// x = x/R mod m (HAC 14.32)
			Montgomery.prototype.reduce = function (x) {
				while (x.t <= this.mt2)	// pad x so am has enough room later
					x[x.t++] = 0;
				for (var i = 0; i < this.m.t; ++i) {
					// faster way of calculating u0 = x[i]*mp mod DV
					var j = x[i] & 0x7fff;
					var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
					// use am to combine the multiply-shift-add into one call
					j = i + this.m.t;
					x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
					// propagate carry
					while (x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
				}
				x.clamp();
				x.drShiftTo(this.m.t, x);
				if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
			};
			// r = "xy/R mod m"; x,y != r
			Montgomery.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
			// r = "x^2/R mod m"; x != r
			Montgomery.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };





			// A "null" reducer
			function NullExp() { }
			NullExp.prototype.convert = function (x) { return x; };
			NullExp.prototype.revert = function (x) { return x; };
			NullExp.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); };
			NullExp.prototype.sqrTo = function (x, r) { x.squareTo(r); };





			// Barrett modular reduction
			function Barrett(m) {
				// setup Barrett
				this.r2 = nbi();
				this.q3 = nbi();
				BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
				this.mu = this.r2.divide(m);
				this.m = m;
			}
			Barrett.prototype.convert = function (x) {
				if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
				else if (x.compareTo(this.m) < 0) return x;
				else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
			};
			Barrett.prototype.revert = function (x) { return x; };
			// x = x mod m (HAC 14.42)
			Barrett.prototype.reduce = function (x) {
				x.drShiftTo(this.m.t - 1, this.r2);
				if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp(); }
				this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
				this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
				while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
				x.subTo(this.r2, x);
				while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
			};
			// r = x*y mod m; x,y != r
			Barrett.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
			// r = x^2 mod m; x != r
			Barrett.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };

		})();
	</script>

	<script type="text/javascript">
	//---------------------------------------------------------------------
	// QRCode for JavaScript
	//
	// Copyright (c) 2009 Kazuhiko Arase
	//
	// URL: http://www.d-project.com/
	//
	// Licensed under the MIT license:
	//   http://www.opensource.org/licenses/mit-license.php
	//
	// The word "QR Code" is registered trademark of 
	// DENSO WAVE INCORPORATED
	//   http://www.denso-wave.com/qrcode/faqpatent-e.html
	//
	//---------------------------------------------------------------------

	(function () {
		//---------------------------------------------------------------------
		// QRCode
		//---------------------------------------------------------------------

		var QRCode = window.QRCode = function (typeNumber, errorCorrectLevel) {
			this.typeNumber = typeNumber;
			this.errorCorrectLevel = errorCorrectLevel;
			this.modules = null;
			this.moduleCount = 0;
			this.dataCache = null;
			this.dataList = new Array();
		}

		QRCode.prototype = {

			addData: function (data) {
				var newData = new QRCode.QR8bitByte(data);
				this.dataList.push(newData);
				this.dataCache = null;
			},

			isDark: function (row, col) {
				if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
					throw new Error(row + "," + col);
				}
				return this.modules[row][col];
			},

			getModuleCount: function () {
				return this.moduleCount;
			},

			make: function () {
				this.makeImpl(false, this.getBestMaskPattern());
			},

			makeImpl: function (test, maskPattern) {

				this.moduleCount = this.typeNumber * 4 + 17;
				this.modules = new Array(this.moduleCount);

				for (var row = 0; row < this.moduleCount; row++) {

					this.modules[row] = new Array(this.moduleCount);

					for (var col = 0; col < this.moduleCount; col++) {
						this.modules[row][col] = null; //(col + row) % 3;
					}
				}

				this.setupPositionProbePattern(0, 0);
				this.setupPositionProbePattern(this.moduleCount - 7, 0);
				this.setupPositionProbePattern(0, this.moduleCount - 7);
				this.setupPositionAdjustPattern();
				this.setupTimingPattern();
				this.setupTypeInfo(test, maskPattern);

				if (this.typeNumber >= 7) {
					this.setupTypeNumber(test);
				}

				if (this.dataCache == null) {
					this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
				}

				this.mapData(this.dataCache, maskPattern);
			},

			setupPositionProbePattern: function (row, col) {

				for (var r = -1; r <= 7; r++) {

					if (row + r <= -1 || this.moduleCount <= row + r) continue;

					for (var c = -1; c <= 7; c++) {

						if (col + c <= -1 || this.moduleCount <= col + c) continue;

						if ((0 <= r && r <= 6 && (c == 0 || c == 6))
						|| (0 <= c && c <= 6 && (r == 0 || r == 6))
						|| (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
							this.modules[row + r][col + c] = true;
						} else {
							this.modules[row + r][col + c] = false;
						}
					}
				}
			},

			getBestMaskPattern: function () {

				var minLostPoint = 0;
				var pattern = 0;

				for (var i = 0; i < 8; i++) {

					this.makeImpl(true, i);

					var lostPoint = QRCode.Util.getLostPoint(this);

					if (i == 0 || minLostPoint > lostPoint) {
						minLostPoint = lostPoint;
						pattern = i;
					}
				}

				return pattern;
			},

			createMovieClip: function (target_mc, instance_name, depth) {

				var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
				var cs = 1;

				this.make();

				for (var row = 0; row < this.modules.length; row++) {

					var y = row * cs;

					for (var col = 0; col < this.modules[row].length; col++) {

						var x = col * cs;
						var dark = this.modules[row][col];

						if (dark) {
							qr_mc.beginFill(0, 100);
							qr_mc.moveTo(x, y);
							qr_mc.lineTo(x + cs, y);
							qr_mc.lineTo(x + cs, y + cs);
							qr_mc.lineTo(x, y + cs);
							qr_mc.endFill();
						}
					}
				}

				return qr_mc;
			},

			setupTimingPattern: function () {

				for (var r = 8; r < this.moduleCount - 8; r++) {
					if (this.modules[r][6] != null) {
						continue;
					}
					this.modules[r][6] = (r % 2 == 0);
				}

				for (var c = 8; c < this.moduleCount - 8; c++) {
					if (this.modules[6][c] != null) {
						continue;
					}
					this.modules[6][c] = (c % 2 == 0);
				}
			},

			setupPositionAdjustPattern: function () {

				var pos = QRCode.Util.getPatternPosition(this.typeNumber);

				for (var i = 0; i < pos.length; i++) {

					for (var j = 0; j < pos.length; j++) {

						var row = pos[i];
						var col = pos[j];

						if (this.modules[row][col] != null) {
							continue;
						}

						for (var r = -2; r <= 2; r++) {

							for (var c = -2; c <= 2; c++) {

								if (r == -2 || r == 2 || c == -2 || c == 2
								|| (r == 0 && c == 0)) {
									this.modules[row + r][col + c] = true;
								} else {
									this.modules[row + r][col + c] = false;
								}
							}
						}
					}
				}
			},

			setupTypeNumber: function (test) {

				var bits = QRCode.Util.getBCHTypeNumber(this.typeNumber);

				for (var i = 0; i < 18; i++) {
					var mod = (!test && ((bits >> i) & 1) == 1);
					this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
				}

				for (var i = 0; i < 18; i++) {
					var mod = (!test && ((bits >> i) & 1) == 1);
					this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
				}
			},

			setupTypeInfo: function (test, maskPattern) {

				var data = (this.errorCorrectLevel << 3) | maskPattern;
				var bits = QRCode.Util.getBCHTypeInfo(data);

				// vertical		
				for (var i = 0; i < 15; i++) {

					var mod = (!test && ((bits >> i) & 1) == 1);

					if (i < 6) {
						this.modules[i][8] = mod;
					} else if (i < 8) {
						this.modules[i + 1][8] = mod;
					} else {
						this.modules[this.moduleCount - 15 + i][8] = mod;
					}
				}

				// horizontal
				for (var i = 0; i < 15; i++) {

					var mod = (!test && ((bits >> i) & 1) == 1);

					if (i < 8) {
						this.modules[8][this.moduleCount - i - 1] = mod;
					} else if (i < 9) {
						this.modules[8][15 - i - 1 + 1] = mod;
					} else {
						this.modules[8][15 - i - 1] = mod;
					}
				}

				// fixed module
				this.modules[this.moduleCount - 8][8] = (!test);

			},

			mapData: function (data, maskPattern) {

				var inc = -1;
				var row = this.moduleCount - 1;
				var bitIndex = 7;
				var byteIndex = 0;

				for (var col = this.moduleCount - 1; col > 0; col -= 2) {

					if (col == 6) col--;

					while (true) {

						for (var c = 0; c < 2; c++) {

							if (this.modules[row][col - c] == null) {

								var dark = false;

								if (byteIndex < data.length) {
									dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
								}

								var mask = QRCode.Util.getMask(maskPattern, row, col - c);

								if (mask) {
									dark = !dark;
								}

								this.modules[row][col - c] = dark;
								bitIndex--;

								if (bitIndex == -1) {
									byteIndex++;
									bitIndex = 7;
								}
							}
						}

						row += inc;

						if (row < 0 || this.moduleCount <= row) {
							row -= inc;
							inc = -inc;
							break;
						}
					}
				}

			}

		};

		QRCode.PAD0 = 0xEC;
		QRCode.PAD1 = 0x11;

		QRCode.createData = function (typeNumber, errorCorrectLevel, dataList) {

			var rsBlocks = QRCode.RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);

			var buffer = new QRCode.BitBuffer();

			for (var i = 0; i < dataList.length; i++) {
				var data = dataList[i];
				buffer.put(data.mode, 4);
				buffer.put(data.getLength(), QRCode.Util.getLengthInBits(data.mode, typeNumber));
				data.write(buffer);
			}

			// calc num max data.
			var totalDataCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalDataCount += rsBlocks[i].dataCount;
			}

			if (buffer.getLengthInBits() > totalDataCount * 8) {
				throw new Error("code length overflow. ("
			+ buffer.getLengthInBits()
			+ ">"
			+ totalDataCount * 8
			+ ")");
			}

			// end code
			if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
				buffer.put(0, 4);
			}

			// padding
			while (buffer.getLengthInBits() % 8 != 0) {
				buffer.putBit(false);
			}

			// padding
			while (true) {

				if (buffer.getLengthInBits() >= totalDataCount * 8) {
					break;
				}
				buffer.put(QRCode.PAD0, 8);

				if (buffer.getLengthInBits() >= totalDataCount * 8) {
					break;
				}
				buffer.put(QRCode.PAD1, 8);
			}

			return QRCode.createBytes(buffer, rsBlocks);
		};

		QRCode.createBytes = function (buffer, rsBlocks) {

			var offset = 0;

			var maxDcCount = 0;
			var maxEcCount = 0;

			var dcdata = new Array(rsBlocks.length);
			var ecdata = new Array(rsBlocks.length);

			for (var r = 0; r < rsBlocks.length; r++) {

				var dcCount = rsBlocks[r].dataCount;
				var ecCount = rsBlocks[r].totalCount - dcCount;

				maxDcCount = Math.max(maxDcCount, dcCount);
				maxEcCount = Math.max(maxEcCount, ecCount);

				dcdata[r] = new Array(dcCount);

				for (var i = 0; i < dcdata[r].length; i++) {
					dcdata[r][i] = 0xff & buffer.buffer[i + offset];
				}
				offset += dcCount;

				var rsPoly = QRCode.Util.getErrorCorrectPolynomial(ecCount);
				var rawPoly = new QRCode.Polynomial(dcdata[r], rsPoly.getLength() - 1);

				var modPoly = rawPoly.mod(rsPoly);
				ecdata[r] = new Array(rsPoly.getLength() - 1);
				for (var i = 0; i < ecdata[r].length; i++) {
					var modIndex = i + modPoly.getLength() - ecdata[r].length;
					ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
				}

			}

			var totalCodeCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalCodeCount += rsBlocks[i].totalCount;
			}

			var data = new Array(totalCodeCount);
			var index = 0;

			for (var i = 0; i < maxDcCount; i++) {
				for (var r = 0; r < rsBlocks.length; r++) {
					if (i < dcdata[r].length) {
						data[index++] = dcdata[r][i];
					}
				}
			}

			for (var i = 0; i < maxEcCount; i++) {
				for (var r = 0; r < rsBlocks.length; r++) {
					if (i < ecdata[r].length) {
						data[index++] = ecdata[r][i];
					}
				}
			}

			return data;

		};

		//---------------------------------------------------------------------
		// QR8bitByte
		//---------------------------------------------------------------------
		QRCode.QR8bitByte = function (data) {
			this.mode = QRCode.Mode.MODE_8BIT_BYTE;
			this.data = data;
		}

		QRCode.QR8bitByte.prototype = {
			getLength: function (buffer) {
				return this.data.length;
			},

			write: function (buffer) {
				for (var i = 0; i < this.data.length; i++) {
					// not JIS ...
					buffer.put(this.data.charCodeAt(i), 8);
				}
			}
		};


		//---------------------------------------------------------------------
		// QRMode
		//---------------------------------------------------------------------
		QRCode.Mode = {
			MODE_NUMBER: 1 << 0,
			MODE_ALPHA_NUM: 1 << 1,
			MODE_8BIT_BYTE: 1 << 2,
			MODE_KANJI: 1 << 3
		};

		//---------------------------------------------------------------------
		// QRErrorCorrectLevel
		//---------------------------------------------------------------------
		QRCode.ErrorCorrectLevel = {
			L: 1,
			M: 0,
			Q: 3,
			H: 2
		};


		//---------------------------------------------------------------------
		// QRMaskPattern
		//---------------------------------------------------------------------
		QRCode.MaskPattern = {
			PATTERN000: 0,
			PATTERN001: 1,
			PATTERN010: 2,
			PATTERN011: 3,
			PATTERN100: 4,
			PATTERN101: 5,
			PATTERN110: 6,
			PATTERN111: 7
		};

		//---------------------------------------------------------------------
		// QRUtil
		//---------------------------------------------------------------------

		QRCode.Util = {

			PATTERN_POSITION_TABLE: [
		[],
		[6, 18],
		[6, 22],
		[6, 26],
		[6, 30],
		[6, 34],
		[6, 22, 38],
		[6, 24, 42],
		[6, 26, 46],
		[6, 28, 50],
		[6, 30, 54],
		[6, 32, 58],
		[6, 34, 62],
		[6, 26, 46, 66],
		[6, 26, 48, 70],
		[6, 26, 50, 74],
		[6, 30, 54, 78],
		[6, 30, 56, 82],
		[6, 30, 58, 86],
		[6, 34, 62, 90],
		[6, 28, 50, 72, 94],
		[6, 26, 50, 74, 98],
		[6, 30, 54, 78, 102],
		[6, 28, 54, 80, 106],
		[6, 32, 58, 84, 110],
		[6, 30, 58, 86, 114],
		[6, 34, 62, 90, 118],
		[6, 26, 50, 74, 98, 122],
		[6, 30, 54, 78, 102, 126],
		[6, 26, 52, 78, 104, 130],
		[6, 30, 56, 82, 108, 134],
		[6, 34, 60, 86, 112, 138],
		[6, 30, 58, 86, 114, 142],
		[6, 34, 62, 90, 118, 146],
		[6, 30, 54, 78, 102, 126, 150],
		[6, 24, 50, 76, 102, 128, 154],
		[6, 28, 54, 80, 106, 132, 158],
		[6, 32, 58, 84, 110, 136, 162],
		[6, 26, 54, 82, 110, 138, 166],
		[6, 30, 58, 86, 114, 142, 170]
	],

			G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
			G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
			G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),

			getBCHTypeInfo: function (data) {
				var d = data << 10;
				while (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G15) >= 0) {
					d ^= (QRCode.Util.G15 << (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G15)));
				}
				return ((data << 10) | d) ^ QRCode.Util.G15_MASK;
			},

			getBCHTypeNumber: function (data) {
				var d = data << 12;
				while (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G18) >= 0) {
					d ^= (QRCode.Util.G18 << (QRCode.Util.getBCHDigit(d) - QRCode.Util.getBCHDigit(QRCode.Util.G18)));
				}
				return (data << 12) | d;
			},

			getBCHDigit: function (data) {

				var digit = 0;

				while (data != 0) {
					digit++;
					data >>>= 1;
				}

				return digit;
			},

			getPatternPosition: function (typeNumber) {
				return QRCode.Util.PATTERN_POSITION_TABLE[typeNumber - 1];
			},

			getMask: function (maskPattern, i, j) {

				switch (maskPattern) {

					case QRCode.MaskPattern.PATTERN000: return (i + j) % 2 == 0;
					case QRCode.MaskPattern.PATTERN001: return i % 2 == 0;
					case QRCode.MaskPattern.PATTERN010: return j % 3 == 0;
					case QRCode.MaskPattern.PATTERN011: return (i + j) % 3 == 0;
					case QRCode.MaskPattern.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
					case QRCode.MaskPattern.PATTERN101: return (i * j) % 2 + (i * j) % 3 == 0;
					case QRCode.MaskPattern.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
					case QRCode.MaskPattern.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 == 0;

					default:
						throw new Error("bad maskPattern:" + maskPattern);
				}
			},

			getErrorCorrectPolynomial: function (errorCorrectLength) {

				var a = new QRCode.Polynomial([1], 0);

				for (var i = 0; i < errorCorrectLength; i++) {
					a = a.multiply(new QRCode.Polynomial([1, QRCode.Math.gexp(i)], 0));
				}

				return a;
			},

			getLengthInBits: function (mode, type) {

				if (1 <= type && type < 10) {

					// 1 - 9

					switch (mode) {
						case QRCode.Mode.MODE_NUMBER: return 10;
						case QRCode.Mode.MODE_ALPHA_NUM: return 9;
						case QRCode.Mode.MODE_8BIT_BYTE: return 8;
						case QRCode.Mode.MODE_KANJI: return 8;
						default:
							throw new Error("mode:" + mode);
					}

				} else if (type < 27) {

					// 10 - 26

					switch (mode) {
						case QRCode.Mode.MODE_NUMBER: return 12;
						case QRCode.Mode.MODE_ALPHA_NUM: return 11;
						case QRCode.Mode.MODE_8BIT_BYTE: return 16;
						case QRCode.Mode.MODE_KANJI: return 10;
						default:
							throw new Error("mode:" + mode);
					}

				} else if (type < 41) {

					// 27 - 40

					switch (mode) {
						case QRCode.Mode.MODE_NUMBER: return 14;
						case QRCode.Mode.MODE_ALPHA_NUM: return 13;
						case QRCode.Mode.MODE_8BIT_BYTE: return 16;
						case QRCode.Mode.MODE_KANJI: return 12;
						default:
							throw new Error("mode:" + mode);
					}

				} else {
					throw new Error("type:" + type);
				}
			},

			getLostPoint: function (qrCode) {

				var moduleCount = qrCode.getModuleCount();

				var lostPoint = 0;

				// LEVEL1

				for (var row = 0; row < moduleCount; row++) {

					for (var col = 0; col < moduleCount; col++) {

						var sameCount = 0;
						var dark = qrCode.isDark(row, col);

						for (var r = -1; r <= 1; r++) {

							if (row + r < 0 || moduleCount <= row + r) {
								continue;
							}

							for (var c = -1; c <= 1; c++) {

								if (col + c < 0 || moduleCount <= col + c) {
									continue;
								}

								if (r == 0 && c == 0) {
									continue;
								}

								if (dark == qrCode.isDark(row + r, col + c)) {
									sameCount++;
								}
							}
						}

						if (sameCount > 5) {
							lostPoint += (3 + sameCount - 5);
						}
					}
				}

				// LEVEL2

				for (var row = 0; row < moduleCount - 1; row++) {
					for (var col = 0; col < moduleCount - 1; col++) {
						var count = 0;
						if (qrCode.isDark(row, col)) count++;
						if (qrCode.isDark(row + 1, col)) count++;
						if (qrCode.isDark(row, col + 1)) count++;
						if (qrCode.isDark(row + 1, col + 1)) count++;
						if (count == 0 || count == 4) {
							lostPoint += 3;
						}
					}
				}

				// LEVEL3

				for (var row = 0; row < moduleCount; row++) {
					for (var col = 0; col < moduleCount - 6; col++) {
						if (qrCode.isDark(row, col)
						&& !qrCode.isDark(row, col + 1)
						&& qrCode.isDark(row, col + 2)
						&& qrCode.isDark(row, col + 3)
						&& qrCode.isDark(row, col + 4)
						&& !qrCode.isDark(row, col + 5)
						&& qrCode.isDark(row, col + 6)) {
							lostPoint += 40;
						}
					}
				}

				for (var col = 0; col < moduleCount; col++) {
					for (var row = 0; row < moduleCount - 6; row++) {
						if (qrCode.isDark(row, col)
						&& !qrCode.isDark(row + 1, col)
						&& qrCode.isDark(row + 2, col)
						&& qrCode.isDark(row + 3, col)
						&& qrCode.isDark(row + 4, col)
						&& !qrCode.isDark(row + 5, col)
						&& qrCode.isDark(row + 6, col)) {
							lostPoint += 40;
						}
					}
				}

				// LEVEL4

				var darkCount = 0;

				for (var col = 0; col < moduleCount; col++) {
					for (var row = 0; row < moduleCount; row++) {
						if (qrCode.isDark(row, col)) {
							darkCount++;
						}
					}
				}

				var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
				lostPoint += ratio * 10;

				return lostPoint;
			}

		};


		//---------------------------------------------------------------------
		// QRMath
		//---------------------------------------------------------------------

		QRCode.Math = {

			glog: function (n) {

				if (n < 1) {
					throw new Error("glog(" + n + ")");
				}

				return QRCode.Math.LOG_TABLE[n];
			},

			gexp: function (n) {

				while (n < 0) {
					n += 255;
				}

				while (n >= 256) {
					n -= 255;
				}

				return QRCode.Math.EXP_TABLE[n];
			},

			EXP_TABLE: new Array(256),

			LOG_TABLE: new Array(256)

		};

		for (var i = 0; i < 8; i++) {
			QRCode.Math.EXP_TABLE[i] = 1 << i;
		}
		for (var i = 8; i < 256; i++) {
			QRCode.Math.EXP_TABLE[i] = QRCode.Math.EXP_TABLE[i - 4]
		^ QRCode.Math.EXP_TABLE[i - 5]
		^ QRCode.Math.EXP_TABLE[i - 6]
		^ QRCode.Math.EXP_TABLE[i - 8];
		}
		for (var i = 0; i < 255; i++) {
			QRCode.Math.LOG_TABLE[QRCode.Math.EXP_TABLE[i]] = i;
		}

		//---------------------------------------------------------------------
		// QRPolynomial
		//---------------------------------------------------------------------

		QRCode.Polynomial = function (num, shift) {

			if (num.length == undefined) {
				throw new Error(num.length + "/" + shift);
			}

			var offset = 0;

			while (offset < num.length && num[offset] == 0) {
				offset++;
			}

			this.num = new Array(num.length - offset + shift);
			for (var i = 0; i < num.length - offset; i++) {
				this.num[i] = num[i + offset];
			}
		}

		QRCode.Polynomial.prototype = {

			get: function (index) {
				return this.num[index];
			},

			getLength: function () {
				return this.num.length;
			},

			multiply: function (e) {

				var num = new Array(this.getLength() + e.getLength() - 1);

				for (var i = 0; i < this.getLength(); i++) {
					for (var j = 0; j < e.getLength(); j++) {
						num[i + j] ^= QRCode.Math.gexp(QRCode.Math.glog(this.get(i)) + QRCode.Math.glog(e.get(j)));
					}
				}

				return new QRCode.Polynomial(num, 0);
			},

			mod: function (e) {

				if (this.getLength() - e.getLength() < 0) {
					return this;
				}

				var ratio = QRCode.Math.glog(this.get(0)) - QRCode.Math.glog(e.get(0));

				var num = new Array(this.getLength());

				for (var i = 0; i < this.getLength(); i++) {
					num[i] = this.get(i);
				}

				for (var i = 0; i < e.getLength(); i++) {
					num[i] ^= QRCode.Math.gexp(QRCode.Math.glog(e.get(i)) + ratio);
				}

				// recursive call
				return new QRCode.Polynomial(num, 0).mod(e);
			}
		};

		//---------------------------------------------------------------------
		// QRRSBlock
		//---------------------------------------------------------------------

		QRCode.RSBlock = function (totalCount, dataCount) {
			this.totalCount = totalCount;
			this.dataCount = dataCount;
		}

		QRCode.RSBlock.RS_BLOCK_TABLE = [

		// L
		// M
		// Q
		// H

		// 1
	[1, 26, 19],
	[1, 26, 16],
	[1, 26, 13],
	[1, 26, 9],

		// 2
	[1, 44, 34],
	[1, 44, 28],
	[1, 44, 22],
	[1, 44, 16],

		// 3
	[1, 70, 55],
	[1, 70, 44],
	[2, 35, 17],
	[2, 35, 13],

		// 4		
	[1, 100, 80],
	[2, 50, 32],
	[2, 50, 24],
	[4, 25, 9],

		// 5
	[1, 134, 108],
	[2, 67, 43],
	[2, 33, 15, 2, 34, 16],
	[2, 33, 11, 2, 34, 12],

		// 6
	[2, 86, 68],
	[4, 43, 27],
	[4, 43, 19],
	[4, 43, 15],

		// 7		
	[2, 98, 78],
	[4, 49, 31],
	[2, 32, 14, 4, 33, 15],
	[4, 39, 13, 1, 40, 14],

		// 8
	[2, 121, 97],
	[2, 60, 38, 2, 61, 39],
	[4, 40, 18, 2, 41, 19],
	[4, 40, 14, 2, 41, 15],

		// 9
	[2, 146, 116],
	[3, 58, 36, 2, 59, 37],
	[4, 36, 16, 4, 37, 17],
	[4, 36, 12, 4, 37, 13],

		// 10		
	[2, 86, 68, 2, 87, 69],
	[4, 69, 43, 1, 70, 44],
	[6, 43, 19, 2, 44, 20],
	[6, 43, 15, 2, 44, 16]

];

		QRCode.RSBlock.getRSBlocks = function (typeNumber, errorCorrectLevel) {

			var rsBlock = QRCode.RSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);

			if (rsBlock == undefined) {
				throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
			}

			var length = rsBlock.length / 3;

			var list = new Array();

			for (var i = 0; i < length; i++) {

				var count = rsBlock[i * 3 + 0];
				var totalCount = rsBlock[i * 3 + 1];
				var dataCount = rsBlock[i * 3 + 2];

				for (var j = 0; j < count; j++) {
					list.push(new QRCode.RSBlock(totalCount, dataCount));
				}
			}

			return list;
		};

		QRCode.RSBlock.getRsBlockTable = function (typeNumber, errorCorrectLevel) {

			switch (errorCorrectLevel) {
				case QRCode.ErrorCorrectLevel.L:
					return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
				case QRCode.ErrorCorrectLevel.M:
					return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
				case QRCode.ErrorCorrectLevel.Q:
					return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
				case QRCode.ErrorCorrectLevel.H:
					return QRCode.RSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
				default:
					return undefined;
			}
		};

		//---------------------------------------------------------------------
		// QRBitBuffer
		//---------------------------------------------------------------------

		QRCode.BitBuffer = function () {
			this.buffer = new Array();
			this.length = 0;
		}

		QRCode.BitBuffer.prototype = {

			get: function (index) {
				var bufIndex = Math.floor(index / 8);
				return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
			},

			put: function (num, length) {
				for (var i = 0; i < length; i++) {
					this.putBit(((num >>> (length - i - 1)) & 1) == 1);
				}
			},

			getLengthInBits: function () {
				return this.length;
			},

			putBit: function (bit) {

				var bufIndex = Math.floor(this.length / 8);
				if (this.buffer.length <= bufIndex) {
					this.buffer.push(0);
				}

				if (bit) {
					this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
				}

				this.length++;
			}
		};
	})();
	</script>

	<script type="text/javascript">
		/*
		* Copyright (c) 2010-2011 Intalio Pte, All Rights Reserved
		* 
		* Permission is hereby granted, free of charge, to any person obtaining a copy
		* of this software and associated documentation files (the "Software"), to deal
		* in the Software without restriction, including without limitation the rights
		* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		* copies of the Software, and to permit persons to whom the Software is
		* furnished to do so, subject to the following conditions:
		* 
		* The above copyright notice and this permission notice shall be included in
		* all copies or substantial portions of the Software.
		* 
		* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
		* THE SOFTWARE.
		*/
		// https://github.com/cheongwy/node-scrypt-js
		(function() {
		
		var MAX_VALUE = 2147483647;
		var workerUrl = null;
		
		//function scrypt(byte[] passwd, byte[] salt, int N, int r, int p, int dkLen)
		/*
		 * N = Cpu cost
		 * r = Memory cost
		 * p = parallelization cost
		 * 
		 */
		window.Crypto_scrypt = function(passwd, salt, N, r, p, dkLen, callback) {
		    if (N == 0 || (N & (N - 1)) != 0) throw Error("N must be > 0 and a power of 2");
		
		    if (N > MAX_VALUE / 128 / r) throw Error("Parameter N is too large");
		    if (r > MAX_VALUE / 128 / p) throw Error("Parameter r is too large");
		
			var PBKDF2_opts = {iterations: 1, hasher: Crypto.SHA256, asBytes: true};
		
		    var B = Crypto.PBKDF2(passwd, salt, p * 128 * r, PBKDF2_opts);
		    
			try {
				var i = 0;
				var worksDone = 0;
				var makeWorker = function() {
					if (!workerUrl) {
						var code = '('+scryptCore.toString()+')()';
						var blob;
						try {
							blob = new Blob([code], {type: "text/javascript"});
						} catch(e) {
							window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
							blob = new BlobBuilder();
							blob.append(code);
							blob = blob.getBlob("text/javascript");
						}
						workerUrl = URL.createObjectURL(blob);
					}
					var worker = new Worker(workerUrl);
					worker.onmessage = function(event) {
						var Bi = event.data[0], Bslice = event.data[1];
						worksDone++;
	
						if (i < p) {
							worker.postMessage([N, r, p, B, i++]);
						}
	
						var length = Bslice.length, destPos = Bi * 128 * r, srcPos = 0;
						while (length--) {
							B[destPos++] = Bslice[srcPos++];
						}
	
						if (worksDone == p) {
							callback(Crypto.PBKDF2(passwd, B, dkLen, PBKDF2_opts));
						}
					};
					return worker;
				};
				var workers = [makeWorker(), makeWorker()];
				workers[0].postMessage([N, r, p, B, i++]);
				if (p > 1) {
					workers[1].postMessage([N, r, p, B, i++]);
				}
			} catch (e) {
				window.setTimeout(function() {
					scryptCore();
					callback(Crypto.PBKDF2(passwd, B, dkLen, PBKDF2_opts));
				}, 0);
			}

			// using this function to enclose everything needed to create a worker (but also invokable directly for synchronous use)
			function scryptCore() {
				var XY = [], V = [];

				if (typeof B === 'undefined') {
					onmessage = function(event) {
						var data = event.data;
						var N = data[0], r = data[1], p = data[2], B = data[3], i = data[4];
					
						var Bslice = [];
						arraycopy32(B, i * 128 * r, Bslice, 0, 128 * r);
						smix(Bslice, 0, r, N, V, XY);
					
						postMessage([i, Bslice]);
					};
				} else {
					for(var i = 0; i < p; i++) {
						smix(B, i * 128 * r, r, N, V, XY);
					}
				}
				
				function smix(B, Bi, r, N, V, XY) {
					var Xi = 0;
					var Yi = 128 * r;
					var i;
				
					arraycopy32(B, Bi, XY, Xi, Yi);
					
					for (i = 0; i < N; i++) {
						arraycopy32(XY, Xi, V, i * Yi, Yi);
						blockmix_salsa8(XY, Xi, Yi, r);
					}
				
					for (i = 0; i < N; i++) {
						var j = integerify(XY, Xi, r) & (N - 1);
						blockxor(V, j * Yi, XY, Xi, Yi);
						blockmix_salsa8(XY, Xi, Yi, r);
					}
				
					arraycopy32(XY, Xi, B, Bi, Yi);
				}
				
				function blockmix_salsa8(BY, Bi, Yi, r) {
					var X = [];
					var i;
				
					arraycopy32(BY, Bi + (2 * r - 1) * 64, X, 0, 64);
					
					for (i = 0; i < 2 * r; i++) {
						blockxor(BY, i * 64, X, 0, 64);
						salsa20_8(X);
						arraycopy32(X, 0, BY, Yi + (i * 64), 64);
					}
				
					for (i = 0; i < r; i++) {
						arraycopy32(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64);
					}
				
					for (i = 0; i < r; i++) {
						arraycopy32(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64);
					}
				}
				
				function R(a, b) {
					return (a << b) | (a >>> (32 - b));
				}
				
				function salsa20_8(B) {
					var B32 = new Array(32);
					var x   = new Array(32);
					var i;
				
					for (i = 0; i < 16; i++) {
						B32[i]  = (B[i * 4 + 0] & 0xff) << 0;
						B32[i] |= (B[i * 4 + 1] & 0xff) << 8;
						B32[i] |= (B[i * 4 + 2] & 0xff) << 16;
						B32[i] |= (B[i * 4 + 3] & 0xff) << 24;
					}
				
					arraycopy(B32, 0, x, 0, 16);
				
					for (i = 8; i > 0; i -= 2) {
						x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
						x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
						x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
						x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
						x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
						x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
						x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
						x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
						x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
						x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
						x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
						x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
						x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
						x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
						x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
						x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
					}
				
					for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i];
					
					for (i = 0; i < 16; i++) {
						var bi = i * 4;
						B[bi + 0] = (B32[i] >> 0  & 0xff);
						B[bi + 1] = (B32[i] >> 8  & 0xff);
						B[bi + 2] = (B32[i] >> 16 & 0xff);
						B[bi + 3] = (B32[i] >> 24 & 0xff);
					}
				}
				
				function blockxor(S, Si, D, Di, len) {
					var i = len>>6;
					while (i--) {
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
						D[Di++] ^= S[Si++]; D[Di++] ^= S[Si++];
					}		
				}
				
				function integerify(B, bi, r) {
					var n;
					
					bi += (2 * r - 1) * 64;
				
					n  = (B[bi + 0] & 0xff) << 0;
					n |= (B[bi + 1] & 0xff) << 8;
					n |= (B[bi + 2] & 0xff) << 16;
					n |= (B[bi + 3] & 0xff) << 24;
				
					return n;
				}
				
				function arraycopy(src, srcPos, dest, destPos, length) {
					 while (length-- ){
						 dest[destPos++] = src[srcPos++];
					 }	
				}

				function arraycopy32(src, srcPos, dest, destPos, length) {
					var i = length>>5;
					while(i--) {
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						 
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];	
						
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						 
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];
						dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++];			
					}
				}
			} // scryptCore
		}; // window.Crypto_scrypt
		})();
	</script>

	<script type="text/javascript">
		/*
		Copyright (c) 2011 Stefan Thomas

		Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		*/

		//https://raw.github.com/bitcoinjs/bitcoinjs-lib/1a7fc9d063f864058809d06ef4542af40be3558f/src/bitcoin.js
		(function (exports) {
			var Bitcoin = exports;
		})(
			'object' === typeof module ? module.exports : (window.Bitcoin = {})
		);
	</script>

	<script type="text/javascript">
		//https://raw.github.com/bitcoinjs/bitcoinjs-lib/c952aaeb3ee472e3776655b8ea07299ebed702c7/src/base58.js
		(function (Bitcoin) {
			Bitcoin.Base58 = {
				alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
				validRegex: /^[1-9A-HJ-NP-Za-km-z]+$/,
				base: BigInteger.valueOf(58),

				/**
				* Convert a byte array to a base58-encoded string.
				*
				* Written by Mike Hearn for BitcoinJ.
				*   Copyright (c) 2011 Google Inc.
				*
				* Ported to JavaScript by Stefan Thomas.
				*/
				encode: function (input) {
					var bi = BigInteger.fromByteArrayUnsigned(input);
					var chars = [];

					while (bi.compareTo(B58.base) >= 0) {
						var mod = bi.mod(B58.base);
						chars.unshift(B58.alphabet[mod.intValue()]);
						bi = bi.subtract(mod).divide(B58.base);
					}
					chars.unshift(B58.alphabet[bi.intValue()]);

					// Convert leading zeros too.
					for (var i = 0; i < input.length; i++) {
						if (input[i] == 0x00) {
							chars.unshift(B58.alphabet[0]);
						} else break;
					}

					return chars.join('');
				},

				/**
				* Convert a base58-encoded string to a byte array.
				*
				* Written by Mike Hearn for BitcoinJ.
				*   Copyright (c) 2011 Google Inc.
				*
				* Ported to JavaScript by Stefan Thomas.
				*/
				decode: function (input) {
					var bi = BigInteger.valueOf(0);
					var leadingZerosNum = 0;
					for (var i = input.length - 1; i >= 0; i--) {
						var alphaIndex = B58.alphabet.indexOf(input[i]);
						if (alphaIndex < 0) {
							throw "Invalid character";
						}
						bi = bi.add(BigInteger.valueOf(alphaIndex)
								.multiply(B58.base.pow(input.length - 1 - i)));

						// This counts leading zero bytes
						if (input[i] == "1") leadingZerosNum++;
						else leadingZerosNum = 0;
					}
					var bytes = bi.toByteArrayUnsigned();

					// Add leading zeros
					while (leadingZerosNum-- > 0) bytes.unshift(0);

					return bytes;
				}
			};

			var B58 = Bitcoin.Base58;
		})(
		'undefined' != typeof Bitcoin ? Bitcoin : module.exports
		);
	</script>

	<script type="text/javascript">
		//https://raw.github.com/bitcoinjs/bitcoinjs-lib/09e8c6e184d6501a0c2c59d73ca64db5c0d3eb95/src/address.js
		Bitcoin.Address = function (bytes) {
			if ("string" == typeof bytes) {
				bytes = Bitcoin.Address.decodeString(bytes);
			}
			this.hash = bytes;
			this.version = Bitcoin.Address.networkVersion;
		};

		Bitcoin.Address.networkVersion = 0x00; // mainnet -- DEFAULT is Bitcoin

		/**
		* Serialize this object as a standard Bitcoin address.
		*
		* Returns the address as a base58-encoded string in the standardized format.
		*/
		Bitcoin.Address.prototype.toString = function () {
			// Get a copy of the hash
			var hash = this.hash.slice(0);

			// Version
			hash.unshift(this.version);
			var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
			var bytes = hash.concat(checksum.slice(0, 4));
			return Bitcoin.Base58.encode(bytes);
		};

		Bitcoin.Address.prototype.getHashBase64 = function () {
			return Crypto.util.bytesToBase64(this.hash);
		};

		/**
		* Parse a Bitcoin address contained in a string.
		*/
		Bitcoin.Address.decodeString = function (string) {
			var bytes = Bitcoin.Base58.decode(string);
			var hash = bytes.slice(0, 21);
			var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });

			if (checksum[0] != bytes[21] ||
			checksum[1] != bytes[22] ||
			checksum[2] != bytes[23] ||
			checksum[3] != bytes[24]) {
				throw "Checksum validation failed!";
			}

			var version = hash.shift();

			if (version != 0) {
				throw "Version " + version + " not supported!";
			}

			return hash;
		};
	</script>

	<script type="text/javascript">
		//https://raw.github.com/bitcoinjs/bitcoinjs-lib/e90780d3d3b8fc0d027d2bcb38b80479902f223e/src/ecdsa.js
		Bitcoin.ECDSA = (function () {
			var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
			var rng = new SecureRandom();

			var P_OVER_FOUR = null;

			function implShamirsTrick(P, k, Q, l) {
				var m = Math.max(k.bitLength(), l.bitLength());
				var Z = P.add2D(Q);
				var R = P.curve.getInfinity();

				for (var i = m - 1; i >= 0; --i) {
					R = R.twice2D();

					R.z = BigInteger.ONE;

					if (k.testBit(i)) {
						if (l.testBit(i)) {
							R = R.add2D(Z);
						} else {
							R = R.add2D(P);
						}
					} else {
						if (l.testBit(i)) {
							R = R.add2D(Q);
						}
					}
				}

				return R;
			};

			var ECDSA = {
				getBigRandom: function (limit) {
					return new BigInteger(limit.bitLength(), rng)
				.mod(limit.subtract(BigInteger.ONE))
				.add(BigInteger.ONE);
				},
				sign: function (hash, priv) {
					var d = priv;
					var n = ecparams.getN();
					var e = BigInteger.fromByteArrayUnsigned(hash);

					do {
						var k = ECDSA.getBigRandom(n);
						var G = ecparams.getG();
						var Q = G.multiply(k);
						var r = Q.getX().toBigInteger().mod(n);
					} while (r.compareTo(BigInteger.ZERO) <= 0);

					var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);

					return ECDSA.serializeSig(r, s);
				},

				verify: function (hash, sig, pubkey) {
					var r, s;
					if (Bitcoin.Util.isArray(sig)) {
						var obj = ECDSA.parseSig(sig);
						r = obj.r;
						s = obj.s;
					} else if ("object" === typeof sig && sig.r && sig.s) {
						r = sig.r;
						s = sig.s;
					} else {
						throw "Invalid value for signature";
					}

					var Q;
					if (pubkey instanceof ec.PointFp) {
						Q = pubkey;
					} else if (Bitcoin.Util.isArray(pubkey)) {
						Q = EllipticCurve.PointFp.decodeFrom(ecparams.getCurve(), pubkey);
					} else {
						throw "Invalid format for pubkey value, must be byte array or ec.PointFp";
					}
					var e = BigInteger.fromByteArrayUnsigned(hash);

					return ECDSA.verifyRaw(e, r, s, Q);
				},

				verifyRaw: function (e, r, s, Q) {
					var n = ecparams.getN();
					var G = ecparams.getG();

					if (r.compareTo(BigInteger.ONE) < 0 ||
          r.compareTo(n) >= 0)
						return false;

					if (s.compareTo(BigInteger.ONE) < 0 ||
          s.compareTo(n) >= 0)
						return false;

					var c = s.modInverse(n);

					var u1 = e.multiply(c).mod(n);
					var u2 = r.multiply(c).mod(n);

					// TODO(!!!): For some reason Shamir's trick isn't working with
					// signed message verification!? Probably an implementation
					// error!
					//var point = implShamirsTrick(G, u1, Q, u2);
					var point = G.multiply(u1).add(Q.multiply(u2));

					var v = point.getX().toBigInteger().mod(n);

					return v.equals(r);
				},

				/**
				* Serialize a signature into DER format.
				*
				* Takes two BigIntegers representing r and s and returns a byte array.
				*/
				serializeSig: function (r, s) {
					var rBa = r.toByteArraySigned();
					var sBa = s.toByteArraySigned();

					var sequence = [];
					sequence.push(0x02); // INTEGER
					sequence.push(rBa.length);
					sequence = sequence.concat(rBa);

					sequence.push(0x02); // INTEGER
					sequence.push(sBa.length);
					sequence = sequence.concat(sBa);

					sequence.unshift(sequence.length);
					sequence.unshift(0x30); // SEQUENCE

					return sequence;
				},

				/**
				* Parses a byte array containing a DER-encoded signature.
				*
				* This function will return an object of the form:
				* 
				* {
				*   r: BigInteger,
				*   s: BigInteger
				* }
				*/
				parseSig: function (sig) {
					var cursor;
					if (sig[0] != 0x30)
						throw new Error("Signature not a valid DERSequence");

					cursor = 2;
					if (sig[cursor] != 0x02)
						throw new Error("First element in signature must be a DERInteger"); ;
					var rBa = sig.slice(cursor + 2, cursor + 2 + sig[cursor + 1]);

					cursor += 2 + sig[cursor + 1];
					if (sig[cursor] != 0x02)
						throw new Error("Second element in signature must be a DERInteger");
					var sBa = sig.slice(cursor + 2, cursor + 2 + sig[cursor + 1]);

					cursor += 2 + sig[cursor + 1];

					//if (cursor != sig.length)
					//	throw new Error("Extra bytes in signature");

					var r = BigInteger.fromByteArrayUnsigned(rBa);
					var s = BigInteger.fromByteArrayUnsigned(sBa);

					return { r: r, s: s };
				},

				parseSigCompact: function (sig) {
					if (sig.length !== 65) {
						throw "Signature has the wrong length";
					}

					// Signature is prefixed with a type byte storing three bits of
					// information.
					var i = sig[0] - 27;
					if (i < 0 || i > 7) {
						throw "Invalid signature type";
					}

					var n = ecparams.getN();
					var r = BigInteger.fromByteArrayUnsigned(sig.slice(1, 33)).mod(n);
					var s = BigInteger.fromByteArrayUnsigned(sig.slice(33, 65)).mod(n);

					return { r: r, s: s, i: i };
				},

				/**
				* Recover a public key from a signature.
				*
				* See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
				* Key Recovery Operation".
				*
				* http://www.secg.org/download/aid-780/sec1-v2.pdf
				*/
				recoverPubKey: function (r, s, hash, i) {
					// The recovery parameter i has two bits.
					i = i & 3;

					// The less significant bit specifies whether the y coordinate
					// of the compressed point is even or not.
					var isYEven = i & 1;

					// The more significant bit specifies whether we should use the
					// first or second candidate key.
					var isSecondKey = i >> 1;

					var n = ecparams.getN();
					var G = ecparams.getG();
					var curve = ecparams.getCurve();
					var p = curve.getQ();
					var a = curve.getA().toBigInteger();
					var b = curve.getB().toBigInteger();

					// We precalculate (p + 1) / 4 where p is if the field order
					if (!P_OVER_FOUR) {
						P_OVER_FOUR = p.add(BigInteger.ONE).divide(BigInteger.valueOf(4));
					}

					// 1.1 Compute x
					var x = isSecondKey ? r.add(n) : r;

					// 1.3 Convert x to point
					var alpha = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);
					var beta = alpha.modPow(P_OVER_FOUR, p);

					var xorOdd = beta.isEven() ? (i % 2) : ((i + 1) % 2);
					// If beta is even, but y isn't or vice versa, then convert it,
					// otherwise we're done and y == beta.
					var y = (beta.isEven() ? !isYEven : isYEven) ? beta : p.subtract(beta);

					// 1.4 Check that nR is at infinity
					var R = new EllipticCurve.PointFp(curve,
                            curve.fromBigInteger(x),
                            curve.fromBigInteger(y));
					R.validate();

					// 1.5 Compute e from M
					var e = BigInteger.fromByteArrayUnsigned(hash);
					var eNeg = BigInteger.ZERO.subtract(e).mod(n);

					// 1.6 Compute Q = r^-1 (sR - eG)
					var rInv = r.modInverse(n);
					var Q = implShamirsTrick(R, s, G, eNeg).multiply(rInv);

					Q.validate();
					if (!ECDSA.verifyRaw(e, r, s, Q)) {
						throw "Pubkey recovery unsuccessful";
					}

					var pubKey = new Bitcoin.ECKey();
					pubKey.pub = Q;
					return pubKey;
				},

				/**
				* Calculate pubkey extraction parameter.
				*
				* When extracting a pubkey from a signature, we have to
				* distinguish four different cases. Rather than putting this
				* burden on the verifier, Bitcoin includes a 2-bit value with the
				* signature.
				*
				* This function simply tries all four cases and returns the value
				* that resulted in a successful pubkey recovery.
				*/
				calcPubkeyRecoveryParam: function (address, r, s, hash) {
					for (var i = 0; i < 4; i++) {
						try {
							var pubkey = Bitcoin.ECDSA.recoverPubKey(r, s, hash, i);
							if (pubkey.getBitcoinAddress().toString() == address) {
								return i;
							}
						} catch (e) { }
					}
					throw "Unable to find valid recovery factor";
				}
			};

			return ECDSA;
		})();
	</script>

	<script type="text/javascript">
		//https://raw.github.com/pointbiz/bitcoinjs-lib/9b2f94a028a7bc9bed94e0722563e9ff1d8e8db8/src/eckey.js
		Bitcoin.ECKey = (function () {
			var ECDSA = Bitcoin.ECDSA;
			var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
			var rng = new SecureRandom();

			var ECKey = function (input) {
				if (!input) {
					// Generate new key
					var n = ecparams.getN();
					this.priv = ECDSA.getBigRandom(n);
				} else if (input instanceof BigInteger) {
					// Input is a private key value
					this.priv = input;
				} else if (Bitcoin.Util.isArray(input)) {
					// Prepend zero byte to prevent interpretation as negative integer
					this.priv = BigInteger.fromByteArrayUnsigned(input);
				} else if ("string" == typeof input) {
					var bytes = null;
					if (ECKey.isWalletImportFormat(input)) {
						bytes = ECKey.decodeWalletImportFormat(input);
					} else if (ECKey.isCompressedWalletImportFormat(input)) {
						bytes = ECKey.decodeCompressedWalletImportFormat(input);
						this.compressed = true;
					} else if (ECKey.isMiniFormat(input)) {
						bytes = Crypto.SHA256(input, { asBytes: true });
					} else if (ECKey.isHexFormat(input)) {
						bytes = Crypto.util.hexToBytes(input);
					} else if (ECKey.isBase64Format(input)) {
						bytes = Crypto.util.base64ToBytes(input);
					}

					if (bytes == null || bytes.length != 32) {
						this.priv = null;
					} else {
						// Prepend zero byte to prevent interpretation as negative integer
						this.priv = BigInteger.fromByteArrayUnsigned(bytes);
					}
				}

				this.compressed = (this.compressed == undefined) ? !!ECKey.compressByDefault : this.compressed;
			};

			ECKey.privateKeyPrefix = 0x80; // mainnet 0x80    testnet 0xEF - DEFAULT is BITCOIN

			/**
			* Whether public keys should be returned compressed by default.
			*/
			ECKey.compressByDefault = false;

			/**
			* Set whether the public key should be returned compressed or not.
			*/
			ECKey.prototype.setCompressed = function (v) {
				this.compressed = !!v;
				if (this.pubPoint) this.pubPoint.compressed = this.compressed;
			};

			/*
			* Return public key as a byte array in DER encoding
			*/
			ECKey.prototype.getPub = function () {
				if (this.compressed) {
					if (this.pubComp) return this.pubComp;
					return this.pubComp = this.getPubPoint().getEncoded(1);
				} else {
					if (this.pubUncomp) return this.pubUncomp;
					return this.pubUncomp = this.getPubPoint().getEncoded(0);
				}
			};

			/**
			* Return public point as ECPoint object.
			*/
			ECKey.prototype.getPubPoint = function () {
				if (!this.pubPoint) {
					this.pubPoint = ecparams.getG().multiply(this.priv);
					this.pubPoint.compressed = this.compressed;
				}
				return this.pubPoint;
			};

			ECKey.prototype.getPubKeyHex = function () {
				if (this.compressed) {
					if (this.pubKeyHexComp) return this.pubKeyHexComp;
					return this.pubKeyHexComp = Crypto.util.bytesToHex(this.getPub()).toString().toUpperCase();
				} else {
					if (this.pubKeyHexUncomp) return this.pubKeyHexUncomp;
					return this.pubKeyHexUncomp = Crypto.util.bytesToHex(this.getPub()).toString().toUpperCase();
				}
			};

			/**
			* Get the pubKeyHash for this key.
			*
			* This is calculated as RIPE160(SHA256([encoded pubkey])) and returned as
			* a byte array.
			*/
			ECKey.prototype.getPubKeyHash = function () {
				if (this.compressed) {
					if (this.pubKeyHashComp) return this.pubKeyHashComp;
					return this.pubKeyHashComp = Bitcoin.Util.sha256ripe160(this.getPub());
				} else {
					if (this.pubKeyHashUncomp) return this.pubKeyHashUncomp;
					return this.pubKeyHashUncomp = Bitcoin.Util.sha256ripe160(this.getPub());
				}
			};

			ECKey.prototype.getBitcoinAddress = function () {
				var hash = this.getPubKeyHash();
				var addr = new Bitcoin.Address(hash);
				return addr.toString();
			};

			/*
			* Takes a public point as a hex string or byte array
			*/
			ECKey.prototype.setPub = function (pub) {
				// byte array
				if (Bitcoin.Util.isArray(pub)) {
					pub = Crypto.util.bytesToHex(pub).toString().toUpperCase();
				}
				var ecPoint = ecparams.getCurve().decodePointHex(pub);
				this.setCompressed(ecPoint.compressed);
				this.pubPoint = ecPoint;
			};

			// Sipa Private Key Wallet Import Format 
			ECKey.prototype.getBitcoinWalletImportFormat = function () {
				var bytes = this.getBitcoinPrivateKeyByteArray();
				bytes.unshift(ECKey.privateKeyPrefix); // prepend 0x80 byte
				if (this.compressed) bytes.push(0x01); // append 0x01 byte for compressed format
				var checksum = Crypto.SHA256(Crypto.SHA256(bytes, { asBytes: true }), { asBytes: true });
				bytes = bytes.concat(checksum.slice(0, 4));
				var privWif = Bitcoin.Base58.encode(bytes);
				return privWif;
			};

			// Private Key Hex Format 
			ECKey.prototype.getBitcoinHexFormat = function () {
				return Crypto.util.bytesToHex(this.getBitcoinPrivateKeyByteArray()).toString().toUpperCase();
			};

			// Private Key Base64 Format 
			ECKey.prototype.getBitcoinBase64Format = function () {
				return Crypto.util.bytesToBase64(this.getBitcoinPrivateKeyByteArray());
			};

			ECKey.prototype.getBitcoinPrivateKeyByteArray = function () {
				// Get a copy of private key as a byte array
				var bytes = this.priv.toByteArrayUnsigned();
				// zero pad if private key is less than 32 bytes 
				while (bytes.length < 32) bytes.unshift(0x00);
				return bytes;
			};

			ECKey.prototype.toString = function (format) {
				format = format || "";
				if (format.toString().toLowerCase() == "base64" || format.toString().toLowerCase() == "b64") {
					return this.getBitcoinBase64Format();
				}
				// Wallet Import Format
				else if (format.toString().toLowerCase() == "wif") {
					return this.getBitcoinWalletImportFormat();
				}
				else {
					return this.getBitcoinHexFormat();
				}
			};

			ECKey.prototype.sign = function (hash) {
				return ECDSA.sign(hash, this.priv);
			};

			ECKey.prototype.verify = function (hash, sig) {
				return ECDSA.verify(hash, sig, this.getPub());
			};

			/**
			* Parse a wallet import format private key contained in a string.
			*/
			ECKey.decodeWalletImportFormat = function (privStr) {
				var bytes = Bitcoin.Base58.decode(privStr);
				var hash = bytes.slice(0, 33);
				var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
				if (checksum[0] != bytes[33] ||
					checksum[1] != bytes[34] ||
					checksum[2] != bytes[35] ||
					checksum[3] != bytes[36]) {
					throw "Checksum validation failed!";
				}
				var version = hash.shift();
				if (version != ECKey.privateKeyPrefix) {
					throw "Version " + version + " not supported!";
				}
				return hash;
			};

			/**
			* Parse a compressed wallet import format private key contained in a string.
			*/
			ECKey.decodeCompressedWalletImportFormat = function (privStr) {
				var bytes = Bitcoin.Base58.decode(privStr);
				var hash = bytes.slice(0, 34);
				var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
				if (checksum[0] != bytes[34] ||
					checksum[1] != bytes[35] ||
					checksum[2] != bytes[36] ||
					checksum[3] != bytes[37]) {
					throw "Checksum validation failed!";
				}
				var version = hash.shift();
				if (version != ECKey.privateKeyPrefix) {
					throw "Version " + version + " not supported!";
				}
				hash.pop();
				return hash;
			};

			// 64 characters [0-9A-F]
			ECKey.isHexFormat = function (key) {
				key = key.toString();
				return /^[A-Fa-f0-9]{64}$/.test(key);
			};

			// 51 characters base58, always starts with a '5'
			ECKey.isWalletImportFormat = function (key) {
				key = key.toString();
				var prefix = 5; //Default is bitcoin
				if(ECKey.privateKeyPrefix == 0xb0) prefix = 6;
				var keyregex = new RegExp("^"+prefix+"[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}$");
				return keyregex.test(key);
				/*return (ECKey.privateKeyPrefix == 0x80) ?
							(/^5[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}$/.test(key)) :
							(/^9[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}$/.test(key));*/
			};

			// 52 characters base58
			ECKey.isCompressedWalletImportFormat = function (key) {
				key = key.toString();
				return (ECKey.privateKeyPrefix == 0x80) ?
							(/^[LK][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}$/.test(key)) :
							(/^c[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}$/.test(key));
			};

			// 44 characters
			ECKey.isBase64Format = function (key) {
				key = key.toString();
				return (/^[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=+\/]{44}$/.test(key));
			};

			// 22, 26 or 30 characters, always starts with an 'S'
			ECKey.isMiniFormat = function (key) {
				key = key.toString();
				var validChars22 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}$/.test(key);
				var validChars26 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}$/.test(key);
				var validChars30 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}$/.test(key);
				var testBytes = Crypto.SHA256(key + "?", { asBytes: true });

				return ((testBytes[0] === 0x00 || testBytes[0] === 0x01) && (validChars22 || validChars26 || validChars30));
			};

			return ECKey;
		})();
	</script>

	<script type="text/javascript">
		//https://raw.github.com/bitcoinjs/bitcoinjs-lib/09e8c6e184d6501a0c2c59d73ca64db5c0d3eb95/src/util.js
		// Bitcoin utility functions
		Bitcoin.Util = {
			/**
			* Cross-browser compatibility version of Array.isArray.
			*/
			isArray: Array.isArray || function (o) {
				return Object.prototype.toString.call(o) === '[object Array]';
			},
			/**
			* Create an array of a certain length filled with a specific value.
			*/
			makeFilledArray: function (len, val) {
				var array = [];
				var i = 0;
				while (i < len) {
					array[i++] = val;
				}
				return array;
			},
			/**
			* Turn an integer into a "var_int".
			*
			* "var_int" is a variable length integer used by Bitcoin's binary format.
			*
			* Returns a byte array.
			*/
			numToVarInt: function (i) {
				if (i < 0xfd) {
					// unsigned char
					return [i];
				} else if (i <= 1 << 16) {
					// unsigned short (LE)
					return [0xfd, i >>> 8, i & 255];
				} else if (i <= 1 << 32) {
					// unsigned int (LE)
					return [0xfe].concat(Crypto.util.wordsToBytes([i]));
				} else {
					// unsigned long long (LE)
					return [0xff].concat(Crypto.util.wordsToBytes([i >>> 32, i]));
				}
			},
			/**
			* Parse a Bitcoin value byte array, returning a BigInteger.
			*/
			valueToBigInt: function (valueBuffer) {
				if (valueBuffer instanceof BigInteger) return valueBuffer;

				// Prepend zero byte to prevent interpretation as negative integer
				return BigInteger.fromByteArrayUnsigned(valueBuffer);
			},
			/**
			* Format a Bitcoin value as a string.
			*
			* Takes a BigInteger or byte-array and returns that amount of Bitcoins in a
			* nice standard formatting.
			*
			* Examples:
			* 12.3555
			* 0.1234
			* 900.99998888
			* 34.00
			*/
			formatValue: function (valueBuffer) {
				var value = this.valueToBigInt(valueBuffer).toString();
				var integerPart = value.length > 8 ? value.substr(0, value.length - 8) : '0';
				var decimalPart = value.length > 8 ? value.substr(value.length - 8) : value;
				while (decimalPart.length < 8) decimalPart = "0" + decimalPart;
				decimalPart = decimalPart.replace(/0*$/, '');
				while (decimalPart.length < 2) decimalPart += "0";
				return integerPart + "." + decimalPart;
			},
			/**
			* Parse a floating point string as a Bitcoin value.
			*
			* Keep in mind that parsing user input is messy. You should always display
			* the parsed value back to the user to make sure we understood his input
			* correctly.
			*/
			parseValue: function (valueString) {
				// TODO: Detect other number formats (e.g. comma as decimal separator)
				var valueComp = valueString.split('.');
				var integralPart = valueComp[0];
				var fractionalPart = valueComp[1] || "0";
				while (fractionalPart.length < 8) fractionalPart += "0";
				fractionalPart = fractionalPart.replace(/^0+/g, '');
				var value = BigInteger.valueOf(parseInt(integralPart));
				value = value.multiply(BigInteger.valueOf(100000000));
				value = value.add(BigInteger.valueOf(parseInt(fractionalPart)));
				return value;
			},
			/**
			* Calculate RIPEMD160(SHA256(data)).
			*
			* Takes an arbitrary byte array as inputs and returns the hash as a byte
			* array.
			*/
			sha256ripe160: function (data) {
				return Crypto.RIPEMD160(Crypto.SHA256(data, { asBytes: true }), { asBytes: true });
			},

			dsha256: function (data) {
				return Crypto.SHA256(Crypto.SHA256(data, { asBytes: true }), { asBytes: true });
			}
		};
	</script>

	<script>
		(function () {
		  var Opcode = Bitcoin.Opcode = function (num) {
		    this.code = num;
		  };

		  Opcode.prototype.toString = function () {
		    return Opcode.reverseMap[this.code];
		  };

		  Opcode.map = {
		    // push value
		    OP_0         : 0,
		    OP_FALSE     : 0,
		    OP_PUSHDATA1 : 76,
		    OP_PUSHDATA2 : 77,
		    OP_PUSHDATA4 : 78,
		    OP_1NEGATE   : 79,
		    OP_RESERVED  : 80,
		    OP_1         : 81,
		    OP_TRUE      : 81,
		    OP_2         : 82,
		    OP_3         : 83,
		    OP_4         : 84,
		    OP_5         : 85,
		    OP_6         : 86,
		    OP_7         : 87,
		    OP_8         : 88,
		    OP_9         : 89,
		    OP_10        : 90,
		    OP_11        : 91,
		    OP_12        : 92,
		    OP_13        : 93,
		    OP_14        : 94,
		    OP_15        : 95,
		    OP_16        : 96,

		    // control
		    OP_NOP       : 97,
		    OP_VER       : 98,
		    OP_IF        : 99,
		    OP_NOTIF     : 100,
		    OP_VERIF     : 101,
		    OP_VERNOTIF  : 102,
		    OP_ELSE      : 103,
		    OP_ENDIF     : 104,
		    OP_VERIFY    : 105,
		    OP_RETURN    : 106,

		    // stack ops
		    OP_TOALTSTACK   : 107,
		    OP_FROMALTSTACK : 108,
		    OP_2DROP        : 109,
		    OP_2DUP         : 110,
		    OP_3DUP         : 111,
		    OP_2OVER        : 112,
		    OP_2ROT         : 113,
		    OP_2SWAP        : 114,
		    OP_IFDUP        : 115,
		    OP_DEPTH        : 116,
		    OP_DROP         : 117,
		    OP_DUP          : 118,
		    OP_NIP          : 119,
		    OP_OVER         : 120,
		    OP_PICK         : 121,
		    OP_ROLL         : 122,
		    OP_ROT          : 123,
		    OP_SWAP         : 124,
		    OP_TUCK         : 125,

		    // splice ops
		    OP_CAT          : 126,
		    OP_SUBSTR       : 127,
		    OP_LEFT         : 128,
		    OP_RIGHT        : 129,
		    OP_SIZE         : 130,

		    // bit logic
		    OP_INVERT       : 131,
		    OP_AND          : 132,
		    OP_OR           : 133,
		    OP_XOR          : 134,
		    OP_EQUAL        : 135,
		    OP_EQUALVERIFY  : 136,
		    OP_RESERVED1    : 137,
		    OP_RESERVED2    : 138,

		    // numeric
		    OP_1ADD         : 139,
		    OP_1SUB         : 140,
		    OP_2MUL         : 141,
		    OP_2DIV         : 142,
		    OP_NEGATE       : 143,
		    OP_ABS          : 144,
		    OP_NOT          : 145,
		    OP_0NOTEQUAL    : 146,

		    OP_ADD          : 147,
		    OP_SUB          : 148,
		    OP_MUL          : 149,
		    OP_DIV          : 150,
		    OP_MOD          : 151,
		    OP_LSHIFT       : 152,
		    OP_RSHIFT       : 153,

		    OP_BOOLAND             : 154,
		    OP_BOOLOR              : 155,
		    OP_NUMEQUAL            : 156,
		    OP_NUMEQUALVERIFY      : 157,
		    OP_NUMNOTEQUAL         : 158,
		    OP_LESSTHAN            : 159,
		    OP_GREATERTHAN         : 160,
		    OP_LESSTHANOREQUAL     : 161,
		    OP_GREATERTHANOREQUAL  : 162,
		    OP_MIN                 : 163,
		    OP_MAX                 : 164,

		    OP_WITHIN              : 165,

		    // crypto
		    OP_RIPEMD160           : 166,
		    OP_SHA1                : 167,
		    OP_SHA256              : 168,
		    OP_HASH160             : 169,
		    OP_HASH256             : 170,
		    OP_CODESEPARATOR       : 171,
		    OP_CHECKSIG            : 172,
		    OP_CHECKSIGVERIFY      : 173,
		    OP_CHECKMULTISIG       : 174,
		    OP_CHECKMULTISIGVERIFY : 175,

		    // expansion
		    OP_NOP1  : 176,
		    OP_NOP2  : 177,
		    OP_NOP3  : 178,
		    OP_NOP4  : 179,
		    OP_NOP5  : 180,
		    OP_NOP6  : 181,
		    OP_NOP7  : 182,
		    OP_NOP8  : 183,
		    OP_NOP9  : 184,
		    OP_NOP10 : 185,

		    // template matching params
		    OP_PUBKEYHASH    : 253,
		    OP_PUBKEY        : 254,
		    OP_INVALIDOPCODE : 255
		  };

		  Opcode.reverseMap = [];

		  for (var i in Opcode.map) {
		    Opcode.reverseMap[Opcode.map[i]] = i;
		  }
		})();
	</script>

	<script>
		(function () {
		  var Opcode = Bitcoin.Opcode;

		  // Make opcodes available as pseudo-constants
		  for (var i in Opcode.map) {
		    eval("var " + i + " = " + Opcode.map[i] + ";");
		  }

		  var Script = Bitcoin.Script = function (data) {
		    if (!data) {
		      this.buffer = [];
		    } else if ("string" == typeof data) {
		      this.buffer = Crypto.util.base64ToBytes(data);
		    } else if (Bitcoin.Util.isArray(data)) {
		      this.buffer = data;
		    } else if (data instanceof Script) {
		      this.buffer = data.buffer;
		    } else {
		      throw new Error("Invalid script");
		    }

		    this.parse();
		  };

		  /**
		   * Update the parsed script representation.
		   *
		   * Each Script object stores the script in two formats. First as a raw byte
		   * array and second as an array of "chunks", such as opcodes and pieces of
		   * data.
		   *
		   * This method updates the chunks cache. Normally this is called by the
		   * constructor and you don't need to worry about it. However, if you change
		   * the script buffer manually, you should update the chunks using this method.
		   */
		  Script.prototype.parse = function () {
		    var self = this;

		    this.chunks = [];

		    // Cursor
		    var i = 0;

		    // Read n bytes and store result as a chunk
		    function readChunk(n) {
		      self.chunks.push(self.buffer.slice(i, i + n));
		      i += n;
		    };

		    while (i < this.buffer.length) {
		      var opcode = this.buffer[i++];
		      if (opcode >= 0xF0) {
		        // Two byte opcode
		        opcode = (opcode << 8) | this.buffer[i++];
		      }

		      var len;
		      if (opcode > 0 && opcode < OP_PUSHDATA1) {
		        // Read some bytes of data, opcode value is the length of data
		        readChunk(opcode);
		      } else if (opcode == OP_PUSHDATA1) {
		        len = this.buffer[i++];
		        readChunk(len);
		      } else if (opcode == OP_PUSHDATA2) {
		        len = (this.buffer[i++] << 8) | this.buffer[i++];
		        readChunk(len);
		      } else if (opcode == OP_PUSHDATA4) {
		        len = (this.buffer[i++] << 24) |
		          (this.buffer[i++] << 16) |
		          (this.buffer[i++] << 8) |
		          this.buffer[i++];
		        readChunk(len);
		      } else {
		        this.chunks.push(opcode);
		      }
		    }
		  };

		  /**
		   * Compare the script to known templates of scriptPubKey.
		   *
		   * This method will compare the script to a small number of standard script
		   * templates and return a string naming the detected type.
		   *
		   * Currently supported are:
		   * Address:
		   *   Paying to a Bitcoin address which is the hash of a pubkey.
		   *   OP_DUP OP_HASH160 [pubKeyHash] OP_EQUALVERIFY OP_CHECKSIG
		   *
		   * Pubkey:
		   *   Paying to a public key directly.
		   *   [pubKey] OP_CHECKSIG
		   * 
		   * Strange:
		   *   Any other script (no template matched).
		   */
		  Script.prototype.getOutType = function () {

		  if (this.chunks[this.chunks.length-1] == OP_CHECKMULTISIG && this.chunks[this.chunks.length-2] <= 3) {
		    // Transfer to M-OF-N
		    return 'Multisig';
		  } else if (this.chunks.length == 5 &&
		    this.chunks[0] == OP_DUP &&
		    this.chunks[1] == OP_HASH160 &&
		    this.chunks[3] == OP_EQUALVERIFY &&
		    this.chunks[4] == OP_CHECKSIG) {
		    // Transfer to Bitcoin address
		    return 'Address';
		  } else if (this.chunks.length == 2 &&
		         this.chunks[1] == OP_CHECKSIG) {
		    // Transfer to IP address
		    return 'Pubkey';
		  } else {
		    return 'Strange';
		  }   
		}

		  /**
		   * Returns the affected address hash for this output.
		   *
		   * For standard transactions, this will return the hash of the pubKey that
		   * can spend this output.
		   *
		   * In the future, for payToScriptHash outputs, this will return the
		   * scriptHash. Note that non-standard and standard payToScriptHash transactions
		   * look the same 
		   *
		   * This method is useful for indexing transactions.
		   */
		  Script.prototype.simpleOutHash = function ()
		  {
		    switch (this.getOutType()) {
		    case 'Address':
		      return this.chunks[2];
		    case 'Pubkey':
		      return Bitcoin.Util.sha256ripe160(this.chunks[0]);
		    default:
		      throw new Error("Encountered non-standard scriptPubKey");
		    }
		  };

		  /**
		   * Old name for Script#simpleOutHash.
		   *
		   * @deprecated
		   */
		  Script.prototype.simpleOutPubKeyHash = Script.prototype.simpleOutHash;

		  /**
		   * Compare the script to known templates of scriptSig.
		   *
		   * This method will compare the script to a small number of standard script
		   * templates and return a string naming the detected type.
		   *
		   * WARNING: Use this method with caution. It merely represents a heuristic
		   * based on common transaction formats. A non-standard transaction could
		   * very easily match one of these templates by accident.
		   *
		   * Currently supported are:
		   * Address:
		   *   Paying to a Bitcoin address which is the hash of a pubkey.
		   *   [sig] [pubKey]
		   *
		   * Pubkey:
		   *   Paying to a public key directly.
		   *   [sig]
		   * 
		   * Strange:
		   *   Any other script (no template matched).
		   */
		  Script.prototype.getInType = function ()
		  {
		    if (this.chunks.length == 1 &&
		        Bitcoin.Util.isArray(this.chunks[0])) {
		      // Direct IP to IP transactions only have the signature in their scriptSig.
		      // TODO: We could also check that the length of the data is correct.
		      return 'Pubkey';
		    } else if (this.chunks.length == 2 &&
		               Bitcoin.Util.isArray(this.chunks[0]) &&
		               Bitcoin.Util.isArray(this.chunks[1])) {
		      return 'Address';
		    } else {
		      return 'Strange';
		    }
		  };

		  /**
		   * Returns the affected public key for this input.
		   *
		   * This currently only works with payToPubKeyHash transactions. It will also
		   * work in the future for standard payToScriptHash transactions that use a
		   * single public key.
		   *
		   * However for multi-key and other complex transactions, this will only return
		   * one of the keys or raise an error. Therefore, it is recommended for indexing
		   * purposes to use Script#simpleInHash or Script#simpleOutHash instead.
		   *
		   * @deprecated
		   */
		  Script.prototype.simpleInPubKey = function ()
		  {
		    switch (this.getInType()) {
		    case 'Address':
		      return this.chunks[1];
		    case 'Pubkey':
		      // TODO: Theoretically, we could recover the pubkey from the sig here.
		      //       See https://bitcointalk.org/?topic=6430.0
		      throw new Error("Script does not contain pubkey.");
		    default:
		      throw new Error("Encountered non-standard scriptSig");
		    }
		  };

		  /**
		   * Returns the affected address hash for this input.
		   *
		   * For standard transactions, this will return the hash of the pubKey that
		   * can spend this output.
		   *
		   * In the future, for standard payToScriptHash inputs, this will return the
		   * scriptHash.
		   *
		   * Note: This function provided for convenience. If you have the corresponding
		   * scriptPubKey available, you are urged to use Script#simpleOutHash instead
		   * as it is more reliable for non-standard payToScriptHash transactions.
		   *
		   * This method is useful for indexing transactions.
		   */
		  Script.prototype.simpleInHash = function ()
		  {
		    return Bitcoin.Util.sha256ripe160(this.simpleInPubKey());
		  };

		  /**
		   * Old name for Script#simpleInHash.
		   *
		   * @deprecated
		   */
		  Script.prototype.simpleInPubKeyHash = Script.prototype.simpleInHash;

		  /**
		   * Add an op code to the script.
		   */
		  Script.prototype.writeOp = function (opcode)
		  {
		    this.buffer.push(opcode);
		    this.chunks.push(opcode);
		  };

		  /**
		   * Add a data chunk to the script.
		   */
		  Script.prototype.writeBytes = function (data)
		  {
		    if (data.length < OP_PUSHDATA1) {
		      this.buffer.push(data.length);
		    } else if (data.length <= 0xff) {
		      this.buffer.push(OP_PUSHDATA1);
		      this.buffer.push(data.length);
		    } else if (data.length <= 0xffff) {
		      this.buffer.push(OP_PUSHDATA2);
		      this.buffer.push(data.length & 0xff);
		      this.buffer.push((data.length >>> 8) & 0xff);
		    } else {
		      this.buffer.push(OP_PUSHDATA4);
		      this.buffer.push(data.length & 0xff);
		      this.buffer.push((data.length >>> 8) & 0xff);
		      this.buffer.push((data.length >>> 16) & 0xff);
		      this.buffer.push((data.length >>> 24) & 0xff);
		    }
		    this.buffer = this.buffer.concat(data);
		    this.chunks.push(data);
		  };

		  /**
		   * Create a standard payToPubKeyHash output.
		   */
		  Script.createOutputScript = function (address)
		  {
		    var script = new Script();
		    script.writeOp(OP_DUP);
		    script.writeOp(OP_HASH160);
		    script.writeBytes(address.hash);
		    script.writeOp(OP_EQUALVERIFY);
		    script.writeOp(OP_CHECKSIG);
		    return script;
		  };
		  
		  
		  /**
		   * Extract bitcoin addresses from an output script
		   */
		  Script.prototype.extractAddresses = function (addresses)
		  { 
		    switch (this.getOutType()) {
		    case 'Address':
		      addresses.push(new Address(this.chunks[2]));
		      return 1;
		    case 'Pubkey':
		      addresses.push(new Address(Util.sha256ripe160(this.chunks[0])));
		      return 1;
		    case 'Multisig':
		      for (var i = 1; i < this.chunks.length-2; ++i) {
		        addresses.push(new Address(Util.sha256ripe160(this.chunks[i])));
		      }
		      return this.chunks[0] - OP_1 + 1;
		    default:
		      throw new Error("Encountered non-standard scriptPubKey");
		    }
		  };

		  /**
		   * Create an m-of-n output script
		   */
		  Script.createMultiSigOutputScript = function (m, pubkeys)
		  {
		    var script = new Bitcoin.Script();
		    
		    script.writeOp(OP_1 + m - 1);
		    
		    for (var i = 0; i < pubkeys.length; ++i) {
		      script.writeBytes(pubkeys[i]);
		    }
		    
		    script.writeOp(OP_1 + pubkeys.length - 1);

		    script.writeOp(OP_CHECKMULTISIG);

		    return script;
		  };

		  /**
		   * Create a standard payToPubKeyHash input.
		   */
		  Script.createInputScript = function (signature, pubKey)
		  {
		    var script = new Script();
		    script.writeBytes(signature);
		    script.writeBytes(pubKey);
		    return script;
		  };

		  Script.prototype.clone = function ()
		  {
		    return new Script(this.buffer);
		  };
		})();
	</script>

	<script>
		(function () {
		  var Script = Bitcoin.Script;

		  var Transaction = Bitcoin.Transaction = function (doc) {
		    this.version = 1;
		    this.lock_time = 0;
		    this.ins = [];
		    this.outs = [];
		    this.timestamp = null;
		    this.block = null;

		    if (doc) {
		      if (doc.hash) this.hash = doc.hash;
		      if (doc.version) this.version = doc.version;
		      if (doc.lock_time) this.lock_time = doc.lock_time;
		      if (doc.ins && doc.ins.length) {
		        for (var i = 0; i < doc.ins.length; i++) {
		          this.addInput(new TransactionIn(doc.ins[i]));
		        }
		      }
		      if (doc.outs && doc.outs.length) {
		        for (var i = 0; i < doc.outs.length; i++) {
		          this.addOutput(new TransactionOut(doc.outs[i]));
		        }
		      }
		      if (doc.timestamp) this.timestamp = doc.timestamp;
		      if (doc.block) this.block = doc.block;
		    }
		  };

		  /**
		   * Turn transaction data into Transaction objects.
		   *
		   * Takes an array of plain JavaScript objects containing transaction data and
		   * returns an array of Transaction objects.
		   */
		  Transaction.objectify = function (txs) {
		    var objs = [];
		    for (var i = 0; i < txs.length; i++) {
		      objs.push(new Transaction(txs[i]));
		    }
		    return objs;
		  };

		  /**
		   * Create a new txin.
		   *
		   * Can be called with an existing TransactionIn object to add it to the
		   * transaction. Or it can be called with a Transaction object and an integer
		   * output index, in which case a new TransactionIn object pointing to the
		   * referenced output will be created.
		   *
		   * Note that this method does not sign the created input.
		   */
		  Transaction.prototype.addInput = function (tx, outIndex) {
		    if (arguments[0] instanceof TransactionIn) {
		      this.ins.push(arguments[0]);
		    } else {
		      this.ins.push(new TransactionIn({
		        outpoint: {
		          hash: tx.hash,
		          index: outIndex
		        },
		        script: new Bitcoin.Script(),
		        sequence: 4294967295
		      }));
		    }
		  };

		  /**
		   * Create a new txout.
		   *
		   * Can be called with an existing TransactionOut object to add it to the
		   * transaction. Or it can be called with an Address object and a BigInteger
		   * for the amount, in which case a new TransactionOut object with those
		   * values will be created.
		   */
		  Transaction.prototype.addOutput = function (address, value) {
		    if (arguments[0] instanceof TransactionOut) {
		      this.outs.push(arguments[0]);
		    } else {
		      if (value instanceof BigInteger) {
		        value = value.toByteArrayUnsigned().reverse();
		        while (value.length < 8) value.push(0);
		      } else if (Bitcoin.Util.isArray(value)) {
		        // Nothing to do
		      }

		      this.outs.push(new TransactionOut({
		        value: value,
		        script: Script.createOutputScript(address)
		      }));
		    }
		  };

		  /**
		   * Serialize this transaction.
		   *
		   * Returns the transaction as a byte array in the standard Bitcoin binary
		   * format. This method is byte-perfect, i.e. the resulting byte array can
		   * be hashed to get the transaction's standard Bitcoin hash.
		   */
		  Transaction.prototype.serialize = function ()
		  {
		    var buffer = [];
		    buffer = buffer.concat(Crypto.util.wordsToBytes([parseInt(this.version)]).reverse());
		    buffer = buffer.concat(Bitcoin.Util.numToVarInt(this.ins.length));
		    for (var i = 0; i < this.ins.length; i++) {
		      var txin = this.ins[i];
		      buffer = buffer.concat(Crypto.util.base64ToBytes(txin.outpoint.hash));
		      buffer = buffer.concat(Crypto.util.wordsToBytes([parseInt(txin.outpoint.index)]).reverse());
		      var scriptBytes = txin.script.buffer;
		      buffer = buffer.concat(Bitcoin.Util.numToVarInt(scriptBytes.length));
		      buffer = buffer.concat(scriptBytes);
		      buffer = buffer.concat(Crypto.util.wordsToBytes([parseInt(txin.sequence)]).reverse());
		    }
		    buffer = buffer.concat(Bitcoin.Util.numToVarInt(this.outs.length));
		    for (var i = 0; i < this.outs.length; i++) {
		      var txout = this.outs[i];
		      buffer = buffer.concat(txout.value);
		      var scriptBytes = txout.script.buffer;
		      buffer = buffer.concat(Bitcoin.Util.numToVarInt(scriptBytes.length));
		      buffer = buffer.concat(scriptBytes);
		    }
		    buffer = buffer.concat(Crypto.util.wordsToBytes([parseInt(this.lock_time)]).reverse());

		    return buffer;
		  };

		  var OP_CODESEPARATOR = 171;

		  var SIGHASH_ALL = 1;
		  var SIGHASH_NONE = 2;
		  var SIGHASH_SINGLE = 3;
		  var SIGHASH_ANYONECANPAY = 80;

		  /**
		   * Hash transaction for signing a specific input.
		   *
		   * Bitcoin uses a different hash for each signed transaction input. This
		   * method copies the transaction, makes the necessary changes based on the
		   * hashType, serializes and finally hashes the result. This hash can then be
		   * used to sign the transaction input in question.
		   */
		  Transaction.prototype.hashTransactionForSignature =
		  function (connectedScript, inIndex, hashType)
		  {
		    var txTmp = this.clone();

		    // In case concatenating two scripts ends up with two codeseparators,
		    // or an extra one at the end, this prevents all those possible
		    // incompatibilities.
		    /*scriptCode = scriptCode.filter(function (val) {
		     return val !== OP_CODESEPARATOR;
		     });*/

		    // Blank out other inputs' signatures
		    for (var i = 0; i < txTmp.ins.length; i++) {
		      txTmp.ins[i].script = new Script();
		    }

		    txTmp.ins[inIndex].script = connectedScript;

		    // Blank out some of the outputs
		    if ((hashType & 0x1f) == SIGHASH_NONE) {
		      txTmp.outs = [];

		      // Let the others update at will
		      for (var i = 0; i < txTmp.ins.length; i++)
		        if (i != inIndex)
		          txTmp.ins[i].sequence = 0;
		    } else if ((hashType & 0x1f) == SIGHASH_SINGLE) {
		      // TODO: Implement
		    }

		    // Blank out other inputs completely, not recommended for open transactions
		    if (hashType & SIGHASH_ANYONECANPAY) {
		      txTmp.ins = [txTmp.ins[inIndex]];
		    }

		    var buffer = txTmp.serialize();

		    buffer = buffer.concat(Crypto.util.wordsToBytes([parseInt(hashType)]).reverse());

		    var hash1 = Crypto.SHA256(buffer, {asBytes: true});

		    return Crypto.SHA256(hash1, {asBytes: true});
		  };

		  /**
		   * Calculate and return the transaction's hash.
		   */
		  Transaction.prototype.getHash = function ()
		  {
		    var buffer = this.serialize();
		    return Crypto.SHA256(Crypto.SHA256(buffer, {asBytes: true}), {asBytes: true});
		  };

		  /**
		   * Create a copy of this transaction object.
		   */
		  Transaction.prototype.clone = function ()
		  {
		    var newTx = new Transaction();
		    newTx.version = this.version;
		    newTx.lock_time = this.lock_time;
		    for (var i = 0; i < this.ins.length; i++) {
		      var txin = this.ins[i].clone();
		      newTx.addInput(txin);
		    }
		    for (var i = 0; i < this.outs.length; i++) {
		      var txout = this.outs[i].clone();
		      newTx.addOutput(txout);
		    }
		    return newTx;
		  };

		  /**
		   * Analyze how this transaction affects a wallet.
		   *
		   * Returns an object with properties 'impact', 'type' and 'addr'.
		   *
		   * 'impact' is an object, see Transaction#calcImpact.
		   * 
		   * 'type' can be one of the following:
		   * 
		   * recv:
		   *   This is an incoming transaction, the wallet received money.
		   *   'addr' contains the first address in the wallet that receives money
		   *   from this transaction.
		   *
		   * self:
		   *   This is an internal transaction, money was sent within the wallet.
		   *   'addr' is undefined.
		   *
		   * sent:
		   *   This is an outgoing transaction, money was sent out from the wallet.
		   *   'addr' contains the first external address, i.e. the recipient.
		   *
		   * other:
		   *   This method was unable to detect what the transaction does. Either it
		   */
		  Transaction.prototype.analyze = function (wallet) {
		    if (!(wallet instanceof Bitcoin.Wallet)) return null;

		    var allFromMe = true,
		    allToMe = true,
		    firstRecvHash = null,
		    firstMeRecvHash = null,
		    firstSendHash = null;

		    for (var i = this.outs.length-1; i >= 0; i--) {
		      var txout = this.outs[i];
		      var hash = txout.script.simpleOutPubKeyHash();
		      if (!wallet.hasHash(hash)) {
		        allToMe = false;
		      } else {
		        firstMeRecvHash = hash;
		      }
		      firstRecvHash = hash;
		    }
		    for (var i = this.ins.length-1; i >= 0; i--) {
		      var txin = this.ins[i];
		      firstSendHash = txin.script.simpleInPubKeyHash();
		      if (!wallet.hasHash(firstSendHash)) {
		        allFromMe = false;
		        break;
		      }
		    }

		    var impact = this.calcImpact(wallet);

		    var analysis = {};

		    analysis.impact = impact;

		    if (impact.sign > 0 && impact.value.compareTo(BigInteger.ZERO) > 0) {
		      analysis.type = 'recv';
		      analysis.addr = new Bitcoin.Address(firstMeRecvHash);
		    } else if (allFromMe && allToMe) {
		      analysis.type = 'self';
		    } else if (allFromMe) {
		      analysis.type = 'sent';
		      // TODO: Right now, firstRecvHash is the first output, which - if the
		      //       transaction was not generated by this library could be the
		      //       change address.
		      analysis.addr = new Bitcoin.Address(firstRecvHash);
		    } else  {
		      analysis.type = "other";
		    }

		    return analysis;
		  };

		  /**
		   * Get a human-readable version of the data returned by Transaction#analyze.
		   *
		   * This is merely a convenience function. Clients should consider implementing
		   * this themselves based on their UI, I18N, etc.
		   */
		  Transaction.prototype.getDescription = function (wallet) {
		    var analysis = this.analyze(wallet);

		    if (!analysis) return "";

		    switch (analysis.type) {
		    case 'recv':
		      return "Received with "+analysis.addr;
		      break;

		    case 'sent':
		      return "Payment to "+analysis.addr;
		      break;

		    case 'self':
		      return "Payment to yourself";
		      break;

		    case 'other':
		    default:
		      return "";
		    }
		  };

		  /**
		   * Get the total amount of a transaction's outputs.
		   */
		  Transaction.prototype.getTotalOutValue = function () {
		    var totalValue = BigInteger.ZERO;
		    for (var j = 0; j < this.outs.length; j++) {
		      var txout = this.outs[j];
		      totalValue = totalValue.add(Bitcoin.Util.valueToBigInt(txout.value));
		    }
		    return totalValue;
		  };

		   /**
		    * Old name for Transaction#getTotalOutValue.
		    *
		    * @deprecated
		    */
		   Transaction.prototype.getTotalValue = Transaction.prototype.getTotalOutValue;

		  /**
		   * Calculates the impact a transaction has on this wallet.
		   *
		   * Based on the its public keys, the wallet will calculate the
		   * credit or debit of this transaction.
		   *
		   * It will return an object with two properties:
		   *  - sign: 1 or -1 depending on sign of the calculated impact.
		   *  - value: amount of calculated impact
		   *
		   * @returns Object Impact on wallet
		   */
		  Transaction.prototype.calcImpact = function (wallet) {
		    if (!(wallet instanceof Bitcoin.Wallet)) return BigInteger.ZERO;

		    // Calculate credit to us from all outputs
		    var valueOut = BigInteger.ZERO;
		    for (var j = 0; j < this.outs.length; j++) {
		      var txout = this.outs[j];
		      var hash = Crypto.util.bytesToBase64(txout.script.simpleOutPubKeyHash());
		      if (wallet.hasHash(hash)) {
		        valueOut = valueOut.add(Bitcoin.Util.valueToBigInt(txout.value));
		      }
		    }

		    // Calculate debit to us from all ins
		    var valueIn = BigInteger.ZERO;
		    for (var j = 0; j < this.ins.length; j++) {
		      var txin = this.ins[j];
		      var hash = Crypto.util.bytesToBase64(txin.script.simpleInPubKeyHash());
		      if (wallet.hasHash(hash)) {
		        var fromTx = wallet.txIndex[txin.outpoint.hash];
		        if (fromTx) {
		          valueIn = valueIn.add(Bitcoin.Util.valueToBigInt(fromTx.outs[txin.outpoint.index].value));
		        }
		      }
		    }
		    if (valueOut.compareTo(valueIn) >= 0) {
		      return {
		        sign: 1,
		        value: valueOut.subtract(valueIn)
		      };
		    } else {
		      return {
		        sign: -1,
		        value: valueIn.subtract(valueOut)
		      };
		    }
		  };

		  var TransactionIn = Bitcoin.TransactionIn = function (data)
		  {
		    this.outpoint = data.outpoint;
		    if (data.script instanceof Script) {
		      this.script = data.script;
		    } else {
		      this.script = new Script(data.script);
		    }
		    this.sequence = data.sequence;
		  };

		  TransactionIn.prototype.clone = function ()
		  {
		    var newTxin = new TransactionIn({
		      outpoint: {
		        hash: this.outpoint.hash,
		        index: this.outpoint.index
		      },
		      script: this.script.clone(),
		      sequence: this.sequence
		    });
		    return newTxin;
		  };

		  var TransactionOut = Bitcoin.TransactionOut = function (data)
		  {
		    if (data.script instanceof Script) {
		      this.script = data.script;
		    } else {
		      this.script = new Script(data.script);
		    }

		    if (Bitcoin.Util.isArray(data.value)) {
		      this.value = data.value;
		    } else if ("string" == typeof data.value) {
		      var valueHex = (new BigInteger(data.value, 10)).toString(16);
		      while (valueHex.length < 16) valueHex = "0" + valueHex;
		      this.value = Crypto.util.hexToBytes(valueHex);
		    }
		  };

		  TransactionOut.prototype.clone = function ()
		  {
		    var newTxout = new TransactionOut({
		      script: this.script.clone(),
		      value: this.value.slice(0)
		    });
		    return newTxout;
		  };
		})();
	</script>


	<script>
		/*
		    tx.js - Bitcoin transactions for JavaScript (public domain)

		    Obtaining inputs:
		    1) http://blockchain.info/unspent?address=<address>
		    2) http://blockexplorer.com/q/mytransactions/<address>

		    Sending transactions:
		    1) http://bitsend.rowit.co.uk
		    2) http://www.blockchain.info/pushtx
		*/

		var TX = new function () {

		    var inputs = [];
		    var outputs = [];
		    var eckey = null;
		    var balance = 0;

		    this.init = function(_eckey) {
		        outputs = [];
		        eckey = _eckey;
		    }

		    this.addOutput = function(addr, fval) {
		        outputs.push({address: addr, value: fval});
		    }

		    this.getBalance = function() {
		        return balance;
		    }

		    this.getAddress = function() {
		        return eckey.getBitcoinAddress().toString();
		    }

		    this.parseInputs = function(text, address) {
		        try {
		            var res = tx_parseBCI(text, address);
		        } catch(err) {
		            var res = parseTxs(text, address);
		        }

		        balance = res.balance;
		        inputs = res.unspenttxs;
		    }

		    this.construct = function() {
		        var sendTx = new Bitcoin.Transaction();
		        var selectedOuts = [];
		        for (var hash in inputs) {
		            if (!inputs.hasOwnProperty(hash))
		                continue;
		            for (var index in inputs[hash]) {
		                if (!inputs[hash].hasOwnProperty(index))
		                    continue;
		                var script = parseScript(inputs[hash][index].script);
		                var b64hash = Crypto.util.bytesToBase64(Crypto.util.hexToBytes(hash));
		                var txin = new Bitcoin.TransactionIn({outpoint: {hash: b64hash, index: index}, script: script, sequence: 4294967295});
		                selectedOuts.push(txin);
		                sendTx.addInput(txin);
		            }
		        }

		        for (var i in outputs) {
		            var address = outputs[i].address;
		            var fval = outputs[i].value;
		            var value = new BigInteger('' + Math.round(fval * 1e8), 10);
		            sendTx.addOutput(new Bitcoin.Address(address), value);
		        }

		        var hashType = 1;
		        for (var i = 0; i < sendTx.ins.length; i++) {
		            var connectedScript = selectedOuts[i].script;
		            var hash = sendTx.hashTransactionForSignature(connectedScript, i, hashType);
		            var pubKeyHash = connectedScript.simpleOutPubKeyHash();
		            var signature = eckey.sign(hash);
		            signature.push(parseInt(hashType, 10));
		            var pubKey = eckey.getPub();
		            var script = new Bitcoin.Script();
		            script.writeBytes(signature);
		            script.writeBytes(pubKey);
		            sendTx.ins[i].script = script;
		        }
		        return sendTx;
		    };

		    function uint(f, size) {
		        if (f.length < size)
		            return 0;
		        var bytes = f.slice(0, size);
		        var pos = 1;
		        var n = 0;
		        for (var i = 0; i < size; i++) { 
		            var b = f.shift();
		            n += b * pos;
		            pos *= 256;
		        }
		        return size <= 4 ? n : bytes;
		    }

		    function u8(f)  { return uint(f,1); }
		    function u16(f) { return uint(f,2); }
		    function u32(f) { return uint(f,4); }
		    function u64(f) { return uint(f,8); }

		    function errv(val) {
		        return (val instanceof BigInteger || val > 0xffff);
		    }

		    function readBuffer(f, size) {
		        var res = f.slice(0, size);
		        for (var i = 0; i < size; i++) f.shift();
		        return res;
		    }

		    function readString(f) {
		        var len = readVarInt(f);
		        if (errv(len)) return [];
		        return readBuffer(f, len);
		    }

		    function readVarInt(f) {
		        var t = u8(f);
		        if (t == 0xfd) return u16(f); else
		        if (t == 0xfe) return u32(f); else
		        if (t == 0xff) return u64(f); else
		        return t;
		    }

		    this.deserialize = function(bytes) {
		        var sendTx = new Bitcoin.Transaction();

		        var f = bytes.slice(0);
		        var tx_ver = u32(f);
		        var vin_sz = readVarInt(f);
		        if (errv(vin_sz))
		            return null;

		        for (var i = 0; i < vin_sz; i++) {
		            var op = readBuffer(f, 32);
		            var n = u32(f);
		            var script = readString(f);
		            var seq = u32(f);
		            var txin = new Bitcoin.TransactionIn({
		                outpoint: { 
		                    hash: Crypto.util.bytesToBase64(op),
		                    index: n
		                },
		                script: new Bitcoin.Script(script),
		                sequence: seq
		            });
		            sendTx.addInput(txin);
		        }

		        var vout_sz = readVarInt(f);

		        if (errv(vout_sz))
		            return null;

		        for (var i = 0; i < vout_sz; i++) {
		            var value = u64(f);
		            var script = readString(f);

		            var txout = new Bitcoin.TransactionOut({
		                value: value,
		                script: new Bitcoin.Script(script)
		            });

		            sendTx.addOutput(txout);
		        }
		        var lock_time = u32(f);
		        sendTx.lock_time = lock_time;
		        return sendTx;
		    };

		    this.toBBE = function(sendTx) {
		        //serialize to Bitcoin Block Explorer format
		        var buf = sendTx.serialize();
		        var hash = Crypto.SHA256(Crypto.SHA256(buf, {asBytes: true}), {asBytes: true});

		        var r = {};
		        r['hash'] = Crypto.util.bytesToHex(hash.reverse());
		        r['ver'] = sendTx.version;
		        r['vin_sz'] = sendTx.ins.length;
		        r['vout_sz'] = sendTx.outs.length;
		        r['lock_time'] = sendTx.lock_time;
		        r['size'] = buf.length;
		        r['in'] = []
		        r['out'] = []

		        for (var i = 0; i < sendTx.ins.length; i++) {
		            var txin = sendTx.ins[i];
		            var hash = Crypto.util.base64ToBytes(txin.outpoint.hash);
		            var n = txin.outpoint.index;
		            var prev_out = {'hash': Crypto.util.bytesToHex(hash.reverse()), 'n': n};

		            if (n == 4294967295) {
		                var cb = Crypto.util.bytesToHex(txin.script.buffer);
		                r['in'].push({'prev_out': prev_out, 'coinbase' : cb});
		            } else {
		                var ss = dumpScript(txin.script);
		                r['in'].push({'prev_out': prev_out, 'scriptSig' : ss});
		            }
		        }

		        for (var i = 0; i < sendTx.outs.length; i++) {
		            var txout = sendTx.outs[i];
		            var bytes = txout.value.slice(0);
		            var fval = parseFloat(Bitcoin.Util.formatValue(bytes.reverse()));
		            var value = fval.toFixed(8);
		            var spk = dumpScript(txout.script);
		            r['out'].push({'value' : value, 'scriptPubKey': spk});
		        }

		        return JSON.stringify(r, null, 4);
		    };

		    this.fromBBE = function(text) {
		        //deserialize from Bitcoin Block Explorer format
		        var sendTx = new Bitcoin.Transaction();
		        var r = JSON.parse(text);
		        if (!r)
		            return sendTx;
		        var tx_ver = r['ver'];
		        var vin_sz = r['vin_sz'];

		        for (var i = 0; i < vin_sz; i++) {
		            var txi = r['in'][i];
		            var hash = Crypto.util.hexToBytes(txi['prev_out']['hash']);
		            var n = txi['prev_out']['n'];

		            if (txi['coinbase'])
		                var script = Crypto.util.hexToBytes(txi['coinbase']);
		            else
		                var script = parseScript(txi['scriptSig']);

		            var txin = new Bitcoin.TransactionIn({
		                outpoint: { 
		                    hash: Crypto.util.bytesToBase64(hash.reverse()),
		                    index: n
		                },
		                script: new Bitcoin.Script(script),
		                sequence: 4294967295
		            });
		            sendTx.addInput(txin);
		        }

		        var vout_sz = r['vout_sz'];

		        for (var i = 0; i < vout_sz; i++) {
		            var txo = r['out'][i];
		            var fval = parseFloat(txo['value']);
		            var value = new BigInteger('' + Math.round(fval * 1e8), 10);
		            var script = parseScript(txo['scriptPubKey']);

		            if (value instanceof BigInteger) {
		                value = value.toByteArrayUnsigned().reverse();
		                while (value.length < 8) value.push(0);
		            }

		            var txout = new Bitcoin.TransactionOut({
		                value: value,
		                script: new Bitcoin.Script(script)
		            });

		            sendTx.addOutput(txout);
		        }
		        sendTx.lock_time = r['lock_time'];
		        return sendTx;
		    };
		    return this;
		};

		function dumpScript(script){
		    var out = [];
		    for (var i = 0; i < script.chunks.length; i++) {
		        var chunk = script.chunks[i];
		        var op = new Bitcoin.Opcode(chunk);
		        typeof chunk == 'number' ?  out.push(op.toString()) :
		            out.push(Crypto.util.bytesToHex(chunk));
		    }
		    return out.join(' ');
		}

		// blockchain.info parser (adapted)
		// uses http://blockchain.info/unspent?address=<address>
		function tx_parseBCI(data, address) {
		    var r = data;
		    var txs = r.unspent_outputs;

		    if (!txs)
		    	throw 'Not a BCI format';

		    delete unspenttxs;
		    var unspenttxs = {};
		    var balance = BigInteger.ZERO;
		    for (var i in txs) {
		        var o = txs[i];
		        var lilendHash = o.tx_hash;
		        //convert script back to BBE-compatible text
		        var scriptbtc = new Bitcoin.Script(Crypto.util.hexToBytes(o.script));
		        var script = dumpScript(scriptbtc);

		        var value = new BigInteger('' + o.value, 10);
		        if (!(lilendHash in unspenttxs))
		            unspenttxs[lilendHash] = {};
		        unspenttxs[lilendHash][o.tx_output_n] = {amount: value, script: script};
		        balance = balance.add(value);
		    }
		    return {balance:balance, unspenttxs:unspenttxs};
		}

		// blockexplorer parser (by BTCurious)
		// uses http://blockexplorer.com/q/mytransactions/<address>
		// --->8---
		function parseTxs(data, address) {
		    var address = address.toString();
		    var tmp = JSON.parse(data);
		    var txs = [];
		    for (var a in tmp) {
		        if (!tmp.hasOwnProperty(a))
		            continue;
		        txs.push(tmp[a]);
		    }
		    
		    // Sort chronologically
		    txs.sort(function(a,b) {
		        if (a.time > b.time) return 1;
		        else if (a.time < b.time) return -1;
		        return 0;
		    })

		    delete unspenttxs;
		    var unspenttxs = {}; // { "<hash>": { <output index>: { amount:<amount>, script:<script> }}}

		    var balance = BigInteger.ZERO;

		    // Enumerate the transactions 
		    for (var a in txs) {
		    
		        if (!txs.hasOwnProperty(a))
		            continue;
		        var tx = txs[a];
		        if (tx.ver != 1) throw "Unknown version found. Expected version 1, found version " + tx.ver;
		        
		        // Enumerate inputs
		        for (var b in tx.in ) {
		            if (!tx.in.hasOwnProperty(b))
		                continue;
		            var input = tx.in[b];
		            var p = input.prev_out;
		            var lilendHash = endian(p.hash)
		            // if this came from a transaction to our address...
		            if (lilendHash in unspenttxs) {
		                unspenttx = unspenttxs[lilendHash];
		                
		                // remove from unspent transactions, and deduce the amount from the balance
		                balance = balance.subtract(unspenttx[p.n].amount);
		                delete unspenttx[p.n]
		                if (isEmpty(unspenttx)) {
		                    delete unspenttxs[lilendHash]
		                }
		            }
		        }
		        
		        // Enumerate outputs
		        var i = 0;
		        for (var b in tx.out) {
		            if (!tx.out.hasOwnProperty(b))
		                continue;
		                
		            var output = tx.out[b];

		            // if this was sent to our address...
		            if (output.address == address) {
		                // remember the transaction, index, amount, and script, and add the amount to the wallet balance
		                var value = btcstr2bignum(output.value);
		                var lilendHash = endian(tx.hash)
		                if (!(lilendHash in unspenttxs))
		                    unspenttxs[lilendHash] = {};
		                unspenttxs[lilendHash][i] = {amount: value, script: output.scriptPubKey};
		                balance = balance.add(value);
		            }
		            i = i + 1;
		        }
		    }

		    return {balance:balance, unspenttxs:unspenttxs};
		}

		function isEmpty(ob) {
		    for(var i in ob){ if(ob.hasOwnProperty(i)){return false;}}
		    return true;
		}

		function endian(string) {
		    var out = []
		    for(var i = string.length; i > 0; i-=2) {
		        out.push(string.substring(i-2,i));
		    }
		    return out.join("");
		}

		function btcstr2bignum(btc) {
		    var i = btc.indexOf('.');
		    var value = new BigInteger(btc.replace(/\./,''));
		    var diff = 9 - (btc.length - i);
		    if (i == -1) {
		        var mul = "100000000";
		    } else if (diff < 0) {
		        return value.divide(new BigInteger(Math.pow(10,-1*diff).toString()));
		    } else {
		        var mul = Math.pow(10,diff).toString();
		    }
		    return value.multiply(new BigInteger(mul));
		}

		function parseScript(script) {
		    var newScript = new Bitcoin.Script();
		    var s = script.split(" ");
		    for (var i in s) {
		        if (Bitcoin.Opcode.map.hasOwnProperty(s[i])){
		            newScript.writeOp(Bitcoin.Opcode.map[s[i]]);
		        } else {
		            newScript.writeBytes(Crypto.util.hexToBytes(s[i]));
		        }
		    }
		    return newScript;
		}
		// --->8---

		// Some cross-domain magic (to bypass Access-Control-Allow-Origin)
		function tx_fetch(url, onSuccess, onError, postdata) {
		    var useYQL = true;

		    if (useYQL) {
		        var q = 'select * from html where url="'+url+'"';
		        if (postdata) {
		            q = 'use "http://brainwallet.github.com/js/htmlpost.xml" as htmlpost; ';
		            q += 'select * from htmlpost where url="' + url + '" ';
		            q += 'and postdata="' + postdata + '" and xpath="//p"';
		        }
		        url = 'https://query.yahooapis.com/v1/public/yql?q=' + encodeURIComponent(q);
		    }
		    var xhr = new XMLHttpRequest();
		    xhr.onreadystatechange = function () {
	        if (xhr.readyState == 4) {
	        	var parser = new DOMParser();
	        	var xmlDoc = parser.parseFromString(xhr.responseText, "text/xml");
	        	if('undefined' != typeof xmlDoc.getElementsByTagName('p')[0]){
	        		var data = JSON.parse(xmlDoc.getElementsByTagName('p')[0].textContent);
	        		onSuccess(data);
	        	}
	        	else{
	        		alert("The private key you provided has no unspent outputs.");
	        	}
	        }
	      }
		    xhr.open('GET', url, true);
		    xhr.send();
		}
	</script>

	<script>
		/*

		jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser, jQuery
		Copyright (c) 2012 2012 Willow Systems Corporation, willow-systems.com
		 jsPDF 0.9.0rc1 ( 2013-04-07T16:52 commit ID d95d8f69915bb999f6704e8021108e2e755bd868 )
		Copyright (c) 2010-2012 James Hall, james@snapshotmedia.co.uk, https://github.com/MrRio/jsPDF
		Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
		MIT license.

		            -----------------------------------------------------------------------------------------------
		            JavaScript PubSub library
		            2012 (c) ddotsenko@willowsystems.com
		            based on Peter Higgins (dante@dojotoolkit.org)
		            Loosely based on Dojo publish/subscribe API, limited in scope. Rewritten blindly.
		            Original is (c) Dojo Foundation 2004-2010. Released under either AFL or new BSD, see:
		            http://dojofoundation.org/license for more information.
		            -----------------------------------------------------------------------------------------------
		 
		jsPDF addImage plugin (JPEG only at this time)
		Copyright (c) 2012 https://github.com/siefkenj/

		jsPDF Silly SVG plugin
		Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
		 
		jsPDF split_text_to_size plugin
		Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
		MIT license.
		 
		jsPDF standard_fonts_metrics plugin
		Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
		MIT license.
		*/
		var jsPDF=function(){function f(g,d,e,h){g="undefined"===typeof g?"p":g.toString().toLowerCase();"undefined"===typeof d&&(d="mm");"undefined"===typeof e&&(e="a4");"undefined"===typeof h&&"undefined"===typeof zpipe&&(h=!1);var a=e.toString().toLowerCase(),p=[],j=0,m=h;h={a3:[841.89,1190.55],a4:[595.28,841.89],a5:[420.94,595.28],letter:[612,792],legal:[612,1008]};var u="0 g",c=0,q=[],C=2,F=!1,H=[],n={},x={},z=16,A,y,s,r,I={title:"",subject:"",author:"",keywords:"",creator:""},w=0,aa=0,D={},G=new k(D),
		B,v=function(c){return c.toFixed(2)},V=function(c){var e=c.toFixed(0);return 10>c?"0"+e:e},l=function(e){F?q[c].push(e):(p.push(e),j+=e.length+1)},N=function(){C++;H[C]=j;l(C+" 0 obj");return C},Q=function(c){l("stream");l(c);l("endstream")},J,ca,R,t=function(c,e){var d;d=c;var j=e,a,h,b,p,g,m;void 0===j&&(j={});a=j.sourceEncoding?a:"Unicode";b=j.outputEncoding;if((j.autoencode||b)&&n[A].metadata&&n[A].metadata[a]&&n[A].metadata[a].encoding)if(a=n[A].metadata[a].encoding,!b&&n[A].encoding&&(b=n[A].encoding),
		!b&&a.codePages&&(b=a.codePages[0]),"string"===typeof b&&(b=a[b]),b){g=!1;p=[];a=0;for(h=d.length;a<h;a++)(m=b[d.charCodeAt(a)])?p.push(String.fromCharCode(m)):p.push(d[a]),p[a].charCodeAt(0)>>8&&(g=!0);d=p.join("")}for(a=d.length;void 0===g&&0!==a;)d.charCodeAt(a-1)>>8&&(g=!0),a--;if(g){p=j.noBOM?[]:[254,255];a=0;for(h=d.length;a<h;a++){m=d.charCodeAt(a);j=m>>8;if(j>>8)throw Error("Character at position "+a.toString(10)+" of string '"+d+"' exceeds 16bits. Cannot be encoded into UCS-2 BE");p.push(j);
		p.push(m-(j<<8))}d=String.fromCharCode.apply(void 0,p)}return d.replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},W=function(){c++;F=!0;q[c]=[];l(v(0.200025*r)+" w");l("0 G");0!==w&&l(w.toString(10)+" J");0!==aa&&l(aa.toString(10)+" j");G.publish("addPage",{pageNumber:c})},E=function(c,a){var d;void 0===c&&(c=n[A].fontName);void 0===a&&(a=n[A].fontStyle);try{d=x[c][a]}catch(e){d=void 0}if(!d)throw Error("Unable to look up font label for font '"+c+"', '"+a+"'. Refer to getFontList() for available fonts.");
		return d},K=function(){F=!1;p=[];H=[];l("%PDF-1.3");J=s*r;ca=y*r;var a,d,e,b,h;for(a=1;a<=c;a++){N();l("<</Type /Page");l("/Parent 1 0 R");l("/Resources 2 0 R");l("/Contents "+(C+1)+" 0 R>>");l("endobj");d=q[a].join("\n");N();if(m){e=[];for(b=0;b<d.length;++b)e[b]=d.charCodeAt(b);h=adler32cs.from(d);d=new Deflater(6);d.append(new Uint8Array(e));d=d.flush();e=[new Uint8Array([120,156]),new Uint8Array(d),new Uint8Array([h&255,h>>8&255,h>>16&255,h>>24&255])];d="";for(b in e)e.hasOwnProperty(b)&&(d+=
		String.fromCharCode.apply(null,e[b]));l("<</Length "+d.length+" /Filter [/FlateDecode]>>")}else l("<</Length "+d.length+">>");Q(d);l("endobj")}H[1]=j;l("1 0 obj");l("<</Type /Pages");R="/Kids [";for(b=0;b<c;b++)R+=3+2*b+" 0 R ";l(R+"]");l("/Count "+c);l("/MediaBox [0 0 "+v(J)+" "+v(ca)+"]");l(">>");l("endobj");for(var g in n)n.hasOwnProperty(g)&&(a=n[g],a.objectNumber=N(),l("<</BaseFont/"+a.PostScriptName+"/Type/Font"),"string"===typeof a.encoding&&l("/Encoding/"+a.encoding),l("/Subtype/Type1>>"),
		l("endobj"));G.publish("putResources");H[2]=j;l("2 0 obj");l("<<");l("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]");l("/Font <<");for(var f in n)n.hasOwnProperty(f)&&l("/"+f+" "+n[f].objectNumber+" 0 R");l(">>");l("/XObject <<");G.publish("putXobjectDict");l(">>");l(">>");l("endobj");G.publish("postPutResources");N();l("<<");l("/Producer (jsPDF 20120619)");I.title&&l("/Title ("+t(I.title)+")");I.subject&&l("/Subject ("+t(I.subject)+")");I.author&&l("/Author ("+t(I.author)+")");I.keywords&&l("/Keywords ("+
		t(I.keywords)+")");I.creator&&l("/Creator ("+t(I.creator)+")");g=new Date;l("/CreationDate (D:"+[g.getFullYear(),V(g.getMonth()+1),V(g.getDate()),V(g.getHours()),V(g.getMinutes()),V(g.getSeconds())].join("")+")");l(">>");l("endobj");N();l("<<");l("/Type /Catalog");l("/Pages 1 0 R");l("/OpenAction [3 0 R /FitH null]");l("/PageLayout /OneColumn");G.publish("putCatalog");l(">>");l("endobj");g=j;l("xref");l("0 "+(C+1));l("0000000000 65535 f ");for(f=1;f<=C;f++)a=H[f].toFixed(0),a=10>a.length?Array(11-
		a.length).join("0")+a:a,l(a+" 00000 n ");l("trailer");l("<<");l("/Size "+(C+1));l("/Root "+C+" 0 R");l("/Info "+(C-1)+" 0 R");l(">>");l("startxref");l(g);l("%%EOF");F=!0;return p.join("\n")},Y=function(c){var a="S";if("F"===c)a="f";else if("FD"===c||"DF"===c)a="B";return a},Z=function(c,a){var d,e,b,j;switch(c){case void 0:return K();case "save":if(navigator.getUserMedia&&(void 0===window.URL||void 0===window.URL.createObjectURL))return D.output("dataurlnewwindow");d=K();e=d.length;b=new Uint8Array(new ArrayBuffer(e));
		for(j=0;j<e;j++)b[j]=d.charCodeAt(j);d=new Blob([b],{type:"application/pdf"});saveAs(d,a);break;case "datauristring":case "dataurlstring":return"data:application/pdf;base64,"+btoa(K());case "datauri":case "dataurl":document.location.href="data:application/pdf;base64,"+btoa(K());break;case "dataurlnewwindow":window.open("data:application/pdf;base64,"+btoa(K()));break;default:throw Error('Output type "'+c+'" is not supported.');}};if("pt"===d)r=1;else if("mm"===d)r=72/25.4;else if("cm"===d)r=72/2.54;
		else if("in"===d)r=72;else throw"Invalid unit: "+d;if(h.hasOwnProperty(a))y=h[a][1]/r,s=h[a][0]/r;else try{y=e[1],s=e[0]}catch(M){throw"Invalid format: "+e;}if("p"===g||"portrait"===g)g="p",s>y&&(g=s,s=y,y=g);else if("l"===g||"landscape"===g)g="l",y>s&&(g=s,s=y,y=g);else throw"Invalid orientation: "+g;D.internal={pdfEscape:t,getStyle:Y,getFont:function(){return n[E.apply(D,arguments)]},getFontSize:function(){return z},btoa:btoa,write:function(c,a,d,e){l(1===arguments.length?c:Array.prototype.join.call(arguments,
		" "))},getCoordinateString:function(c){return v(c*r)},getVerticalCoordinateString:function(c){return v((y-c)*r)},collections:{},newObject:N,putStream:Q,events:G,scaleFactor:r,pageSize:{width:s,height:y},output:function(c,a){return Z(c,a)}};D.addPage=function(){W();return this};D.text=function(c,a,d,e){var b,j;"number"===typeof c&&(b=c,j=a,c=d,a=b,d=j);"string"===typeof c&&c.match(/[\n\r]/)&&(c=c.split(/\r\n|\r|\n/g));"undefined"===typeof e?e={noBOM:!0,autoencode:!0}:(void 0===e.noBOM&&(e.noBOM=!0),
		void 0===e.autoencode&&(e.autoencode=!0));if("string"===typeof c)e=t(c,e);else if(c instanceof Array){c=c.concat();for(b=c.length-1;-1!==b;b--)c[b]=t(c[b],e);e=c.join(") Tj\nT* (")}else throw Error('Type of text must be string or Array. "'+c+'" is not recognized.');l("BT\n/"+A+" "+z+" Tf\n"+z+" TL\n"+u+"\n"+v(a*r)+" "+v((y-d)*r)+" Td\n("+e+") Tj\nET");return this};D.line=function(c,a,d,e){l(v(c*r)+" "+v((y-a)*r)+" m "+v(d*r)+" "+v((y-e)*r)+" l S");return this};D.lines=function(c,a,d,e,b){var j,g,
		h,p,m,f,q,u;"number"===typeof c&&(j=c,g=a,c=d,a=j,d=g);b=Y(b);e=void 0===e?[1,1]:e;l((a*r).toFixed(3)+" "+((y-d)*r).toFixed(3)+" m ");j=e[0];e=e[1];g=c.length;u=d;for(d=0;d<g;d++)h=c[d],2===h.length?(a=h[0]*j+a,u=h[1]*e+u,l((a*r).toFixed(3)+" "+((y-u)*r).toFixed(3)+" l")):(p=h[0]*j+a,m=h[1]*e+u,f=h[2]*j+a,q=h[3]*e+u,a=h[4]*j+a,u=h[5]*e+u,l((p*r).toFixed(3)+" "+((y-m)*r).toFixed(3)+" "+(f*r).toFixed(3)+" "+((y-q)*r).toFixed(3)+" "+(a*r).toFixed(3)+" "+((y-u)*r).toFixed(3)+" c"));l(b);return this};
		D.rect=function(c,a,d,e,b){b=Y(b);l([v(c*r),v((y-a)*r),v(d*r),v(-e*r),"re",b].join(" "));return this};D.triangle=function(c,a,d,e,b,j,h){this.lines([[d-c,e-a],[b-d,j-e],[c-b,a-j]],c,a,[1,1],h);return this};D.roundedRect=function(c,a,d,e,b,j,h){var g=4/3*(Math.SQRT2-1);this.lines([[d-2*b,0],[b*g,0,b,j-j*g,b,j],[0,e-2*j],[0,j*g,-(b*g),j,-b,j],[-d+2*b,0],[-(b*g),0,-b,-(j*g),-b,-j],[0,-e+2*j],[0,-(j*g),b*g,-j,b,-j]],c+b,a,[1,1],h);return this};D.ellipse=function(c,a,d,e,b){b=Y(b);var j=4/3*(Math.SQRT2-
		1)*d,g=4/3*(Math.SQRT2-1)*e;l([v((c+d)*r),v((y-a)*r),"m",v((c+d)*r),v((y-(a-g))*r),v((c+j)*r),v((y-(a-e))*r),v(c*r),v((y-(a-e))*r),"c"].join(" "));l([v((c-j)*r),v((y-(a-e))*r),v((c-d)*r),v((y-(a-g))*r),v((c-d)*r),v((y-a)*r),"c"].join(" "));l([v((c-d)*r),v((y-(a+g))*r),v((c-j)*r),v((y-(a+e))*r),v(c*r),v((y-(a+e))*r),"c"].join(" "));l([v((c+j)*r),v((y-(a+e))*r),v((c+d)*r),v((y-(a+g))*r),v((c+d)*r),v((y-a)*r),"c",b].join(" "));return this};D.circle=function(c,a,d,e){return this.ellipse(c,a,d,d,e)};D.setProperties=
		function(c){for(var a in I)I.hasOwnProperty(a)&&c[a]&&(I[a]=c[a]);return this};D.setFontSize=function(c){z=c;return this};D.setFont=function(c,a){A=E(c,a);return this};D.setFontStyle=D.setFontType=function(c){A=E(void 0,c);return this};D.getFontList=function(){var c={},a,d,e;for(a in x)if(x.hasOwnProperty(a))for(d in c[a]=e=[],x[a])x[a].hasOwnProperty(d)&&e.push(d);return c};D.setLineWidth=function(c){l((c*r).toFixed(2)+" w");return this};D.setDrawColor=function(c,a,d,e){c=void 0===a||void 0===e&&
		c===a===d?"string"===typeof c?c+" G":v(c/255)+" G":void 0===e?"string"===typeof c?[c,a,d,"RG"].join(" "):[v(c/255),v(a/255),v(d/255),"RG"].join(" "):"string"===typeof c?[c,a,d,e,"K"].join(" "):[v(c),v(a),v(d),v(e),"K"].join(" ");l(c);return this};D.setFillColor=function(c,a,d,e){c=void 0===a||void 0===e&&c===a===d?"string"===typeof c?c+" g":v(c/255)+" g":void 0===e?"string"===typeof c?[c,a,d,"rg"].join(" "):[v(c/255),v(a/255),v(d/255),"rg"].join(" "):"string"===typeof c?[c,a,d,e,"k"].join(" "):[v(c),
		v(a),v(d),v(e),"k"].join(" ");l(c);return this};D.setTextColor=function(c,a,d){u=0===c&&0===a&&0===d||"undefined"===typeof a?(c/255).toFixed(3)+" g":[(c/255).toFixed(3),(a/255).toFixed(3),(d/255).toFixed(3),"rg"].join(" ");return this};D.CapJoinStyles={"0":0,butt:0,but:0,bevel:0,1:1,round:1,rounded:1,circle:1,2:2,projecting:2,project:2,square:2,milter:2};D.setLineCap=function(c){var a=this.CapJoinStyles[c];if(void 0===a)throw Error("Line cap style of '"+c+"' is not recognized. See or extend .CapJoinStyles property for valid styles");
		w=a;l(a.toString(10)+" J");return this};D.setLineJoin=function(c){var a=this.CapJoinStyles[c];if(void 0===a)throw Error("Line join style of '"+c+"' is not recognized. See or extend .CapJoinStyles property for valid styles");aa=a;l(a.toString(10)+" j");return this};D.output=Z;D.save=function(c){D.output("save",c)};for(B in f.API)if(f.API.hasOwnProperty(B))if("events"===B&&f.API.events.length){g=G;d=f.API.events;h=a=e=void 0;for(h=d.length-1;-1!==h;h--)e=d[h][0],a=d[h][1],g.subscribe.apply(g,[e].concat("function"===
		typeof a?[a]:a))}else D[B]=f.API[B];B=[["Helvetica","helvetica","normal"],["Helvetica-Bold","helvetica","bold"],["Helvetica-Oblique","helvetica","italic"],["Helvetica-BoldOblique","helvetica","bolditalic"],["Courier","courier","normal"],["Courier-Bold","courier","bold"],["Courier-Oblique","courier","italic"],["Courier-BoldOblique","courier","bolditalic"],["Times-Roman","times","normal"],["Times-Bold","times","bold"],["Times-Italic","times","italic"],["Times-BoldItalic","times","bolditalic"]];g=0;
		for(d=B.length;g<d;g++){h=B[g][0];var T=B[g][1],a=B[g][2];e="F"+(b(n)+1).toString(10);h=n[e]={id:e,PostScriptName:h,fontName:T,fontStyle:a,encoding:"StandardEncoding",metadata:{}};var ha=e;void 0===x[T]&&(x[T]={});x[T][a]=ha;G.publish("addFont",h);a=e;e=B[g][0].split("-");h=e[0];e=e[1]||"";void 0===x[h]&&(x[h]={});x[h][e]=a}G.publish("addFonts",{fonts:n,dictionary:x});A="F1";W();G.publish("initialized");return D}"undefined"===typeof btoa&&(window.btoa=function(b){var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split(""),
		e,h,a,p,j=0,m=0,f="",f=[];do e=b.charCodeAt(j++),h=b.charCodeAt(j++),a=b.charCodeAt(j++),p=e<<16|h<<8|a,e=p>>18&63,h=p>>12&63,a=p>>6&63,p&=63,f[m++]=d[e]+d[h]+d[a]+d[p];while(j<b.length);f=f.join("");b=b.length%3;return(b?f.slice(0,b-3):f)+"===".slice(b||3)});"undefined"===typeof atob&&(window.atob=function(b){var d,e,h,a,p,j=0,m=0;a="";var f=[];if(!b)return b;b+="";do d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(j++)),e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(j++)),
		a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(j++)),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(j++)),h=d<<18|e<<12|a<<6|p,d=h>>16&255,e=h>>8&255,h&=255,64===a?f[m++]=String.fromCharCode(d):64===p?f[m++]=String.fromCharCode(d,e):f[m++]=String.fromCharCode(d,e,h);while(j<b.length);return a=f.join("")});var b="function"===typeof Object.keys?function(b){return Object.keys(b).length}:function(b){var d=0,e;for(e in b)b.hasOwnProperty(e)&&
		d++;return d},k=function(b){this.topics={};this.context=b;this.publish=function(d,b){if(this.topics[d]){var h=this.topics[d],a=[],p,j,g,f,c=function(){};b=Array.prototype.slice.call(arguments,1);j=0;for(g=h.length;j<g;j++)f=h[j],p=f[0],f[1]&&(f[0]=c,a.push(j)),p.apply(this.context,b);j=0;for(g=a.length;j<g;j++)h.splice(a[j],1)}};this.subscribe=function(d,b,h){this.topics[d]?this.topics[d].push([b,h]):this.topics[d]=[[b,h]];return{topic:d,callback:b}};this.unsubscribe=function(d){if(this.topics[d.topic]){var b=
		this.topics[d.topic],h,a;h=0;for(a=b.length;h<a;h++)b[h][0]===d.callback&&b.splice(h,1)}}};f.API={events:[]};return f}();
		(function(f){var b=function(){var b=this.internal.collections.addImage_images,d;for(d in b){var e=b[d],h=this.internal.newObject(),a=this.internal.write,p=this.internal.putStream;e.n=h;a("<</Type /XObject");a("/Subtype /Image");a("/Width "+e.w);a("/Height "+e.h);"Indexed"===e.cs?a("/ColorSpace [/Indexed /DeviceRGB "+(e.pal.length/3-1)+" "+(h+1)+" 0 R]"):(a("/ColorSpace /"+e.cs),"DeviceCMYK"===e.cs&&a("/Decode [1 0 1 0 1 0 1 0]"));a("/BitsPerComponent "+e.bpc);"f"in e&&a("/Filter /"+e.f);"dp"in e&&
		a("/DecodeParms <<"+e.dp+">>");if("trns"in e&&e.trns.constructor==Array)for(var j="",f=0;f<e.trns.length;f++)j+=e[j][f]+" "+e.trns[f]+" ",a("/Mask ["+j+"]");"smask"in e&&a("/SMask "+(h+1)+" 0 R");a("/Length "+e.data.length+">>");p(e.data);a("endobj")}},k=function(){var b=this.internal.collections.addImage_images,d=this.internal.write,e,h;for(h in b)e=b[h],d("/I"+e.i,e.n,"0","R")};f.addImage=function(g,d,e,h,a,p){if("object"===typeof g&&1===g.nodeType){d=document.createElement("canvas");d.width=g.clientWidth;
		d.height=g.clientHeight;var j=d.getContext("2d");if(!j)throw"addImage requires canvas to be supported by browser.";j.drawImage(g,0,0,d.width,d.height);g=d.toDataURL("image/jpeg");d="JPEG"}if("JPEG"!==d.toUpperCase())throw Error("addImage currently only supports format 'JPEG', not '"+d+"'");var f;d=this.internal.collections.addImage_images;var j=this.internal.getCoordinateString,u=this.internal.getVerticalCoordinateString;"data:image/jpeg;base64,"===g.substring(0,23)&&(g=atob(g.replace("data:image/jpeg;base64,",
		"")));if(d)if(Object.keys)f=Object.keys(d).length;else{var c=d,q=0;for(f in c)c.hasOwnProperty(f)&&q++;f=q}else f=0,this.internal.collections.addImage_images=d={},this.internal.events.subscribe("putResources",b),this.internal.events.subscribe("putXobjectDict",k);a:{var c=g,C;if(255===!c.charCodeAt(0)||216===!c.charCodeAt(1)||255===!c.charCodeAt(2)||224===!c.charCodeAt(3)||74===!c.charCodeAt(6)||70===!c.charCodeAt(7)||73===!c.charCodeAt(8)||70===!c.charCodeAt(9)||0===!c.charCodeAt(10))throw Error("getJpegSize requires a binary jpeg file");
		C=256*c.charCodeAt(4)+c.charCodeAt(5);for(var q=4,F=c.length;q<F;){q+=C;if(255!==c.charCodeAt(q))throw Error("getJpegSize could not find the size of the image");if(192===c.charCodeAt(q+1)){C=256*c.charCodeAt(q+5)+c.charCodeAt(q+6);c=256*c.charCodeAt(q+7)+c.charCodeAt(q+8);c=[c,C];break a}else q+=2,C=256*c.charCodeAt(q)+c.charCodeAt(q+1)}c=void 0}g={w:c[0],h:c[1],cs:"DeviceRGB",bpc:8,f:"DCTDecode",i:f,data:g};d[f]=g;!a&&!p&&(p=a=-96);0>a&&(a=-72*g.w/a/this.internal.scaleFactor);0>p&&(p=-72*g.h/p/this.internal.scaleFactor);
		0===a&&(a=p*g.w/g.h);0===p&&(p=a*g.h/g.w);this.internal.write("q",j(a),"0 0",j(p),j(e),u(h+p),"cm /I"+g.i,"Do Q");return this}})(jsPDF.API);
		(function(f){function b(a,b,d,e){this.pdf=a;this.x=b;this.y=d;this.settings=e;this.init();return this}function k(b){var d=a[b];if(d)return d;d={"xx-small":9,"x-small":11,small:13,medium:16,large:19,"x-large":23,"xx-large":28,auto:0}[b];if(void 0!==d||(d=parseFloat(b)))return a[b]=d/16;d=b.match(/([\d\.]+)(px)/);return 3===d.length?a[b]=parseFloat(d[1])/16:a[b]=1}function g(a,b,f){var u=a.childNodes,c;c=$(a);a={};for(var q,C=c.css("font-family").split(","),F=C.shift();!q&&F;)q=d[F.trim().toLowerCase()],
		F=C.shift();a["font-family"]=q||"times";a["font-style"]=h[c.css("font-style")]||"normal";q=e[c.css("font-weight")]||"normal";"bold"===q&&(a["font-style"]="normal"===a["font-style"]?q:q+a["font-style"]);a["font-size"]=k(c.css("font-size"))||1;a["line-height"]=k(c.css("line-height"))||1;a.display="inline"===c.css("display")?"inline":"block";"block"===a.display&&(a["margin-top"]=k(c.css("margin-top"))||0,a["margin-bottom"]=k(c.css("margin-bottom"))||0,a["padding-top"]=k(c.css("padding-top"))||0,a["padding-bottom"]=
		k(c.css("padding-bottom"))||0);if(q="block"===a.display)b.setBlockBoundary(),b.setBlockStyle(a);C=0;for(F=u.length;C<F;C++)if(c=u[C],"object"===typeof c)if(1===c.nodeType&&"SCRIPT"!=c.nodeName){var H=c,n=b,x=f,z=!1,A=void 0,y=void 0,s=x["#"+H.id];if(s)if("function"===typeof s)z=s(H,n);else{A=0;for(y=s.length;!z&&A!==y;)z=s[A](H,n),A++}s=x[H.nodeName];if(!z&&s)if("function"===typeof s)z=s(H,n);else{A=0;for(y=s.length;!z&&A!==y;)z=s[A](H,n),A++}z||g(c,b,f)}else 3===c.nodeType&&b.addText(c.nodeValue,
		a);else"string"===typeof c&&b.addText(c,a);q&&b.setBlockBoundary()}String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")});String.prototype.trimLeft||(String.prototype.trimLeft=function(){return this.replace(/^\s+/g,"")});String.prototype.trimRight||(String.prototype.trimRight=function(){return this.replace(/\s+$/g,"")});b.prototype.init=function(){this.paragraph={text:[],style:[]};this.pdf.internal.write("q")};b.prototype.dispose=function(){this.pdf.internal.write("Q");
		return{x:this.x,y:this.y}};b.prototype.splitFragmentsIntoLines=function(a,b){for(var d=this.pdf.internal.scaleFactor,e={},c,h,g,f,k,n=[],x=[n],z=0,A=this.settings.width;a.length;)if(f=a.shift(),k=b.shift(),f)if(c=k["font-family"],h=k["font-style"],g=e[c+h],g||(g=this.pdf.internal.getFont(c,h).metadata.Unicode,e[c+h]=g),c={widths:g.widths,kerning:g.kerning,fontSize:12*k["font-size"],textIndent:z},h=this.pdf.getStringUnitWidth(f,c)*c.fontSize/d,z+h>A){f=this.pdf.splitTextToSize(f,A,c);for(n.push([f.shift(),
		k]);f.length;)n=[[f.shift(),k]],x.push(n);z=this.pdf.getStringUnitWidth(n[0][0],c)*c.fontSize/d}else n.push([f,k]),z+=h;return x};b.prototype.RenderTextFragment=function(a,b){var d=this.pdf.internal.getFont(b["font-family"],b["font-style"]);this.pdf.internal.write("/"+d.id,(12*b["font-size"]).toFixed(2),"Tf","("+this.pdf.internal.pdfEscape(a)+") Tj")};b.prototype.renderParagraph=function(){for(var a=this.paragraph.text,b=0,d=a.length,e,c=!1,h=!1;!c&&b!==d;)(e=a[b]=a[b].trimLeft())&&(c=!0),b++;for(b=
		d-1;d&&!h&&-1!==b;)(e=a[b]=a[b].trimRight())&&(h=!0),b--;c=/\s+$/g;h=!0;for(b=0;b!==d;b++)e=a[b].replace(/\s+/g," "),h&&(e=e.trimLeft()),e&&(h=c.test(e)),a[b]=e;b=this.paragraph.style;e=(d=this.paragraph.blockstyle)||{};this.paragraph={text:[],style:[],blockstyle:{},priorblockstyle:d};if(a.join("").trim()){a=this.splitFragmentsIntoLines(a,b);b=12/this.pdf.internal.scaleFactor;c=(Math.max((d["margin-top"]||0)-(e["margin-bottom"]||0),0)+(d["padding-top"]||0))*b;d=((d["margin-bottom"]||0)+(d["padding-bottom"]||
		0))*b;e=this.pdf.internal.write;var g,f;this.y+=c;for(e("q","BT",this.pdf.internal.getCoordinateString(this.x),this.pdf.internal.getVerticalCoordinateString(this.y),"Td");a.length;){c=a.shift();g=h=0;for(f=c.length;g!==f;g++)c[g][0].trim()&&(h=Math.max(h,c[g][1]["line-height"],c[g][1]["font-size"]));e(0,(-12*h).toFixed(2),"Td");g=0;for(f=c.length;g!==f;g++)c[g][0]&&this.RenderTextFragment(c[g][0],c[g][1]);this.y+=h*b}e("ET","Q");this.y+=d}};b.prototype.setBlockBoundary=function(){this.renderParagraph()};
		b.prototype.setBlockStyle=function(a){this.paragraph.blockstyle=a};b.prototype.addText=function(a,b){this.paragraph.text.push(a);this.paragraph.style.push(b)};var d={helvetica:"helvetica","sans-serif":"helvetica",serif:"times",times:"times","times new roman":"times",monospace:"courier",courier:"courier"},e={100:"normal",200:"normal",300:"normal",400:"normal",500:"bold",600:"bold",700:"bold",800:"bold",900:"bold",normal:"normal",bold:"bold",bolder:"bold",lighter:"normal"},h={normal:"normal",italic:"italic",
		oblique:"italic"},a={normal:1};f.fromHTML=function(a,d,e,h){if("string"===typeof a){var c="jsPDFhtmlText"+Date.now().toString()+(1E3*Math.random()).toFixed(0);$('<div style="position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;"><iframe style="height:1px;width:1px" name="'+c+'" /></div>').appendTo(document.body);a=$(window.frames[c].document.body).html(a)[0]}d=
		new b(this,d,e,h);g(a,d,h.elementHandlers);return d.dispose()}})(jsPDF.API);
		(function(f){f.addSVG=function(b,f,g,d,e){if(void 0===f||void 0===f)throw Error("addSVG needs values for 'x' and 'y'");var h=document.createElement("iframe"),a=document.createElement("style");a.type="text/css";a.styleSheet?a.styleSheet.cssText=".jsPDF_sillysvg_iframe {display:none;position:absolute;}":a.appendChild(document.createTextNode(".jsPDF_sillysvg_iframe {display:none;position:absolute;}"));document.getElementsByTagName("head")[0].appendChild(a);h.name="childframe";h.setAttribute("width",
		0);h.setAttribute("height",0);h.setAttribute("frameborder","0");h.setAttribute("scrolling","no");h.setAttribute("seamless","seamless");h.setAttribute("class","jsPDF_sillysvg_iframe");document.body.appendChild(h);h=(h.contentWindow||h.contentDocument).document;h.write(b);h.close();h=h.getElementsByTagName("svg")[0];b=[1,1];var a=parseFloat(h.getAttribute("width")),p=parseFloat(h.getAttribute("height"));a&&p&&(d&&e?b=[d/a,e/p]:d?b=[d/a,d/a]:e&&(b=[e/p,e/p]));h=h.childNodes;d=0;for(e=h.length;d<e;d++)if(a=
		h[d],a.tagName&&"PATH"===a.tagName.toUpperCase()){for(var a=a.getAttribute("d").split(" "),p=parseFloat(a[1]),j=parseFloat(a[2]),m=[],u=3,c=a.length;u<c;)"c"===a[u]?(m.push([parseFloat(a[u+1]),parseFloat(a[u+2]),parseFloat(a[u+3]),parseFloat(a[u+4]),parseFloat(a[u+5]),parseFloat(a[u+6])]),u+=7):"l"===a[u]?(m.push([parseFloat(a[u+1]),parseFloat(a[u+2])]),u+=3):u+=1;a=[p,j,m];a[0]=a[0]*b[0]+f;a[1]=a[1]*b[1]+g;this.lines.call(this,a[2],a[0],a[1],b)}return this}})(jsPDF.API);
		(function(f){var b=f.getCharWidthsArray=function(b,e){e||(e={});var h=e.widths?e.widths:this.internal.getFont().metadata.Unicode.widths,a=h.fof?h.fof:1,g=e.kerning?e.kerning:this.internal.getFont().metadata.Unicode.kerning,f=g.fof?g.fof:1,m,k,c,q=0,C=h[0]||a,F=[];m=0;for(k=b.length;m<k;m++)c=b.charCodeAt(m),F.push((h[c]||C)/a+(g[c]&&g[c][q]||0)/f),q=c;return F},k=function(b){for(var e=b.length,h=0;e;)e--,h+=b[e];return h};f.getStringUnitWidth=function(d,e){return k(b.call(this,d,e))};var g=function(d,
		e,h){h||(h={});var a=b(" ",h)[0],g=d.split(" "),f=[];d=[f];var m=h.textIndent||0,u=0,c=0,q,C,F,H;F=0;for(H=g.length;F<H;F++){q=g[F];C=b(q,h);c=k(C);if(m+u+c>e){if(c>e){for(var c=q,n=C,x=e,z=[],A=0,y=c.length,s=0;A!==y&&s+n[A]<e-(m+u);)s+=n[A],A++;z.push(c.slice(0,A));m=A;for(s=0;A!==y;)s+n[A]>x&&(z.push(c.slice(m,A)),s=0,m=A),s+=n[A],A++;m!==A&&z.push(c.slice(m,A));m=z;f.push(m.shift());for(f=[m.pop()];m.length;)d.push([m.shift()]);c=k(C.slice(q.length-f[0].length))}else f=[q];d.push(f);m=c}else f.push(q),
		m+=u+c;u=a}e=[];F=0;for(H=d.length;F<H;F++)e.push(d[F].join(" "));return e};f.splitTextToSize=function(b,e,h){h||(h={});var a=h.fontSize||this.internal.getFontSize(),f;var j=h;f={"0":1};var m={};!j.widths||!j.kerning?(j=this.internal.getFont(j.fontName,j.fontStyle),f=j.metadata.Unicode?{widths:j.metadata.Unicode.widths||f,kerning:j.metadata.Unicode.kerning||m}:{widths:f,kerning:m}):f={widths:j.widths,kerning:j.kerning};b=b.match(/[\n\r]/)?b.split(/\r\n|\r|\n/g):[b];e=1*this.internal.scaleFactor*e/
		a;f.textIndent=h.textIndent?1*h.textIndent*this.internal.scaleFactor/a:0;m=[];h=0;for(a=b.length;h<a;h++)m=m.concat(g(b[h],e,f));return m}})(jsPDF.API);
		(function(f){var b=function(b){for(var d={},a=0;16>a;a++)d["klmnopqrstuvwxyz"[a]]="0123456789abcdef"[a];for(var g={},f=1,m,k=g,c=[],q,C="",F="",H,n=b.length-1,a=1;a!=n;)q=b[a],a+=1,"'"==q?m?(H=m.join(""),m=void 0):m=[]:m?m.push(q):"{"==q?(c.push([k,H]),k={},H=void 0):"}"==q?(q=c.pop(),q[0][q[1]]=k,H=void 0,k=q[0]):"-"==q?f=-1:void 0===H?d.hasOwnProperty(q)?(C+=d[q],H=parseInt(C,16)*f,f=1,C=""):C+=q:d.hasOwnProperty(q)?(F+=d[q],k[H]=parseInt(F,16)*f,f=1,H=void 0,F=""):F+=q;return g},k={codePages:["WinAnsiEncoding"],
		WinAnsiEncoding:b("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")},g={Unicode:{Courier:k,"Courier-Bold":k,"Courier-BoldOblique":k,"Courier-Oblique":k,Helvetica:k,"Helvetica-Bold":k,"Helvetica-BoldOblique":k,"Helvetica-Oblique":k,"Times-Roman":k,"Times-Bold":k,"Times-BoldItalic":k,"Times-Italic":k}},d={Unicode:{"Courier-Oblique":b("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-BoldItalic":b("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
		"Helvetica-Bold":b("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
		Courier:b("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-BoldOblique":b("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Bold":b("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
		Helvetica:b("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
		"Helvetica-BoldOblique":b("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
		"Courier-Bold":b("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Italic":b("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
		"Times-Roman":b("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
		"Helvetica-Oblique":b("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")}};
		f.events.push(["addFonts",function(b){var h,a,f,j;for(a in b.fonts)if(b.fonts.hasOwnProperty(a)){h=b.fonts[a];if(f=d.Unicode[h.PostScriptName])j=h.metadata.Unicode?h.metadata.Unicode:h.metadata.Unicode={},j.widths=f.widths,j.kerning=f.kerning;if(f=g.Unicode[h.PostScriptName])j=h.metadata.Unicode?h.metadata.Unicode:h.metadata.Unicode={},j.encoding=f,f.codePages&&f.codePages.length&&(h.encoding=f.codePages[0])}}])})(jsPDF.API);
		var BlobBuilder=BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder||function(f){var b=function(a){return Object.prototype.toString.call(a).match(/^\[object\s(.*)\]$/)[1]},k=function(){this.data=[]},g=function(a,b,c){this.data=a;this.size=a.length;this.type=b;this.encoding=c},d=k.prototype,e=g.prototype,h=f.FileReaderSync,a=function(a){this.code=this[this.name=a]},p="NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "),
		j=p.length,m=f.URL||f.webkitURL||f,u=m.createObjectURL,c=m.revokeObjectURL,q=m,C=f.btoa,F=f.atob,H=!1,n=function(a){H=!a},x=f.ArrayBuffer,z=f.Uint8Array;for(k.fake=e.fake=!0;j--;)a.prototype[p[j]]=j+1;try{z&&n.apply(0,new z(1))}catch(A){}m.createObjectURL||(q=f.URL={});q.createObjectURL=function(a){var b=a.type;null===b&&(b="application/octet-stream");if(a instanceof g)return b="data:"+b,"base64"===a.encoding?b+";base64,"+a.data:"URI"===a.encoding?b+","+decodeURIComponent(a.data):C?b+";base64,"+C(a.data):
		b+","+encodeURIComponent(a.data);if(u)return u.call(m,a)};q.revokeObjectURL=function(a){"data:"!==a.substring(0,5)&&c&&c.call(m,a)};d.append=function(c){var d=this.data;if(z&&c instanceof x)if(H)d.push(String.fromCharCode.apply(String,new z(c)));else{d="";c=new z(c);for(var e=0,f=c.length;e<f;e++)d+=String.fromCharCode(c[e])}else if("Blob"===b(c)||"File"===b(c))if(h)e=new h,d.push(e.readAsBinaryString(c));else throw new a("NOT_READABLE_ERR");else c instanceof g?"base64"===c.encoding&&F?d.push(F(c.data)):
		"URI"===c.encoding?d.push(decodeURIComponent(c.data)):"raw"===c.encoding&&d.push(c.data):("string"!==typeof c&&(c+=""),d.push(unescape(encodeURIComponent(c))))};d.getBlob=function(a){arguments.length||(a=null);return new g(this.data.join(""),a,"raw")};d.toString=function(){return"[object BlobBuilder]"};e.slice=function(a,c,b){var d=arguments.length;3>d&&(b=null);return new g(this.data.slice(a,1<d?c:this.data.length),b,this.encoding)};e.toString=function(){return"[object Blob]"};return k}(self),saveAs=
		saveAs||navigator.msSaveBlob&&navigator.msSaveBlob.bind(navigator)||function(f){var b=f.document,k=f.URL||f.webkitURL||f,g=b.createElementNS("http://www.w3.org/1999/xhtml","a"),d="download"in g,e=f.webkitRequestFileSystem,h=f.requestFileSystem||e||f.mozRequestFileSystem,a=function(a){(f.setImmediate||f.setTimeout)(function(){throw a;},0)},p=0,j=[],m=function(c,b,d){b=[].concat(b);for(var e=b.length;e--;){var f=c["on"+b[e]];if("function"===typeof f)try{f.call(c,d||c)}catch(h){a(h)}}},u=function(a,
		c){var k=this,u=a.type,n=!1,x,z,A=function(){var c=(f.URL||f.webkitURL||f).createObjectURL(a);j.push(c);return c},y=function(){m(k,["writestart","progress","write","writeend"])},s=function(){if(n||!x)x=A(a);z&&(z.location.href=x);k.readyState=k.DONE;y()},r=function(a){return function(){if(k.readyState!==k.DONE)return a.apply(this,arguments)}},I={create:!0,exclusive:!1},w;k.readyState=k.INIT;c||(c="download");if(d&&(x=A(a),g.href=x,g.download=c,w=b.createEvent("MouseEvents"),w.initMouseEvent("click",
		!0,!1,f,0,0,0,0,0,!1,!1,!1,!1,0,null),g.dispatchEvent(w))){k.readyState=k.DONE;y();return}f.chrome&&(u&&"application/octet-stream"!==u)&&(w=a.slice||a.webkitSlice,a=w.call(a,0,a.size,"application/octet-stream"),n=!0);e&&"download"!==c&&(c+=".download");z="application/octet-stream"===u||e?f:f.open();h?(p+=a.size,h(f.TEMPORARY,p,r(function(b){b.root.getDirectory("saved",I,r(function(b){var d=function(){b.getFile(c,I,r(function(c){c.createWriter(r(function(b){b.onwriteend=function(a){z.location.href=
		c.toURL();j.push(c);k.readyState=k.DONE;m(k,"writeend",a)};b.onerror=function(){var a=b.error;a.code!==a.ABORT_ERR&&s()};["writestart","progress","write","abort"].forEach(function(a){b["on"+a]=k["on"+a]});b.write(a);k.abort=function(){b.abort();k.readyState=k.DONE};k.readyState=k.WRITING}),s)}),s)};b.getFile(c,{create:!1},r(function(a){a.remove();d()}),r(function(a){a.code===a.NOT_FOUND_ERR?d():s()}))}),s)}),s)):s()},c=u.prototype;c.abort=function(){this.readyState=this.DONE;m(this,"abort")};c.readyState=
		c.INIT=0;c.WRITING=1;c.DONE=2;c.error=c.onwritestart=c.onprogress=c.onwrite=c.onabort=c.onerror=c.onwriteend=null;f.addEventListener("unload",function(){for(var a=j.length;a--;){var c=j[a];"string"===typeof c?k.revokeObjectURL(c):c.remove()}j.length=0},!1);return function(a,c){return new u(a,c)}}(self),MAX_BITS=15,D_CODES=30,BL_CODES=19,LENGTH_CODES=29,LITERALS=256,L_CODES=LITERALS+1+LENGTH_CODES,HEAP_SIZE=2*L_CODES+1,END_BLOCK=256,MAX_BL_BITS=7,REP_3_6=16,REPZ_3_10=17,REPZ_11_138=18,Buf_size=16,
		Z_DEFAULT_COMPRESSION=-1,Z_FILTERED=1,Z_HUFFMAN_ONLY=2,Z_DEFAULT_STRATEGY=0,Z_NO_FLUSH=0,Z_PARTIAL_FLUSH=1,Z_FULL_FLUSH=3,Z_FINISH=4,Z_OK=0,Z_STREAM_END=1,Z_NEED_DICT=2,Z_STREAM_ERROR=-2,Z_DATA_ERROR=-3,Z_BUF_ERROR=-5,_dist_code=[0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,17,18,18,19,19,20,20,20,20,21,
		21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
		28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29];
		function Tree(){var f=this;f.build_tree=function(b){var k=f.dyn_tree,g=f.stat_desc.static_tree,d=f.stat_desc.elems,e,h=-1,a;b.heap_len=0;b.heap_max=HEAP_SIZE;for(e=0;e<d;e++)0!==k[2*e]?(b.heap[++b.heap_len]=h=e,b.depth[e]=0):k[2*e+1]=0;for(;2>b.heap_len;)a=b.heap[++b.heap_len]=2>h?++h:0,k[2*a]=1,b.depth[a]=0,b.opt_len--,g&&(b.static_len-=g[2*a+1]);f.max_code=h;for(e=Math.floor(b.heap_len/2);1<=e;e--)b.pqdownheap(k,e);a=d;do e=b.heap[1],b.heap[1]=b.heap[b.heap_len--],b.pqdownheap(k,1),g=b.heap[1],
		b.heap[--b.heap_max]=e,b.heap[--b.heap_max]=g,k[2*a]=k[2*e]+k[2*g],b.depth[a]=Math.max(b.depth[e],b.depth[g])+1,k[2*e+1]=k[2*g+1]=a,b.heap[1]=a++,b.pqdownheap(k,1);while(2<=b.heap_len);b.heap[--b.heap_max]=b.heap[1];e=f.dyn_tree;for(var h=f.stat_desc.static_tree,p=f.stat_desc.extra_bits,j=f.stat_desc.extra_base,m=f.stat_desc.max_length,u,c,q=0,d=0;d<=MAX_BITS;d++)b.bl_count[d]=0;e[2*b.heap[b.heap_max]+1]=0;for(a=b.heap_max+1;a<HEAP_SIZE;a++)g=b.heap[a],d=e[2*e[2*g+1]+1]+1,d>m&&(d=m,q++),e[2*g+1]=
		d,g>f.max_code||(b.bl_count[d]++,u=0,g>=j&&(u=p[g-j]),c=e[2*g],b.opt_len+=c*(d+u),h&&(b.static_len+=c*(h[2*g+1]+u)));if(0!==q){do{for(d=m-1;0===b.bl_count[d];)d--;b.bl_count[d]--;b.bl_count[d+1]+=2;b.bl_count[m]--;q-=2}while(0<q);for(d=m;0!==d;d--)for(g=b.bl_count[d];0!==g;)h=b.heap[--a],h>f.max_code||(e[2*h+1]!=d&&(b.opt_len+=(d-e[2*h+1])*e[2*h],e[2*h+1]=d),g--)}e=f.max_code;a=b.bl_count;b=[];g=0;for(d=1;d<=MAX_BITS;d++)b[d]=g=g+a[d-1]<<1;for(a=0;a<=e;a++)if(p=k[2*a+1],0!==p){g=k;d=2*a;h=b[p]++;
		j=0;do j|=h&1,h>>>=1,j<<=1;while(0<--p);g[d]=j>>>1}}}
		Tree._length_code=[0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,
		25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28];Tree.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0];Tree.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576];
		Tree.d_code=function(f){return 256>f?_dist_code[f]:_dist_code[256+(f>>>7)]};Tree.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];Tree.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];Tree.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];Tree.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function StaticTree(f,b,k,g,d){this.static_tree=f;this.extra_bits=b;this.extra_base=k;this.elems=g;this.max_length=d}
		StaticTree.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,
		8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,
		9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,
		48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8];StaticTree.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5];StaticTree.static_l_desc=new StaticTree(StaticTree.static_ltree,Tree.extra_lbits,LITERALS+1,L_CODES,MAX_BITS);
		StaticTree.static_d_desc=new StaticTree(StaticTree.static_dtree,Tree.extra_dbits,0,D_CODES,MAX_BITS);StaticTree.static_bl_desc=new StaticTree(null,Tree.extra_blbits,0,BL_CODES,MAX_BL_BITS);var MAX_MEM_LEVEL=9,DEF_MEM_LEVEL=8;function Config(f,b,k,g,d){this.good_length=f;this.max_lazy=b;this.nice_length=k;this.max_chain=g;this.func=d}
		var STORED=0,FAST=1,SLOW=2,config_table=[new Config(0,0,0,0,STORED),new Config(4,4,8,4,FAST),new Config(4,5,16,8,FAST),new Config(4,6,32,32,FAST),new Config(4,4,16,16,SLOW),new Config(8,16,32,32,SLOW),new Config(8,16,128,128,SLOW),new Config(8,32,128,256,SLOW),new Config(32,128,258,1024,SLOW),new Config(32,258,258,4096,SLOW)],z_errmsg="need dictionary;stream end;;;stream error;data error;;buffer error;;".split(";"),NeedMore=0,BlockDone=1,FinishStarted=2,FinishDone=3,PRESET_DICT=32,INIT_STATE=42,BUSY_STATE=
		113,FINISH_STATE=666,Z_DEFLATED=8,STORED_BLOCK=0,STATIC_TREES=1,DYN_TREES=2,MIN_MATCH=3,MAX_MATCH=258,MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1;function smaller(f,b,k,g){var d=f[2*b];f=f[2*k];return d<f||d==f&&g[b]<=g[k]}
		function Deflate(){function f(){var a;for(a=0;a<L_CODES;a++)U[2*a]=0;for(a=0;a<D_CODES;a++)X[2*a]=0;for(a=0;a<BL_CODES;a++)O[2*a]=0;U[2*END_BLOCK]=1;S=la=n.opt_len=n.static_len=0}function b(a,c){var b,d=-1,e,f=a[1],h=0,g=7,j=4;0===f&&(g=138,j=3);a[2*(c+1)+1]=65535;for(b=0;b<=c;b++)e=f,f=a[2*(b+1)+1],++h<g&&e==f||(h<j?O[2*e]+=h:0!==e?(e!=d&&O[2*e]++,O[2*REP_3_6]++):10>=h?O[2*REPZ_3_10]++:O[2*REPZ_11_138]++,h=0,d=e,0===f?(g=138,j=3):e==f?(g=6,j=3):(g=7,j=4))}function k(a){n.pending_buf[n.pending++]=
		a}function g(a){k(a&255);k(a>>>8&255)}function d(a,c){L>Buf_size-c?(P|=a<<L&65535,g(P),P=a>>>Buf_size-L,L+=c-Buf_size):(P|=a<<L&65535,L+=c)}function e(a,c){var b=2*a;d(c[b]&65535,c[b+1]&65535)}function h(a,c){var b,f=-1,h,g=a[1],j=0,k=7,l=4;0===g&&(k=138,l=3);for(b=0;b<=c;b++)if(h=g,g=a[2*(b+1)+1],!(++j<k&&h==g)){if(j<l){do e(h,O);while(0!==--j)}else 0!==h?(h!=f&&(e(h,O),j--),e(REP_3_6,O),d(j-3,2)):10>=j?(e(REPZ_3_10,O),d(j-3,3)):(e(REPZ_11_138,O),d(j-11,7));j=0;f=h;0===g?(k=138,l=3):h==g?(k=6,l=
		3):(k=7,l=4)}}function a(){16==L?(g(P),L=P=0):8<=L&&(k(P&255),P>>>=8,L-=8)}function p(a,c){var b,d,e;n.pending_buf[fa+2*S]=a>>>8&255;n.pending_buf[fa+2*S+1]=a&255;n.pending_buf[ka+S]=c&255;S++;0===a?U[2*c]++:(la++,a--,U[2*(Tree._length_code[c]+LITERALS+1)]++,X[2*Tree.d_code(a)]++);if(0===(S&8191)&&2<M){b=8*S;d=t-Q;for(e=0;e<D_CODES;e++)b+=X[2*e]*(5+Tree.extra_dbits[e]);if(la<Math.floor(S/2)&&b>>>3<Math.floor(d/2))return!0}return S==ba-1}function j(a,c){var b,f,h=0,g,j;if(0!==S){do b=n.pending_buf[fa+
		2*h]<<8&65280|n.pending_buf[fa+2*h+1]&255,f=n.pending_buf[ka+h]&255,h++,0===b?e(f,a):(g=Tree._length_code[f],e(g+LITERALS+1,a),j=Tree.extra_lbits[g],0!==j&&(f-=Tree.base_length[g],d(f,j)),b--,g=Tree.d_code(b),e(g,c),j=Tree.extra_dbits[g],0!==j&&(b-=Tree.base_dist[g],d(b,j)));while(h<S)}e(END_BLOCK,a);ga=a[2*END_BLOCK+1]}function m(){8<L?g(P):0<L&&k(P&255);L=P=0}function u(a,c,b){d((STORED_BLOCK<<1)+(b?1:0),3);m();ga=8;g(c);g(~c);n.pending_buf.set(w.subarray(a,a+c),n.pending);n.pending+=c}function c(a){var c=
		0<=Q?Q:-1,e=t-Q,g,k,l=0;if(0<M){da.build_tree(n);ea.build_tree(n);b(U,da.max_code);b(X,ea.max_code);ja.build_tree(n);for(l=BL_CODES-1;3<=l&&0===O[2*Tree.bl_order[l]+1];l--);n.opt_len+=3*(l+1)+14;g=n.opt_len+3+7>>>3;k=n.static_len+3+7>>>3;k<=g&&(g=k)}else g=k=e+5;if(e+4<=g&&-1!=c)u(c,e,a);else if(k==g)d((STATIC_TREES<<1)+(a?1:0),3),j(StaticTree.static_ltree,StaticTree.static_dtree);else{d((DYN_TREES<<1)+(a?1:0),3);c=da.max_code+1;e=ea.max_code+1;l+=1;d(c-257,5);d(e-1,5);d(l-4,4);for(g=0;g<l;g++)d(O[2*
		Tree.bl_order[g]+1],3);h(U,c-1);h(X,e-1);j(U,X)}f();a&&m();Q=t;x.flush_pending()}function q(){var a,c,b,d;do{d=aa-E-t;if(0===d&&0===t&&0===E)d=s;else if(-1==d)d--;else if(t>=s+s-MIN_LOOKAHEAD){w.set(w.subarray(s,s+s),0);W-=s;t-=s;Q-=s;b=a=v;do c=G[--b]&65535,G[b]=c>=s?c-s:0;while(0!==--a);b=a=s;do c=D[--b]&65535,D[b]=c>=s?c-s:0;while(0!==--a);d+=s}if(0===x.avail_in)break;a=x.read_buf(w,t+E,d);E+=a;E>=MIN_MATCH&&(B=w[t]&255,B=(B<<N^w[t+1]&255)&l)}while(E<MIN_LOOKAHEAD&&0!==x.avail_in)}function C(a){var b=
		65535,d;for(b>A-5&&(b=A-5);;){if(1>=E){q();if(0===E&&a==Z_NO_FLUSH)return NeedMore;if(0===E)break}t+=E;E=0;d=Q+b;if(0===t||t>=d)if(E=t-d,t=d,c(!1),0===x.avail_out)return NeedMore;if(t-Q>=s-MIN_LOOKAHEAD&&(c(!1),0===x.avail_out))return NeedMore}c(a==Z_FINISH);return 0===x.avail_out?a==Z_FINISH?FinishStarted:NeedMore:a==Z_FINISH?FinishDone:BlockDone}function F(a){var c=Y,b=t,d,e=K,g=t>s-MIN_LOOKAHEAD?t-(s-MIN_LOOKAHEAD):0,f=ia,h=I,j=t+MAX_MATCH,k=w[b+e-1],l=w[b+e];K>=ha&&(c>>=2);f>E&&(f=E);do if(d=
		a,!(w[d+e]!=l||w[d+e-1]!=k||w[d]!=w[b]||w[++d]!=w[b+1])){b+=2;d++;do;while(w[++b]==w[++d]&&w[++b]==w[++d]&&w[++b]==w[++d]&&w[++b]==w[++d]&&w[++b]==w[++d]&&w[++b]==w[++d]&&w[++b]==w[++d]&&w[++b]==w[++d]&&b<j);d=MAX_MATCH-(j-b);b=j-MAX_MATCH;if(d>e){W=a;e=d;if(d>=f)break;k=w[b+e-1];l=w[b+e]}}while((a=D[a&h]&65535)>g&&0!==--c);return e<=E?e:E}function H(a){for(var b=0,d,e;;){if(E<MIN_LOOKAHEAD){q();if(E<MIN_LOOKAHEAD&&a==Z_NO_FLUSH)return NeedMore;if(0===E)break}E>=MIN_MATCH&&(B=(B<<N^w[t+(MIN_MATCH-
		1)]&255)&l,b=G[B]&65535,D[t&I]=G[B],G[B]=t);K=J;ca=W;J=MIN_MATCH-1;if(0!==b&&(K<Z&&(t-b&65535)<=s-MIN_LOOKAHEAD)&&(T!=Z_HUFFMAN_ONLY&&(J=F(b)),5>=J&&(T==Z_FILTERED||J==MIN_MATCH&&4096<t-W)))J=MIN_MATCH-1;if(K>=MIN_MATCH&&J<=K){e=t+E-MIN_MATCH;d=p(t-1-ca,K-MIN_MATCH);E-=K-1;K-=2;do++t<=e&&(B=(B<<N^w[t+(MIN_MATCH-1)]&255)&l,b=G[B]&65535,D[t&I]=G[B],G[B]=t);while(0!==--K);R=0;J=MIN_MATCH-1;t++;if(d&&(c(!1),0===x.avail_out))return NeedMore}else if(0!==R){if((d=p(0,w[t-1]&255))&&c(!1),t++,E--,0===x.avail_out)return NeedMore}else R=
		1,t++,E--}0!==R&&(p(0,w[t-1]&255),R=0);c(a==Z_FINISH);return 0===x.avail_out?a==Z_FINISH?FinishStarted:NeedMore:a==Z_FINISH?FinishDone:BlockDone}var n=this,x,z,A,y,s,r,I,w,aa,D,G,B,v,V,l,N,Q,J,ca,R,t,W,E,K,Y,Z,M,T,ha,ia,U,X,O,da=new Tree,ea=new Tree,ja=new Tree;n.depth=[];var ka,ba,S,fa,la,ga,P,L;n.bl_count=[];n.heap=[];U=[];X=[];O=[];n.pqdownheap=function(a,b){for(var c=n.heap,d=c[b],e=b<<1;e<=n.heap_len;){e<n.heap_len&&smaller(a,c[e+1],c[e],n.depth)&&e++;if(smaller(a,d,c[e],n.depth))break;c[b]=
		c[e];b=e;e<<=1}c[b]=d};n.deflateInit=function(a,b,c,d,e,g){d||(d=Z_DEFLATED);e||(e=DEF_MEM_LEVEL);g||(g=Z_DEFAULT_STRATEGY);a.msg=null;b==Z_DEFAULT_COMPRESSION&&(b=6);if(1>e||e>MAX_MEM_LEVEL||d!=Z_DEFLATED||9>c||15<c||0>b||9<b||0>g||g>Z_HUFFMAN_ONLY)return Z_STREAM_ERROR;a.dstate=n;r=c;s=1<<r;I=s-1;V=e+7;v=1<<V;l=v-1;N=Math.floor((V+MIN_MATCH-1)/MIN_MATCH);w=new Uint8Array(2*s);D=[];G=[];ba=1<<e+6;n.pending_buf=new Uint8Array(4*ba);A=4*ba;fa=Math.floor(ba/2);ka=3*ba;M=b;T=g;a.total_in=a.total_out=
		0;a.msg=null;n.pending=0;n.pending_out=0;z=BUSY_STATE;y=Z_NO_FLUSH;da.dyn_tree=U;da.stat_desc=StaticTree.static_l_desc;ea.dyn_tree=X;ea.stat_desc=StaticTree.static_d_desc;ja.dyn_tree=O;ja.stat_desc=StaticTree.static_bl_desc;L=P=0;ga=8;f();aa=2*s;for(a=G[v-1]=0;a<v-1;a++)G[a]=0;Z=config_table[M].max_lazy;ha=config_table[M].good_length;ia=config_table[M].nice_length;Y=config_table[M].max_chain;E=Q=t=0;J=K=MIN_MATCH-1;B=R=0;return Z_OK};n.deflateEnd=function(){if(z!=INIT_STATE&&z!=BUSY_STATE&&z!=FINISH_STATE)return Z_STREAM_ERROR;
		w=D=G=n.pending_buf=null;n.dstate=null;return z==BUSY_STATE?Z_DATA_ERROR:Z_OK};n.deflateParams=function(a,b,c){var d=Z_OK;b==Z_DEFAULT_COMPRESSION&&(b=6);if(0>b||9<b||0>c||c>Z_HUFFMAN_ONLY)return Z_STREAM_ERROR;config_table[M].func!=config_table[b].func&&0!==a.total_in&&(d=a.deflate(Z_PARTIAL_FLUSH));M!=b&&(M=b,Z=config_table[M].max_lazy,ha=config_table[M].good_length,ia=config_table[M].nice_length,Y=config_table[M].max_chain);T=c;return d};n.deflateSetDictionary=function(a,b,c){a=c;var d=0;if(!b||
		z!=INIT_STATE)return Z_STREAM_ERROR;if(a<MIN_MATCH)return Z_OK;a>s-MIN_LOOKAHEAD&&(a=s-MIN_LOOKAHEAD,d=c-a);w.set(b.subarray(d,d+a),0);Q=t=a;B=w[0]&255;B=(B<<N^w[1]&255)&l;for(b=0;b<=a-MIN_MATCH;b++)B=(B<<N^w[b+(MIN_MATCH-1)]&255)&l,D[b&I]=G[B],G[B]=b;return Z_OK};n.deflate=function(b,g){var f,h,j;if(g>Z_FINISH||0>g)return Z_STREAM_ERROR;if(!b.next_out||!b.next_in&&0!==b.avail_in||z==FINISH_STATE&&g!=Z_FINISH)return b.msg=z_errmsg[Z_NEED_DICT-Z_STREAM_ERROR],Z_STREAM_ERROR;if(0===b.avail_out)return b.msg=
		z_errmsg[Z_NEED_DICT-Z_BUF_ERROR],Z_BUF_ERROR;x=b;f=y;y=g;z==INIT_STATE&&(h=Z_DEFLATED+(r-8<<4)<<8,j=(M-1&255)>>1,3<j&&(j=3),h|=j<<6,0!==t&&(h|=PRESET_DICT),z=BUSY_STATE,h+=31-h%31,k(h>>8&255),k(h&255));if(0!==n.pending){if(x.flush_pending(),0===x.avail_out)return y=-1,Z_OK}else if(0===x.avail_in&&g<=f&&g!=Z_FINISH)return x.msg=z_errmsg[Z_NEED_DICT-Z_BUF_ERROR],Z_BUF_ERROR;if(z==FINISH_STATE&&0!==x.avail_in)return b.msg=z_errmsg[Z_NEED_DICT-Z_BUF_ERROR],Z_BUF_ERROR;if(0!==x.avail_in||0!==E||g!=Z_NO_FLUSH&&
		z!=FINISH_STATE){f=-1;switch(config_table[M].func){case STORED:f=C(g);break;case FAST:a:{for(f=0;;){if(E<MIN_LOOKAHEAD){q();if(E<MIN_LOOKAHEAD&&g==Z_NO_FLUSH){f=NeedMore;break a}if(0===E)break}E>=MIN_MATCH&&(B=(B<<N^w[t+(MIN_MATCH-1)]&255)&l,f=G[B]&65535,D[t&I]=G[B],G[B]=t);0!==f&&(t-f&65535)<=s-MIN_LOOKAHEAD&&T!=Z_HUFFMAN_ONLY&&(J=F(f));if(J>=MIN_MATCH)if(h=p(t-W,J-MIN_MATCH),E-=J,J<=Z&&E>=MIN_MATCH){J--;do t++,B=(B<<N^w[t+(MIN_MATCH-1)]&255)&l,f=G[B]&65535,D[t&I]=G[B],G[B]=t;while(0!==--J);t++}else t+=
		J,J=0,B=w[t]&255,B=(B<<N^w[t+1]&255)&l;else h=p(0,w[t]&255),E--,t++;if(h&&(c(!1),0===x.avail_out)){f=NeedMore;break a}}c(g==Z_FINISH);f=0===x.avail_out?g==Z_FINISH?FinishStarted:NeedMore:g==Z_FINISH?FinishDone:BlockDone}break;case SLOW:f=H(g)}if(f==FinishStarted||f==FinishDone)z=FINISH_STATE;if(f==NeedMore||f==FinishStarted)return 0===x.avail_out&&(y=-1),Z_OK;if(f==BlockDone){if(g==Z_PARTIAL_FLUSH)d(STATIC_TREES<<1,3),e(END_BLOCK,StaticTree.static_ltree),a(),9>1+ga+10-L&&(d(STATIC_TREES<<1,3),e(END_BLOCK,
		StaticTree.static_ltree),a()),ga=7;else if(u(0,0,!1),g==Z_FULL_FLUSH)for(f=0;f<v;f++)G[f]=0;x.flush_pending();if(0===x.avail_out)return y=-1,Z_OK}}return g!=Z_FINISH?Z_OK:Z_STREAM_END}}function ZStream(){this.total_out=this.avail_out=this.total_in=this.avail_in=this.next_out_index=this.next_in_index=0}
		ZStream.prototype={deflateInit:function(f,b){this.dstate=new Deflate;b||(b=MAX_BITS);return this.dstate.deflateInit(this,f,b)},deflate:function(f){return!this.dstate?Z_STREAM_ERROR:this.dstate.deflate(this,f)},deflateEnd:function(){if(!this.dstate)return Z_STREAM_ERROR;var f=this.dstate.deflateEnd();this.dstate=null;return f},deflateParams:function(f,b){return!this.dstate?Z_STREAM_ERROR:this.dstate.deflateParams(this,f,b)},deflateSetDictionary:function(f,b){return!this.dstate?Z_STREAM_ERROR:this.dstate.deflateSetDictionary(this,
		f,b)},read_buf:function(f,b,k){var g=this.avail_in;g>k&&(g=k);if(0===g)return 0;this.avail_in-=g;f.set(this.next_in.subarray(this.next_in_index,this.next_in_index+g),b);this.next_in_index+=g;this.total_in+=g;return g},flush_pending:function(){var f=this.dstate.pending;f>this.avail_out&&(f=this.avail_out);0!==f&&(this.next_out.set(this.dstate.pending_buf.subarray(this.dstate.pending_out,this.dstate.pending_out+f),this.next_out_index),this.next_out_index+=f,this.dstate.pending_out+=f,this.total_out+=
		f,this.avail_out-=f,this.dstate.pending-=f,0===this.dstate.pending&&(this.dstate.pending_out=0))}};
		function Deflater(f){var b=new ZStream,k=Z_NO_FLUSH,g=new Uint8Array(512);"undefined"==typeof f&&(f=Z_DEFAULT_COMPRESSION);b.deflateInit(f);b.next_out=g;this.append=function(d,e){var f,a=[],p=0,j=0,m=0,u;if(d.length){b.next_in_index=0;b.next_in=d;b.avail_in=d.length;do{b.next_out_index=0;b.avail_out=512;f=b.deflate(k);if(f!=Z_OK)throw"deflating: "+b.msg;b.next_out_index&&(512==b.next_out_index?a.push(new Uint8Array(g)):a.push(new Uint8Array(g.subarray(0,b.next_out_index))));m+=b.next_out_index;e&&
		(0<b.next_in_index&&b.next_in_index!=p)&&(e(b.next_in_index),p=b.next_in_index)}while(0<b.avail_in||0===b.avail_out);u=new Uint8Array(m);a.forEach(function(a){u.set(a,j);j+=a.length});return u}};this.flush=function(){var d,e=[],f=0,a=0,k;do{b.next_out_index=0;b.avail_out=512;d=b.deflate(Z_FINISH);if(d!=Z_STREAM_END&&d!=Z_OK)throw"deflating: "+b.msg;0<512-b.avail_out&&e.push(new Uint8Array(g.subarray(0,b.next_out_index)));a+=b.next_out_index}while(0<b.avail_in||0===b.avail_out);b.deflateEnd();k=new Uint8Array(a);
		e.forEach(function(a){k.set(a,f);f+=a.length});return k}}
		void function(f,b){"object"===typeof module?module.exports=b():"function"===typeof define?define(b):f.adler32cs=b()}(this,function(){var f="function"===typeof ArrayBuffer&&"function"===typeof Uint8Array,b=null,k;if(f){try{var g=require("buffer");"function"===typeof g.Buffer&&(b=g.Buffer)}catch(d){}k=function(a){return a instanceof ArrayBuffer||null!==b&&a instanceof b}}else k=function(){return!1};var e;e=null!==b?function(a){return(new b(a,"utf8")).toString("binary")}:function(a){return unescape(encodeURIComponent(a))};
		var h=function(a,b){for(var d=a&65535,e=a>>>16,f=0,g=b.length;f<g;f++)d=(d+(b.charCodeAt(f)&255))%65521,e=(e+d)%65521;return(e<<16|d)>>>0},a=function(a,b){for(var d=a&65535,e=a>>>16,f=0,g=b.length;f<g;f++)d=(d+b[f])%65521,e=(e+d)%65521;return(e<<16|d)>>>0},g={},p=function(a){if(!(this instanceof p))throw new TypeError("Constructor cannot called be as a function.");if(!isFinite(a=null==a?1:+a))throw Error("First arguments needs to be a finite number.");this.checksum=a>>>0},j=p.prototype={};j.constructor=
		p;var m=function(a){if(!(this instanceof p))throw new TypeError("Constructor cannot called be as a function.");if(null==a)throw Error("First argument needs to be a string.");this.checksum=h(1,a.toString())};m.prototype=j;p.from=m;m=function(a){if(!(this instanceof p))throw new TypeError("Constructor cannot called be as a function.");if(null==a)throw Error("First argument needs to be a string.");a=e(a.toString());this.checksum=h(1,a)};m.prototype=j;p.fromUtf8=m;f&&(m=function(b){if(!(this instanceof
		p))throw new TypeError("Constructor cannot called be as a function.");if(!k(b))throw Error("First argument needs to be ArrayBuffer.");b=new Uint8Array(b);return this.checksum=a(1,b)},m.prototype=j,p.fromBuffer=m);j.update=function(a){if(null==a)throw Error("First argument needs to be a string.");a=a.toString();return this.checksum=h(this.checksum,a)};j.updateUtf8=function(a){if(null==a)throw Error("First argument needs to be a string.");a=e(a.toString());return this.checksum=h(this.checksum,a)};f&&
		(j.updateBuffer=function(b){if(!k(b))throw Error("First argument needs to be ArrayBuffer.");b=new Uint8Array(b);return this.checksum=a(this.checksum,b)});j.clone=function(){return new u(this.checksum)};var u=g.Adler32=p;g.from=function(a){if(null==a)throw Error("First argument needs to be a string.");return h(1,a.toString())};g.fromUtf8=function(a){if(null==a)throw Error("First argument needs to be a string.");a=e(a.toString());return h(1,a)};f&&(g.fromBuffer=function(b){if(!k(b))throw Error("First argument need to be ArrayBuffer.");
		b=new Uint8Array(b);return a(1,b)});return g});



		/** @preserve 
		jsPDF split_text_to_size plugin
		Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
		MIT license.
		*/
		/**
		 * Permission is hereby granted, free of charge, to any person obtaining
		 * a copy of this software and associated documentation files (the
		 * "Software"), to deal in the Software without restriction, including
		 * without limitation the rights to use, copy, modify, merge, publish,
		 * distribute, sublicense, and/or sell copies of the Software, and to
		 * permit persons to whom the Software is furnished to do so, subject to
		 * the following conditions:
		 * 
		 * The above copyright notice and this permission notice shall be
		 * included in all copies or substantial portions of the Software.
		 * 
		 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
		 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
		 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
		 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
		 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		 * ====================================================================
		 */

		;(function(API) {
		'use strict'

		/**
		Returns an array of length matching length of the 'word' string, with each
		cell ocupied by the width of the char in that position.

		@function
		@param word {String}
		@param widths {Object}
		@param kerning {Object}
		@returns {Array}
		*/
		var getCharWidthsArray = API.getCharWidthsArray = function(text, options){

			if (!options) {
				options = {}
			}

			var widths = options.widths ? options.widths : this.internal.getFont().metadata.Unicode.widths
			, widthsFractionOf = widths.fof ? widths.fof : 1
			, kerning = options.kerning ? options.kerning : this.internal.getFont().metadata.Unicode.kerning
			, kerningFractionOf = kerning.fof ? kerning.fof : 1
			
			// console.log("widths, kergnings", widths, kerning)

			var i, l
			, char_code
			, char_width
			, prior_char_code = 0 // for kerning
			, default_char_width = widths[0] || widthsFractionOf
			, output = []

			for (i = 0, l = text.length; i < l; i++) {
				char_code = text.charCodeAt(i)
				output.push(
					( widths[char_code] || default_char_width ) / widthsFractionOf + 
					( kerning[char_code] && kerning[char_code][prior_char_code] || 0 ) / kerningFractionOf
				)
				prior_char_code = char_code
			}

			return output
		}
		var getArraySum = function(array){
			var i = array.length
			, output = 0
			while(i){
				;i--;
				output += array[i]
			}
			return output
		}
		/**
		Returns a widths of string in a given font, if the font size is set as 1 point.

		In other words, this is "proportional" value. For 1 unit of font size, the length
		of the string will be that much.

		Multiply by font size to get actual width in *points*
		Then divide by 72 to get inches or divide by (72/25.6) to get 'mm' etc.

		@public
		@function
		@param
		@returns {Type}
		*/
		var getStringUnitWidth = API.getStringUnitWidth = function(text, options) {
			return getArraySum(getCharWidthsArray.call(this, text, options))
		}

		/** 
		returns array of lines
		*/
		var splitLongWord = function(word, widths_array, firstLineMaxLen, maxLen){
			var answer = []

			// 1st, chop off the piece that can fit on the hanging line.
			var i = 0
			, l = word.length
			, workingLen = 0
			while (i !== l && workingLen + widths_array[i] < firstLineMaxLen){
				workingLen += widths_array[i]
				;i++;
			}
			// this is first line.
			answer.push(word.slice(0, i))

			// 2nd. Split the rest into maxLen pieces.
			var startOfLine = i
			workingLen = 0
			while (i !== l){
				if (workingLen + widths_array[i] > maxLen) {
					answer.push(word.slice(startOfLine, i))
					workingLen = 0
					startOfLine = i
				}
				workingLen += widths_array[i]
				;i++;
			}
			if (startOfLine !== i) {
				answer.push(word.slice(startOfLine, i))
			}

			return answer
		}

		// Note, all sizing inputs for this function must be in "font measurement units"
		// By default, for PDF, it's "point".
		var splitParagraphIntoLines = function(text, maxlen, options){
			// at this time works only on Western scripts, ones with space char
			// separating the words. Feel free to expand.

			if (!options) {
				options = {}
			}

			var spaceCharWidth = getCharWidthsArray(' ', options)[0]

			var words = text.split(' ')

			var line = []
			, lines = [line]
			, line_length = options.textIndent || 0
			, separator_length = 0
			, current_word_length = 0
			, word
			, widths_array

			var i, l, tmp
			for (i = 0, l = words.length; i < l; i++) {
				word = words[i]
				widths_array = getCharWidthsArray(word, options)
				current_word_length = getArraySum(widths_array)

				if (line_length + separator_length + current_word_length > maxlen) {
					if (current_word_length > maxlen) {
						// this happens when you have space-less long URLs for example.
						// we just chop these to size. We do NOT insert hiphens
						tmp = splitLongWord(word, widths_array, maxlen - (line_length + separator_length), maxlen)
						// first line we add to existing line object
						line.push(tmp.shift()) // it's ok to have extra space indicator there
						// last line we make into new line object
						line = [tmp.pop()]
						// lines in the middle we apped to lines object as whole lines
						while(tmp.length){
							lines.push([tmp.shift()]) // single fragment occupies whole line
						}
						current_word_length = getArraySum( widths_array.slice(word.length - line[0].length) )
					} else {
						// just put it on a new line
						line = [word]
					}

					// now we attach new line to lines
					lines.push(line)

					line_length = current_word_length
					separator_length = spaceCharWidth

				} else {
					line.push(word)

					line_length += separator_length + current_word_length
					separator_length = spaceCharWidth
				}
			}

			var output = []
			for (i = 0, l = lines.length; i < l; i++) {
				output.push( lines[i].join(' ') )
			}
			return output

		}

		/**
		Splits a given string into an array of strings. Uses 'size' value
		(in measurement units declared as default for the jsPDF instance)
		and the font's "widths" and "Kerning" tables, where availabe, to
		determine display length of a given string for a given font.

		We use character's 100% of unit size (height) as width when Width
		table or other default width is not available.

		@public
		@function
		@param text {String} Unencoded, regular JavaScript (Unicode, UTF-16 / UCS-2) string.
		@param size {Number} Nominal number, measured in units default to this instance of jsPDF.
		@param options {Object} Optional flags needed for chopper to do the right thing.
		@returns {Array} with strings chopped to size.
		*/
		API.splitTextToSize = function(text, maxlen, options) {
			'use strict'

			if (!options) {
				options = {}
			}

			var fsize = options.fontSize || this.internal.getFontSize()
			, newOptions = (function(options){
				var widths = {0:1}
				, kerning = {}

				if (!options.widths || !options.kerning) {
					var f = this.internal.getFont(options.fontName, options.fontStyle)
					, encoding = 'Unicode'
					// NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE
					// Actual JavaScript-native String's 16bit char codes used.
					// no multi-byte logic here

					if (f.metadata[encoding]) {
						return {
							widths: f.metadata[encoding].widths || widths
							, kerning: f.metadata[encoding].kerning || kerning
						}
					}
				} else {
					return 	{
						widths: options.widths
						, kerning: options.kerning
					}			
				}

				// then use default values
				return 	{
					widths: widths
					, kerning: kerning
				}
			}).call(this, options)

			// first we split on end-of-line chars
			var paragraphs 
			if (text.match(/[\n\r]/)) {
				paragraphs = text.split(/\r\n|\r|\n/g)
			} else {
				paragraphs = [text]
			}

			// now we convert size (max length of line) into "font size units"
			// at present time, the "font size unit" is always 'point'
			// 'proportional' means, "in proportion to font size"
			var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize
			// at this time, fsize is always in "points" regardless of the default measurement unit of the doc.
			// this may change in the future?
			// until then, proportional_maxlen is likely to be in 'points'

			// If first line is to be indented (shorter or longer) than maxLen 
			// we indicate that by using CSS-style "text-indent" option.
			// here it's in font units too (which is likely 'points')
			// it can be negative (which makes the first line longer than maxLen)
			newOptions.textIndent = options.textIndent ? 
				options.textIndent * 1.0 * this.internal.scaleFactor / fsize : 
				0

			var i, l
			, output = []
			for (i = 0, l = paragraphs.length; i < l; i++) {
				output = output.concat(
					splitParagraphIntoLines(
						paragraphs[i]
						, fontUnit_maxLen
						, newOptions
					)
				)
			}

			return output 
		}

		})(jsPDF.API);


		/** @preserve 
		jsPDF addImage plugin (JPEG only at this time)
		Copyright (c) 2012 https://github.com/siefkenj/
		*/

		/**
		 * Permission is hereby granted, free of charge, to any person obtaining
		 * a copy of this software and associated documentation files (the
		 * "Software"), to deal in the Software without restriction, including
		 * without limitation the rights to use, copy, modify, merge, publish,
		 * distribute, sublicense, and/or sell copies of the Software, and to
		 * permit persons to whom the Software is furnished to do so, subject to
		 * the following conditions:
		 * 
		 * The above copyright notice and this permission notice shall be
		 * included in all copies or substantial portions of the Software.
		 * 
		 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
		 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
		 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
		 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
		 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		 * ====================================================================
		 */

		;(function(jsPDFAPI) {
		'use strict'

		var namespace = 'addImage_'

		// takes a string imgData containing the raw bytes of
		// a jpeg image and returns [width, height]
		// Algorithm from: http://www.64lines.com/jpeg-width-height
		var getJpegSize = function(imgData) {
			'use strict'
			var width, height;
			// Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
			if (!imgData.charCodeAt(0) === 0xff ||
				!imgData.charCodeAt(1) === 0xd8 ||
				!imgData.charCodeAt(2) === 0xff ||
				!imgData.charCodeAt(3) === 0xe0 ||
				!imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||
				!imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||
				!imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||
				!imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||
				!imgData.charCodeAt(10) === 0x00) {
					throw new Error('getJpegSize requires a binary jpeg file')
			}
			var blockLength = imgData.charCodeAt(4)*256 + imgData.charCodeAt(5);
			var i = 4, len = imgData.length;
			while ( i < len ) {
				i += blockLength;
				if (imgData.charCodeAt(i) !== 0xff) {
					throw new Error('getJpegSize could not find the size of the image');
				}
				if (imgData.charCodeAt(i+1) === 0xc0 || //(SOF) Huffman  - Baseline DCT
				    imgData.charCodeAt(i+1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT 
				    imgData.charCodeAt(i+1) === 0xc2 || // Progressive DCT (SOF2)
				    imgData.charCodeAt(i+1) === 0xc3 || // Spatial (sequential) lossless (SOF3)
				    imgData.charCodeAt(i+1) === 0xc4 || // Differential sequential DCT (SOF5)
				    imgData.charCodeAt(i+1) === 0xc5 || // Differential progressive DCT (SOF6)
				    imgData.charCodeAt(i+1) === 0xc6 || // Differential spatial (SOF7)
				    imgData.charCodeAt(i+1) === 0xc7) {
					height = imgData.charCodeAt(i+5)*256 + imgData.charCodeAt(i+6);
					width = imgData.charCodeAt(i+7)*256 + imgData.charCodeAt(i+8);
					return [width, height];
				} else {
					i += 2;
					blockLength = imgData.charCodeAt(i)*256 + imgData.charCodeAt(i+1)
				}
			}
		}
		// Image functionality ported from pdf.js
		, putImage = function(img) {
			var objectNumber = this.internal.newObject()
			, out = this.internal.write
			, putStream = this.internal.putStream

			img['n'] = objectNumber

			out('<</Type /XObject')
			out('/Subtype /Image')
			out('/Width ' + img['w'])
			out('/Height ' + img['h'])
			if (img['cs'] === 'Indexed') {
				out('/ColorSpace [/Indexed /DeviceRGB '
						+ (img['pal'].length / 3 - 1) + ' ' + (objectNumber + 1)
						+ ' 0 R]');
			} else {
				out('/ColorSpace /' + img['cs']);
				if (img['cs'] === 'DeviceCMYK') {
					out('/Decode [1 0 1 0 1 0 1 0]');
				}
			}
			out('/BitsPerComponent ' + img['bpc']);
			if ('f' in img) {
				out('/Filter /' + img['f']);
			}
			if ('dp' in img) {
				out('/DecodeParms <<' + img['dp'] + '>>');
			}
			if ('trns' in img && img['trns'].constructor == Array) {
				var trns = '';
				for ( var i = 0; i < img['trns'].length; i++) {
					trns += (img[trns][i] + ' ' + img['trns'][i] + ' ');
					out('/Mask [' + trns + ']');
				}
			}
			if ('smask' in img) {
				out('/SMask ' + (objectNumber + 1) + ' 0 R');
			}
			out('/Length ' + img['data'].length + '>>');

			putStream(img['data']);

			out('endobj');
		}
		, putResourcesCallback = function() {
			var images = this.internal.collections[namespace + 'images']
			for ( var i in images ) {
				putImage.call(this, images[i])
			}
		}
		, putXObjectsDictCallback = function(){
			var images = this.internal.collections[namespace + 'images']
			, out = this.internal.write
			, image
			for (var i in images) {
				image = images[i]
				out(
					'/I' + image['i']
					, image['n']
					, '0'
					, 'R'
				)
			}
		}

		jsPDFAPI.addImage = function(imageData, format, x, y, w, h) {
			'use strict'
			if (typeof imageData === 'object' && imageData.nodeType === 1) {
		        var canvas = document.createElement('canvas');
		        canvas.width = imageData.clientWidth;
			    canvas.height = imageData.clientHeight;

		        var ctx = canvas.getContext('2d');
		        if (!ctx) {
		            throw ('addImage requires canvas to be supported by browser.');
		        }
		        ctx.drawImage(imageData, 0, 0, canvas.width, canvas.height);
		        imageData = canvas.toDataURL('image/jpeg');
			    format = "JPEG";
			}
			if (format.toUpperCase() !== 'JPEG') {
				throw new Error('addImage currently only supports format \'JPEG\', not \''+format+'\'');
			}

			var imageIndex
			, images = this.internal.collections[namespace + 'images']
			, coord = this.internal.getCoordinateString
			, vcoord = this.internal.getVerticalCoordinateString;

			// Detect if the imageData is raw binary or Data URL
			if (imageData.substring(0, 23) === 'data:image/jpeg;base64,') {
				imageData = atob(imageData.replace('data:image/jpeg;base64,', ''));
			}

			if (images){
				// this is NOT the first time this method is ran on this instance of jsPDF object.
				imageIndex = Object.keys ? 
				Object.keys(images).length :
				(function(o){
					var i = 0
					for (var e in o){if(o.hasOwnProperty(e)){ i++ }}
					return i
				})(images)
			} else {
				// this is the first time this method is ran on this instance of jsPDF object.
				imageIndex = 0
				this.internal.collections[namespace + 'images'] = images = {}
				this.internal.events.subscribe('putResources', putResourcesCallback)
				this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback)
			}

			var dims = getJpegSize(imageData);
			var info = {
				w : dims[0],
				h : dims[1],
				cs : 'DeviceRGB',
				bpc : 8,
				f : 'DCTDecode',
				i : imageIndex,
				data : imageData
				// n: objectNumber will be added by putImage code

			};
			images[imageIndex] = info
			if (!w && !h) {
				w = -96;
				h = -96;
			}
			if (w < 0) {
				w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
			}
			if (h < 0) {
				h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
			}
			if (w === 0) {
				w = h * info['w'] / info['h'];
			}
			if (h === 0) {
				h = w * info['h'] / info['w'];
			}

			this.internal.write(
				'q'
				, coord(w)
				, '0 0'
				, coord(h) // TODO: check if this should be shifted by vcoord
				, coord(x)
				, vcoord(y + h)
				, 'cm /I'+info['i']
				, 'Do Q'
			)

			return this 
		}
		})(jsPDF.API)
	</script>

	<script>
		/*
		  html2canvas 0.4.1 <http://html2canvas.hertzen.com>
		  Copyright (c) 2013 Niklas von Hertzen

		  Released under MIT License
		*/

		(function(window, document, undefined){

		"use strict";

		var _html2canvas = {},
		previousElement,
		computedCSS,
		html2canvas;

		_html2canvas.Util = {};

		_html2canvas.Util.log = function(a) {
		  if (_html2canvas.logging && window.console && window.console.log) {
		    window.console.log(a);
		  }
		};

		_html2canvas.Util.trimText = (function(isNative){
		  return function(input) {
		    return isNative ? isNative.apply(input) : ((input || '') + '').replace( /^\s+|\s+$/g , '' );
		  };
		})(String.prototype.trim);

		_html2canvas.Util.asFloat = function(v) {
		  return parseFloat(v);
		};

		(function() {
		  // TODO: support all possible length values
		  var TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
		  var TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
		  _html2canvas.Util.parseTextShadows = function (value) {
		    if (!value || value === 'none') {
		      return [];
		    }

		    // find multiple shadow declarations
		    var shadows = value.match(TEXT_SHADOW_PROPERTY),
		      results = [];
		    for (var i = 0; shadows && (i < shadows.length); i++) {
		      var s = shadows[i].match(TEXT_SHADOW_VALUES);
		      results.push({
		        color: s[0],
		        offsetX: s[1] ? s[1].replace('px', '') : 0,
		        offsetY: s[2] ? s[2].replace('px', '') : 0,
		        blur: s[3] ? s[3].replace('px', '') : 0
		      });
		    }
		    return results;
		  };
		})();


		_html2canvas.Util.parseBackgroundImage = function (value) {
		    var whitespace = ' \r\n\t',
		        method, definition, prefix, prefix_i, block, results = [],
		        c, mode = 0, numParen = 0, quote, args;

		    var appendResult = function(){
		        if(method) {
		            if(definition.substr( 0, 1 ) === '"') {
		                definition = definition.substr( 1, definition.length - 2 );
		            }
		            if(definition) {
		                args.push(definition);
		            }
		            if(method.substr( 0, 1 ) === '-' &&
		                    (prefix_i = method.indexOf( '-', 1 ) + 1) > 0) {
		                prefix = method.substr( 0, prefix_i);
		                method = method.substr( prefix_i );
		            }
		            results.push({
		                prefix: prefix,
		                method: method.toLowerCase(),
		                value: block,
		                args: args
		            });
		        }
		        args = []; //for some odd reason, setting .length = 0 didn't work in safari
		        method =
		            prefix =
		            definition =
		            block = '';
		    };

		    appendResult();
		    for(var i = 0, ii = value.length; i<ii; i++) {
		        c = value[i];
		        if(mode === 0 && whitespace.indexOf( c ) > -1){
		            continue;
		        }
		        switch(c) {
		            case '"':
		                if(!quote) {
		                    quote = c;
		                }
		                else if(quote === c) {
		                    quote = null;
		                }
		                break;

		            case '(':
		                if(quote) { break; }
		                else if(mode === 0) {
		                    mode = 1;
		                    block += c;
		                    continue;
		                } else {
		                    numParen++;
		                }
		                break;

		            case ')':
		                if(quote) { break; }
		                else if(mode === 1) {
		                    if(numParen === 0) {
		                        mode = 0;
		                        block += c;
		                        appendResult();
		                        continue;
		                    } else {
		                        numParen--;
		                    }
		                }
		                break;

		            case ',':
		                if(quote) { break; }
		                else if(mode === 0) {
		                    appendResult();
		                    continue;
		                }
		                else if (mode === 1) {
		                    if(numParen === 0 && !method.match(/^url$/i)) {
		                        args.push(definition);
		                        definition = '';
		                        block += c;
		                        continue;
		                    }
		                }
		                break;
		        }

		        block += c;
		        if(mode === 0) { method += c; }
		        else { definition += c; }
		    }
		    appendResult();

		    return results;
		};

		_html2canvas.Util.Bounds = function (element) {
		  var clientRect, bounds = {};

		  if (element.getBoundingClientRect){
		    clientRect = element.getBoundingClientRect();

		    // TODO add scroll position to bounds, so no scrolling of window necessary
		    bounds.top = clientRect.top;
		    bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);
		    bounds.left = clientRect.left;

		    bounds.width = element.offsetWidth;
		    bounds.height = element.offsetHeight;
		  }

		  return bounds;
		};

		// TODO ideally, we'd want everything to go through this function instead of Util.Bounds,
		// but would require further work to calculate the correct positions for elements with offsetParents
		_html2canvas.Util.OffsetBounds = function (element) {
		  var parent = element.offsetParent ? _html2canvas.Util.OffsetBounds(element.offsetParent) : {top: 0, left: 0};

		  return {
		    top: element.offsetTop + parent.top,
		    bottom: element.offsetTop + element.offsetHeight + parent.top,
		    left: element.offsetLeft + parent.left,
		    width: element.offsetWidth,
		    height: element.offsetHeight
		  };
		};

		function toPX(element, attribute, value ) {
		    var rsLeft = element.runtimeStyle && element.runtimeStyle[attribute],
		        left,
		        style = element.style;

		    // Check if we are not dealing with pixels, (Opera has issues with this)
		    // Ported from jQuery css.js
		    // From the awesome hack by Dean Edwards
		    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		    // If we're not dealing with a regular pixel number
		    // but a number that has a weird ending, we need to convert it to pixels

		    if ( !/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test( value ) && /^-?\d/.test(value) ) {
		        // Remember the original values
		        left = style.left;

		        // Put in the new values to get a computed value out
		        if (rsLeft) {
		            element.runtimeStyle.left = element.currentStyle.left;
		        }
		        style.left = attribute === "fontSize" ? "1em" : (value || 0);
		        value = style.pixelLeft + "px";

		        // Revert the changed values
		        style.left = left;
		        if (rsLeft) {
		            element.runtimeStyle.left = rsLeft;
		        }
		    }

		    if (!/^(thin|medium|thick)$/i.test(value)) {
		        return Math.round(parseFloat(value)) + "px";
		    }

		    return value;
		}

		function asInt(val) {
		    return parseInt(val, 10);
		}

		function parseBackgroundSizePosition(value, element, attribute, index) {
		    value = (value || '').split(',');
		    value = value[index || 0] || value[0] || 'auto';
		    value = _html2canvas.Util.trimText(value).split(' ');

		    if(attribute === 'backgroundSize' && (!value[0] || value[0].match(/cover|contain|auto/))) {
		        //these values will be handled in the parent function
		    } else {
		        value[0] = (value[0].indexOf( "%" ) === -1) ? toPX(element, attribute + "X", value[0]) : value[0];
		        if(value[1] === undefined) {
		            if(attribute === 'backgroundSize') {
		                value[1] = 'auto';
		                return value;
		            } else {
		                // IE 9 doesn't return double digit always
		                value[1] = value[0];
		            }
		        }
		        value[1] = (value[1].indexOf("%") === -1) ? toPX(element, attribute + "Y", value[1]) : value[1];
		    }
		    return value;
		}

		_html2canvas.Util.getCSS = function (element, attribute, index) {
		    if (previousElement !== element) {
		      computedCSS = document.defaultView.getComputedStyle(element, null);
		    }

		    var value = computedCSS[attribute];

		    if (/^background(Size|Position)$/.test(attribute)) {
		        return parseBackgroundSizePosition(value, element, attribute, index);
		    } else if (/border(Top|Bottom)(Left|Right)Radius/.test(attribute)) {
		      var arr = value.split(" ");
		      if (arr.length <= 1) {
		          arr[1] = arr[0];
		      }
		      return arr.map(asInt);
		    }

		  return value;
		};

		_html2canvas.Util.resizeBounds = function( current_width, current_height, target_width, target_height, stretch_mode ){
		  var target_ratio = target_width / target_height,
		    current_ratio = current_width / current_height,
		    output_width, output_height;

		  if(!stretch_mode || stretch_mode === 'auto') {
		    output_width = target_width;
		    output_height = target_height;
		  } else if(target_ratio < current_ratio ^ stretch_mode === 'contain') {
		    output_height = target_height;
		    output_width = target_height * current_ratio;
		  } else {
		    output_width = target_width;
		    output_height = target_width / current_ratio;
		  }

		  return {
		    width: output_width,
		    height: output_height
		  };
		};

		function backgroundBoundsFactory( prop, el, bounds, image, imageIndex, backgroundSize ) {
		    var bgposition =  _html2canvas.Util.getCSS( el, prop, imageIndex ) ,
		    topPos,
		    left,
		    percentage,
		    val;

		    if (bgposition.length === 1){
		      val = bgposition[0];

		      bgposition = [];

		      bgposition[0] = val;
		      bgposition[1] = val;
		    }

		    if (bgposition[0].toString().indexOf("%") !== -1){
		      percentage = (parseFloat(bgposition[0])/100);
		      left = bounds.width * percentage;
		      if(prop !== 'backgroundSize') {
		        left -= (backgroundSize || image).width*percentage;
		      }
		    } else {
		      if(prop === 'backgroundSize') {
		        if(bgposition[0] === 'auto') {
		          left = image.width;
		        } else {
		          if (/contain|cover/.test(bgposition[0])) {
		            var resized = _html2canvas.Util.resizeBounds(image.width, image.height, bounds.width, bounds.height, bgposition[0]);
		            left = resized.width;
		            topPos = resized.height;
		          } else {
		            left = parseInt(bgposition[0], 10);
		          }
		        }
		      } else {
		        left = parseInt( bgposition[0], 10);
		      }
		    }


		    if(bgposition[1] === 'auto') {
		      topPos = left / image.width * image.height;
		    } else if (bgposition[1].toString().indexOf("%") !== -1){
		      percentage = (parseFloat(bgposition[1])/100);
		      topPos =  bounds.height * percentage;
		      if(prop !== 'backgroundSize') {
		        topPos -= (backgroundSize || image).height * percentage;
		      }

		    } else {
		      topPos = parseInt(bgposition[1],10);
		    }

		    return [left, topPos];
		}

		_html2canvas.Util.BackgroundPosition = function( el, bounds, image, imageIndex, backgroundSize ) {
		    var result = backgroundBoundsFactory( 'backgroundPosition', el, bounds, image, imageIndex, backgroundSize );
		    return { left: result[0], top: result[1] };
		};

		_html2canvas.Util.BackgroundSize = function( el, bounds, image, imageIndex ) {
		    var result = backgroundBoundsFactory( 'backgroundSize', el, bounds, image, imageIndex );
		    return { width: result[0], height: result[1] };
		};

		_html2canvas.Util.Extend = function (options, defaults) {
		  for (var key in options) {
		    if (options.hasOwnProperty(key)) {
		      defaults[key] = options[key];
		    }
		  }
		  return defaults;
		};


		/*
		 * Derived from jQuery.contents()
		 * Copyright 2010, John Resig
		 * Dual licensed under the MIT or GPL Version 2 licenses.
		 * http://jquery.org/license
		 */
		_html2canvas.Util.Children = function( elem ) {
		  var children;
		  try {
		    children = (elem.nodeName && elem.nodeName.toUpperCase() === "IFRAME") ? elem.contentDocument || elem.contentWindow.document : (function(array) {
		      var ret = [];
		      if (array !== null) {
		        (function(first, second ) {
		          var i = first.length,
		          j = 0;

		          if (typeof second.length === "number") {
		            for (var l = second.length; j < l; j++) {
		              first[i++] = second[j];
		            }
		          } else {
		            while (second[j] !== undefined) {
		              first[i++] = second[j++];
		            }
		          }

		          first.length = i;

		          return first;
		        })(ret, array);
		      }
		      return ret;
		    })(elem.childNodes);

		  } catch (ex) {
		    _html2canvas.Util.log("html2canvas.Util.Children failed with exception: " + ex.message);
		    children = [];
		  }
		  return children;
		};

		_html2canvas.Util.isTransparent = function(backgroundColor) {
		  return (backgroundColor === "transparent" || backgroundColor === "rgba(0, 0, 0, 0)");
		};
		_html2canvas.Util.Font = (function () {

		  var fontData = {};

		  return function(font, fontSize, doc) {
		    if (fontData[font + "-" + fontSize] !== undefined) {
		      return fontData[font + "-" + fontSize];
		    }

		    var container = doc.createElement('div'),
		    img = doc.createElement('img'),
		    span = doc.createElement('span'),
		    sampleText = 'Hidden Text',
		    baseline,
		    middle,
		    metricsObj;

		    container.style.visibility = "hidden";
		    container.style.fontFamily = font;
		    container.style.fontSize = fontSize;
		    container.style.margin = 0;
		    container.style.padding = 0;

		    doc.body.appendChild(container);

		    // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)
		    img.src = "data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=";
		    img.width = 1;
		    img.height = 1;

		    img.style.margin = 0;
		    img.style.padding = 0;
		    img.style.verticalAlign = "baseline";

		    span.style.fontFamily = font;
		    span.style.fontSize = fontSize;
		    span.style.margin = 0;
		    span.style.padding = 0;

		    span.appendChild(doc.createTextNode(sampleText));
		    container.appendChild(span);
		    container.appendChild(img);
		    baseline = (img.offsetTop - span.offsetTop) + 1;

		    container.removeChild(span);
		    container.appendChild(doc.createTextNode(sampleText));

		    container.style.lineHeight = "normal";
		    img.style.verticalAlign = "super";

		    middle = (img.offsetTop-container.offsetTop) + 1;
		    metricsObj = {
		      baseline: baseline,
		      lineWidth: 1,
		      middle: middle
		    };

		    fontData[font + "-" + fontSize] = metricsObj;

		    doc.body.removeChild(container);

		    return metricsObj;
		  };
		})();

		(function(){
		  var Util = _html2canvas.Util,
		    Generate = {};

		  _html2canvas.Generate = Generate;

		  var reGradients = [
		  /^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
		  /^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
		  /^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)\-]+)\)$/,
		  /^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,
		  /^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/,
		  /^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z\-]*)([\w\d\.\s,%\(\)]+)\)$/,
		  /^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/
		  ];

		  /*
		 * TODO: Add IE10 vendor prefix (-ms) support
		 * TODO: Add W3C gradient (linear-gradient) support
		 * TODO: Add old Webkit -webkit-gradient(radial, ...) support
		 * TODO: Maybe some RegExp optimizations are possible ;o)
		 */
		  Generate.parseGradient = function(css, bounds) {
		    var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3, tl,tr,br,bl;

		    for(i = 0; i < len; i+=1){
		      m1 = css.match(reGradients[i]);
		      if(m1) {
		        break;
		      }
		    }

		    if(m1) {
		      switch(m1[1]) {
		        case '-webkit-linear-gradient':
		        case '-o-linear-gradient':

		          gradient = {
		            type: 'linear',
		            x0: null,
		            y0: null,
		            x1: null,
		            y1: null,
		            colorStops: []
		          };

		          // get coordinates
		          m2 = m1[2].match(/\w+/g);
		          if(m2){
		            m2Len = m2.length;
		            for(i = 0; i < m2Len; i+=1){
		              switch(m2[i]) {
		                case 'top':
		                  gradient.y0 = 0;
		                  gradient.y1 = bounds.height;
		                  break;

		                case 'right':
		                  gradient.x0 = bounds.width;
		                  gradient.x1 = 0;
		                  break;

		                case 'bottom':
		                  gradient.y0 = bounds.height;
		                  gradient.y1 = 0;
		                  break;

		                case 'left':
		                  gradient.x0 = 0;
		                  gradient.x1 = bounds.width;
		                  break;
		              }
		            }
		          }
		          if(gradient.x0 === null && gradient.x1 === null){ // center
		            gradient.x0 = gradient.x1 = bounds.width / 2;
		          }
		          if(gradient.y0 === null && gradient.y1 === null){ // center
		            gradient.y0 = gradient.y1 = bounds.height / 2;
		          }

		          // get colors and stops
		          m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
		          if(m2){
		            m2Len = m2.length;
		            step = 1 / Math.max(m2Len - 1, 1);
		            for(i = 0; i < m2Len; i+=1){
		              m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
		              if(m3[2]){
		                stop = parseFloat(m3[2]);
		                if(m3[3] === '%'){
		                  stop /= 100;
		                } else { // px - stupid opera
		                  stop /= bounds.width;
		                }
		              } else {
		                stop = i * step;
		              }
		              gradient.colorStops.push({
		                color: m3[1],
		                stop: stop
		              });
		            }
		          }
		          break;

		        case '-webkit-gradient':

		          gradient = {
		            type: m1[2] === 'radial' ? 'circle' : m1[2], // TODO: Add radial gradient support for older mozilla definitions
		            x0: 0,
		            y0: 0,
		            x1: 0,
		            y1: 0,
		            colorStops: []
		          };

		          // get coordinates
		          m2 = m1[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/);
		          if(m2){
		            gradient.x0 = (m2[1] * bounds.width) / 100;
		            gradient.y0 = (m2[2] * bounds.height) / 100;
		            gradient.x1 = (m2[3] * bounds.width) / 100;
		            gradient.y1 = (m2[4] * bounds.height) / 100;
		          }

		          // get colors and stops
		          m2 = m1[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g);
		          if(m2){
		            m2Len = m2.length;
		            for(i = 0; i < m2Len; i+=1){
		              m3 = m2[i].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/);
		              stop = parseFloat(m3[2]);
		              if(m3[1] === 'from') {
		                stop = 0.0;
		              }
		              if(m3[1] === 'to') {
		                stop = 1.0;
		              }
		              gradient.colorStops.push({
		                color: m3[3],
		                stop: stop
		              });
		            }
		          }
		          break;

		        case '-moz-linear-gradient':

		          gradient = {
		            type: 'linear',
		            x0: 0,
		            y0: 0,
		            x1: 0,
		            y1: 0,
		            colorStops: []
		          };

		          // get coordinates
		          m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);

		          // m2[1] == 0%   -> left
		          // m2[1] == 50%  -> center
		          // m2[1] == 100% -> right

		          // m2[2] == 0%   -> top
		          // m2[2] == 50%  -> center
		          // m2[2] == 100% -> bottom

		          if(m2){
		            gradient.x0 = (m2[1] * bounds.width) / 100;
		            gradient.y0 = (m2[2] * bounds.height) / 100;
		            gradient.x1 = bounds.width - gradient.x0;
		            gradient.y1 = bounds.height - gradient.y0;
		          }

		          // get colors and stops
		          m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g);
		          if(m2){
		            m2Len = m2.length;
		            step = 1 / Math.max(m2Len - 1, 1);
		            for(i = 0; i < m2Len; i+=1){
		              m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/);
		              if(m3[2]){
		                stop = parseFloat(m3[2]);
		                if(m3[3]){ // percentage
		                  stop /= 100;
		                }
		              } else {
		                stop = i * step;
		              }
		              gradient.colorStops.push({
		                color: m3[1],
		                stop: stop
		              });
		            }
		          }
		          break;

		        case '-webkit-radial-gradient':
		        case '-moz-radial-gradient':
		        case '-o-radial-gradient':

		          gradient = {
		            type: 'circle',
		            x0: 0,
		            y0: 0,
		            x1: bounds.width,
		            y1: bounds.height,
		            cx: 0,
		            cy: 0,
		            rx: 0,
		            ry: 0,
		            colorStops: []
		          };

		          // center
		          m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);
		          if(m2){
		            gradient.cx = (m2[1] * bounds.width) / 100;
		            gradient.cy = (m2[2] * bounds.height) / 100;
		          }

		          // size
		          m2 = m1[3].match(/\w+/);
		          m3 = m1[4].match(/[a-z\-]*/);
		          if(m2 && m3){
		            switch(m3[0]){
		              case 'farthest-corner':
		              case 'cover': // is equivalent to farthest-corner
		              case '': // mozilla removes "cover" from definition :(
		                tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
		                tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
		                br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
		                bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
		                gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);
		                break;
		              case 'closest-corner':
		                tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
		                tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
		                br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
		                bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
		                gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);
		                break;
		              case 'farthest-side':
		                if(m2[0] === 'circle'){
		                  gradient.rx = gradient.ry = Math.max(
		                    gradient.cx,
		                    gradient.cy,
		                    gradient.x1 - gradient.cx,
		                    gradient.y1 - gradient.cy
		                    );
		                } else { // ellipse

		                  gradient.type = m2[0];

		                  gradient.rx = Math.max(
		                    gradient.cx,
		                    gradient.x1 - gradient.cx
		                    );
		                  gradient.ry = Math.max(
		                    gradient.cy,
		                    gradient.y1 - gradient.cy
		                    );
		                }
		                break;
		              case 'closest-side':
		              case 'contain': // is equivalent to closest-side
		                if(m2[0] === 'circle'){
		                  gradient.rx = gradient.ry = Math.min(
		                    gradient.cx,
		                    gradient.cy,
		                    gradient.x1 - gradient.cx,
		                    gradient.y1 - gradient.cy
		                    );
		                } else { // ellipse

		                  gradient.type = m2[0];

		                  gradient.rx = Math.min(
		                    gradient.cx,
		                    gradient.x1 - gradient.cx
		                    );
		                  gradient.ry = Math.min(
		                    gradient.cy,
		                    gradient.y1 - gradient.cy
		                    );
		                }
		                break;

		            // TODO: add support for "30px 40px" sizes (webkit only)
		            }
		          }

		          // color stops
		          m2 = m1[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
		          if(m2){
		            m2Len = m2.length;
		            step = 1 / Math.max(m2Len - 1, 1);
		            for(i = 0; i < m2Len; i+=1){
		              m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
		              if(m3[2]){
		                stop = parseFloat(m3[2]);
		                if(m3[3] === '%'){
		                  stop /= 100;
		                } else { // px - stupid opera
		                  stop /= bounds.width;
		                }
		              } else {
		                stop = i * step;
		              }
		              gradient.colorStops.push({
		                color: m3[1],
		                stop: stop
		              });
		            }
		          }
		          break;
		      }
		    }

		    return gradient;
		  };

		  function addScrollStops(grad) {
		    return function(colorStop) {
		      try {
		        grad.addColorStop(colorStop.stop, colorStop.color);
		      }
		      catch(e) {
		        Util.log(['failed to add color stop: ', e, '; tried to add: ', colorStop]);
		      }
		    };
		  }

		  Generate.Gradient = function(src, bounds) {
		    if(bounds.width === 0 || bounds.height === 0) {
		      return;
		    }

		    var canvas = document.createElement('canvas'),
		    ctx = canvas.getContext('2d'),
		    gradient, grad;

		    canvas.width = bounds.width;
		    canvas.height = bounds.height;

		    // TODO: add support for multi defined background gradients
		    gradient = _html2canvas.Generate.parseGradient(src, bounds);

		    if(gradient) {
		      switch(gradient.type) {
		        case 'linear':
		          grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);
		          gradient.colorStops.forEach(addScrollStops(grad));
		          ctx.fillStyle = grad;
		          ctx.fillRect(0, 0, bounds.width, bounds.height);
		          break;

		        case 'circle':
		          grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);
		          gradient.colorStops.forEach(addScrollStops(grad));
		          ctx.fillStyle = grad;
		          ctx.fillRect(0, 0, bounds.width, bounds.height);
		          break;

		        case 'ellipse':
		          var canvasRadial = document.createElement('canvas'),
		            ctxRadial = canvasRadial.getContext('2d'),
		            ri = Math.max(gradient.rx, gradient.ry),
		            di = ri * 2;

		          canvasRadial.width = canvasRadial.height = di;

		          grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);
		          gradient.colorStops.forEach(addScrollStops(grad));

		          ctxRadial.fillStyle = grad;
		          ctxRadial.fillRect(0, 0, di, di);

		          ctx.fillStyle = gradient.colorStops[gradient.colorStops.length - 1].color;
		          ctx.fillRect(0, 0, canvas.width, canvas.height);
		          ctx.drawImage(canvasRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);
		          break;
		      }
		    }

		    return canvas;
		  };

		  Generate.ListAlpha = function(number) {
		    var tmp = "",
		    modulus;

		    do {
		      modulus = number % 26;
		      tmp = String.fromCharCode((modulus) + 64) + tmp;
		      number = number / 26;
		    }while((number*26) > 26);

		    return tmp;
		  };

		  Generate.ListRoman = function(number) {
		    var romanArray = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"],
		    decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
		    roman = "",
		    v,
		    len = romanArray.length;

		    if (number <= 0 || number >= 4000) {
		      return number;
		    }

		    for (v=0; v < len; v+=1) {
		      while (number >= decimal[v]) {
		        number -= decimal[v];
		        roman += romanArray[v];
		      }
		    }

		    return roman;
		  };
		})();
		function h2cRenderContext(width, height) {
		  var storage = [];
		  return {
		    storage: storage,
		    width: width,
		    height: height,
		    clip: function() {
		      storage.push({
		        type: "function",
		        name: "clip",
		        'arguments': arguments
		      });
		    },
		    translate: function() {
		      storage.push({
		        type: "function",
		        name: "translate",
		        'arguments': arguments
		      });
		    },
		    fill: function() {
		      storage.push({
		        type: "function",
		        name: "fill",
		        'arguments': arguments
		      });
		    },
		    save: function() {
		      storage.push({
		        type: "function",
		        name: "save",
		        'arguments': arguments
		      });
		    },
		    restore: function() {
		      storage.push({
		        type: "function",
		        name: "restore",
		        'arguments': arguments
		      });
		    },
		    fillRect: function () {
		      storage.push({
		        type: "function",
		        name: "fillRect",
		        'arguments': arguments
		      });
		    },
		    createPattern: function() {
		      storage.push({
		        type: "function",
		        name: "createPattern",
		        'arguments': arguments
		      });
		    },
		    drawShape: function() {

		      var shape = [];

		      storage.push({
		        type: "function",
		        name: "drawShape",
		        'arguments': shape
		      });

		      return {
		        moveTo: function() {
		          shape.push({
		            name: "moveTo",
		            'arguments': arguments
		          });
		        },
		        lineTo: function() {
		          shape.push({
		            name: "lineTo",
		            'arguments': arguments
		          });
		        },
		        arcTo: function() {
		          shape.push({
		            name: "arcTo",
		            'arguments': arguments
		          });
		        },
		        bezierCurveTo: function() {
		          shape.push({
		            name: "bezierCurveTo",
		            'arguments': arguments
		          });
		        },
		        quadraticCurveTo: function() {
		          shape.push({
		            name: "quadraticCurveTo",
		            'arguments': arguments
		          });
		        }
		      };

		    },
		    drawImage: function () {
		      storage.push({
		        type: "function",
		        name: "drawImage",
		        'arguments': arguments
		      });
		    },
		    fillText: function () {
		      storage.push({
		        type: "function",
		        name: "fillText",
		        'arguments': arguments
		      });
		    },
		    setVariable: function (variable, value) {
		      storage.push({
		        type: "variable",
		        name: variable,
		        'arguments': value
		      });
		      return value;
		    }
		  };
		}
		_html2canvas.Parse = function (images, options) {
		  window.scroll(0,0);

		  var element = (( options.elements === undefined ) ? document.body : options.elements[0]), // select body by default
		  numDraws = 0,
		  doc = element.ownerDocument,
		  Util = _html2canvas.Util,
		  support = Util.Support(options, doc),
		  ignoreElementsRegExp = new RegExp("(" + options.ignoreElements + ")"),
		  body = doc.body,
		  getCSS = Util.getCSS,
		  pseudoHide = "___html2canvas___pseudoelement",
		  hidePseudoElements = doc.createElement('style');

		  hidePseudoElements.innerHTML = '.' + pseudoHide + '-before:before { content: "" !important; display: none !important; }' +
		  '.' + pseudoHide + '-after:after { content: "" !important; display: none !important; }';

		  body.appendChild(hidePseudoElements);

		  images = images || {};

		  function documentWidth () {
		    return Math.max(
		      Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
		      Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
		      Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
		      );
		  }

		  function documentHeight () {
		    return Math.max(
		      Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
		      Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
		      Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
		      );
		  }

		  function getCSSInt(element, attribute) {
		    var val = parseInt(getCSS(element, attribute), 10);
		    return (isNaN(val)) ? 0 : val; // borders in old IE are throwing 'medium' for demo.html
		  }

		  function renderRect (ctx, x, y, w, h, bgcolor) {
		    if (bgcolor !== "transparent"){
		      ctx.setVariable("fillStyle", bgcolor);
		      ctx.fillRect(x, y, w, h);
		      numDraws+=1;
		    }
		  }

		  function capitalize(m, p1, p2) {
		    if (m.length > 0) {
		      return p1 + p2.toUpperCase();
		    }
		  }

		  function textTransform (text, transform) {
		    switch(transform){
		      case "lowercase":
		        return text.toLowerCase();
		      case "capitalize":
		        return text.replace( /(^|\s|:|-|\(|\))([a-z])/g, capitalize);
		      case "uppercase":
		        return text.toUpperCase();
		      default:
		        return text;
		    }
		  }

		  function noLetterSpacing(letter_spacing) {
		    return (/^(normal|none|0px)$/.test(letter_spacing));
		  }

		  function drawText(currentText, x, y, ctx){
		    if (currentText !== null && Util.trimText(currentText).length > 0) {
		      ctx.fillText(currentText, x, y);
		      numDraws+=1;
		    }
		  }

		  function setTextVariables(ctx, el, text_decoration, color) {
		    var align = false,
		    bold = getCSS(el, "fontWeight"),
		    family = getCSS(el, "fontFamily"),
		    size = getCSS(el, "fontSize"),
		    shadows = Util.parseTextShadows(getCSS(el, "textShadow"));

		    switch(parseInt(bold, 10)){
		      case 401:
		        bold = "bold";
		        break;
		      case 400:
		        bold = "normal";
		        break;
		    }

		    ctx.setVariable("fillStyle", color);
		    ctx.setVariable("font", [getCSS(el, "fontStyle"), getCSS(el, "fontVariant"), bold, size, family].join(" "));
		    ctx.setVariable("textAlign", (align) ? "right" : "left");

		    if (shadows.length) {
		      // TODO: support multiple text shadows
		      // apply the first text shadow
		      ctx.setVariable("shadowColor", shadows[0].color);
		      ctx.setVariable("shadowOffsetX", shadows[0].offsetX);
		      ctx.setVariable("shadowOffsetY", shadows[0].offsetY);
		      ctx.setVariable("shadowBlur", shadows[0].blur);
		    }

		    if (text_decoration !== "none"){
		      return Util.Font(family, size, doc);
		    }
		  }

		  function renderTextDecoration(ctx, text_decoration, bounds, metrics, color) {
		    switch(text_decoration) {
		      case "underline":
		        // Draws a line at the baseline of the font
		        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
		        renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);
		        break;
		      case "overline":
		        renderRect(ctx, bounds.left, Math.round(bounds.top), bounds.width, 1, color);
		        break;
		      case "line-through":
		        // TODO try and find exact position for line-through
		        renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);
		        break;
		    }
		  }

		  function getTextBounds(state, text, textDecoration, isLast, transform) {
		    var bounds;
		    if (support.rangeBounds && !transform) {
		      if (textDecoration !== "none" || Util.trimText(text).length !== 0) {
		        bounds = textRangeBounds(text, state.node, state.textOffset);
		      }
		      state.textOffset += text.length;
		    } else if (state.node && typeof state.node.nodeValue === "string" ){
		      var newTextNode = (isLast) ? state.node.splitText(text.length) : null;
		      bounds = textWrapperBounds(state.node, transform);
		      state.node = newTextNode;
		    }
		    return bounds;
		  }

		  function textRangeBounds(text, textNode, textOffset) {
		    var range = doc.createRange();
		    range.setStart(textNode, textOffset);
		    range.setEnd(textNode, textOffset + text.length);
		    return range.getBoundingClientRect();
		  }

		  function textWrapperBounds(oldTextNode, transform) {
		    var parent = oldTextNode.parentNode,
		    wrapElement = doc.createElement('wrapper'),
		    backupText = oldTextNode.cloneNode(true);

		    wrapElement.appendChild(oldTextNode.cloneNode(true));
		    parent.replaceChild(wrapElement, oldTextNode);

		    var bounds = transform ? Util.OffsetBounds(wrapElement) : Util.Bounds(wrapElement);
		    parent.replaceChild(backupText, wrapElement);
		    return bounds;
		  }

		  function renderText(el, textNode, stack) {
		    var ctx = stack.ctx,
		    color = getCSS(el, "color"),
		    textDecoration = getCSS(el, "textDecoration"),
		    textAlign = getCSS(el, "textAlign"),
		    metrics,
		    textList,
		    state = {
		      node: textNode,
		      textOffset: 0
		    };

		    if (Util.trimText(textNode.nodeValue).length > 0) {
		      textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, "textTransform"));
		      textAlign = textAlign.replace(["-webkit-auto"],["auto"]);

		      textList = (!options.letterRendering && /^(left|right|justify|auto)$/.test(textAlign) && noLetterSpacing(getCSS(el, "letterSpacing"))) ?
		      textNode.nodeValue.split(/(\b| )/)
		      : textNode.nodeValue.split("");

		      metrics = setTextVariables(ctx, el, textDecoration, color);

		      if (options.chinese) {
		        textList.forEach(function(word, index) {
		          if (/.*[\u4E00-\u9FA5].*$/.test(word)) {
		            word = word.split("");
		            word.unshift(index, 1);
		            textList.splice.apply(textList, word);
		          }
		        });
		      }

		      textList.forEach(function(text, index) {
		        var bounds = getTextBounds(state, text, textDecoration, (index < textList.length - 1), stack.transform.matrix);
		        if (bounds) {
		          drawText(text, bounds.left, bounds.bottom, ctx);
		          renderTextDecoration(ctx, textDecoration, bounds, metrics, color);
		        }
		      });
		    }
		  }

		  function listPosition (element, val) {
		    var boundElement = doc.createElement( "boundelement" ),
		    originalType,
		    bounds;

		    boundElement.style.display = "inline";

		    originalType = element.style.listStyleType;
		    element.style.listStyleType = "none";

		    boundElement.appendChild(doc.createTextNode(val));

		    element.insertBefore(boundElement, element.firstChild);

		    bounds = Util.Bounds(boundElement);
		    element.removeChild(boundElement);
		    element.style.listStyleType = originalType;
		    return bounds;
		  }

		  function elementIndex(el) {
		    var i = -1,
		    count = 1,
		    childs = el.parentNode.childNodes;

		    if (el.parentNode) {
		      while(childs[++i] !== el) {
		        if (childs[i].nodeType === 1) {
		          count++;
		        }
		      }
		      return count;
		    } else {
		      return -1;
		    }
		  }

		  function listItemText(element, type) {
		    var currentIndex = elementIndex(element), text;
		    switch(type){
		      case "decimal":
		        text = currentIndex;
		        break;
		      case "decimal-leading-zero":
		        text = (currentIndex.toString().length === 1) ? currentIndex = "0" + currentIndex.toString() : currentIndex.toString();
		        break;
		      case "upper-roman":
		        text = _html2canvas.Generate.ListRoman( currentIndex );
		        break;
		      case "lower-roman":
		        text = _html2canvas.Generate.ListRoman( currentIndex ).toLowerCase();
		        break;
		      case "lower-alpha":
		        text = _html2canvas.Generate.ListAlpha( currentIndex ).toLowerCase();
		        break;
		      case "upper-alpha":
		        text = _html2canvas.Generate.ListAlpha( currentIndex );
		        break;
		    }

		    return text + ". ";
		  }

		  function renderListItem(element, stack, elBounds) {
		    var x,
		    text,
		    ctx = stack.ctx,
		    type = getCSS(element, "listStyleType"),
		    listBounds;

		    if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {
		      text = listItemText(element, type);
		      listBounds = listPosition(element, text);
		      setTextVariables(ctx, element, "none", getCSS(element, "color"));

		      if (getCSS(element, "listStylePosition") === "inside") {
		        ctx.setVariable("textAlign", "left");
		        x = elBounds.left;
		      } else {
		        return;
		      }

		      drawText(text, x, listBounds.bottom, ctx);
		    }
		  }

		  function loadImage (src){
		    var img = images[src];
		    return (img && img.succeeded === true) ? img.img : false;
		  }

		  function clipBounds(src, dst){
		    var x = Math.max(src.left, dst.left),
		    y = Math.max(src.top, dst.top),
		    x2 = Math.min((src.left + src.width), (dst.left + dst.width)),
		    y2 = Math.min((src.top + src.height), (dst.top + dst.height));

		    return {
		      left:x,
		      top:y,
		      width:x2-x,
		      height:y2-y
		    };
		  }

		  function setZ(element, stack, parentStack){
		    var newContext,
		    isPositioned = stack.cssPosition !== 'static',
		    zIndex = isPositioned ? getCSS(element, 'zIndex') : 'auto',
		    opacity = getCSS(element, 'opacity'),
		    isFloated = getCSS(element, 'cssFloat') !== 'none';

		    // https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
		    // When a new stacking context should be created:
		    // the root element (HTML),
		    // positioned (absolutely or relatively) with a z-index value other than "auto",
		    // elements with an opacity value less than 1. (See the specification for opacity),
		    // on mobile WebKit and Chrome 22+, position: fixed always creates a new stacking context, even when z-index is "auto" (See this post)

		    stack.zIndex = newContext = h2czContext(zIndex);
		    newContext.isPositioned = isPositioned;
		    newContext.isFloated = isFloated;
		    newContext.opacity = opacity;
		    newContext.ownStacking = (zIndex !== 'auto' || opacity < 1);

		    if (parentStack) {
		      parentStack.zIndex.children.push(stack);
		    }
		  }

		  function renderImage(ctx, element, image, bounds, borders) {

		    var paddingLeft = getCSSInt(element, 'paddingLeft'),
		    paddingTop = getCSSInt(element, 'paddingTop'),
		    paddingRight = getCSSInt(element, 'paddingRight'),
		    paddingBottom = getCSSInt(element, 'paddingBottom');

		    drawImage(
		      ctx,
		      image,
		      0, //sx
		      0, //sy
		      image.width, //sw
		      image.height, //sh
		      bounds.left + paddingLeft + borders[3].width, //dx
		      bounds.top + paddingTop + borders[0].width, // dy
		      bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
		      bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
		      );
		  }

		  function getBorderData(element) {
		    return ["Top", "Right", "Bottom", "Left"].map(function(side) {
		      return {
		        width: getCSSInt(element, 'border' + side + 'Width'),
		        color: getCSS(element, 'border' + side + 'Color')
		      };
		    });
		  }

		  function getBorderRadiusData(element) {
		    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
		      return getCSS(element, 'border' + side + 'Radius');
		    });
		  }

		  var getCurvePoints = (function(kappa) {

		    return function(x, y, r1, r2) {
		      var ox = (r1) * kappa, // control point offset horizontal
		      oy = (r2) * kappa, // control point offset vertical
		      xm = x + r1, // x-middle
		      ym = y + r2; // y-middle
		      return {
		        topLeft: bezierCurve({
		          x:x,
		          y:ym
		        }, {
		          x:x,
		          y:ym - oy
		        }, {
		          x:xm - ox,
		          y:y
		        }, {
		          x:xm,
		          y:y
		        }),
		        topRight: bezierCurve({
		          x:x,
		          y:y
		        }, {
		          x:x + ox,
		          y:y
		        }, {
		          x:xm,
		          y:ym - oy
		        }, {
		          x:xm,
		          y:ym
		        }),
		        bottomRight: bezierCurve({
		          x:xm,
		          y:y
		        }, {
		          x:xm,
		          y:y + oy
		        }, {
		          x:x + ox,
		          y:ym
		        }, {
		          x:x,
		          y:ym
		        }),
		        bottomLeft: bezierCurve({
		          x:xm,
		          y:ym
		        }, {
		          x:xm - ox,
		          y:ym
		        }, {
		          x:x,
		          y:y + oy
		        }, {
		          x:x,
		          y:y
		        })
		      };
		    };
		  })(4 * ((Math.sqrt(2) - 1) / 3));

		  function bezierCurve(start, startControl, endControl, end) {

		    var lerp = function (a, b, t) {
		      return {
		        x:a.x + (b.x - a.x) * t,
		        y:a.y + (b.y - a.y) * t
		      };
		    };

		    return {
		      start: start,
		      startControl: startControl,
		      endControl: endControl,
		      end: end,
		      subdivide: function(t) {
		        var ab = lerp(start, startControl, t),
		        bc = lerp(startControl, endControl, t),
		        cd = lerp(endControl, end, t),
		        abbc = lerp(ab, bc, t),
		        bccd = lerp(bc, cd, t),
		        dest = lerp(abbc, bccd, t);
		        return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
		      },
		      curveTo: function(borderArgs) {
		        borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
		      },
		      curveToReversed: function(borderArgs) {
		        borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
		      }
		    };
		  }

		  function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
		    if (radius1[0] > 0 || radius1[1] > 0) {
		      borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
		      corner1[0].curveTo(borderArgs);
		      corner1[1].curveTo(borderArgs);
		    } else {
		      borderArgs.push(["line", x, y]);
		    }

		    if (radius2[0] > 0 || radius2[1] > 0) {
		      borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
		    }
		  }

		  function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
		    var borderArgs = [];

		    if (radius1[0] > 0 || radius1[1] > 0) {
		      borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
		      outer1[1].curveTo(borderArgs);
		    } else {
		      borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);
		    }

		    if (radius2[0] > 0 || radius2[1] > 0) {
		      borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
		      outer2[0].curveTo(borderArgs);
		      borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
		      inner2[0].curveToReversed(borderArgs);
		    } else {
		      borderArgs.push([ "line", borderData.c2[0], borderData.c2[1]]);
		      borderArgs.push([ "line", borderData.c3[0], borderData.c3[1]]);
		    }

		    if (radius1[0] > 0 || radius1[1] > 0) {
		      borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
		      inner1[1].curveToReversed(borderArgs);
		    } else {
		      borderArgs.push([ "line", borderData.c4[0], borderData.c4[1]]);
		    }

		    return borderArgs;
		  }

		  function calculateCurvePoints(bounds, borderRadius, borders) {

		    var x = bounds.left,
		    y = bounds.top,
		    width = bounds.width,
		    height = bounds.height,

		    tlh = borderRadius[0][0],
		    tlv = borderRadius[0][1],
		    trh = borderRadius[1][0],
		    trv = borderRadius[1][1],
		    brh = borderRadius[2][0],
		    brv = borderRadius[2][1],
		    blh = borderRadius[3][0],
		    blv = borderRadius[3][1],

		    topWidth = width - trh,
		    rightHeight = height - brv,
		    bottomWidth = width - brh,
		    leftHeight = height - blv;

		    return {
		      topLeftOuter: getCurvePoints(
		        x,
		        y,
		        tlh,
		        tlv
		        ).topLeft.subdivide(0.5),

		      topLeftInner: getCurvePoints(
		        x + borders[3].width,
		        y + borders[0].width,
		        Math.max(0, tlh - borders[3].width),
		        Math.max(0, tlv - borders[0].width)
		        ).topLeft.subdivide(0.5),

		      topRightOuter: getCurvePoints(
		        x + topWidth,
		        y,
		        trh,
		        trv
		        ).topRight.subdivide(0.5),

		      topRightInner: getCurvePoints(
		        x + Math.min(topWidth, width + borders[3].width),
		        y + borders[0].width,
		        (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width,
		        trv - borders[0].width
		        ).topRight.subdivide(0.5),

		      bottomRightOuter: getCurvePoints(
		        x + bottomWidth,
		        y + rightHeight,
		        brh,
		        brv
		        ).bottomRight.subdivide(0.5),

		      bottomRightInner: getCurvePoints(
		        x + Math.min(bottomWidth, width + borders[3].width),
		        y + Math.min(rightHeight, height + borders[0].width),
		        Math.max(0, brh - borders[1].width),
		        Math.max(0, brv - borders[2].width)
		        ).bottomRight.subdivide(0.5),

		      bottomLeftOuter: getCurvePoints(
		        x,
		        y + leftHeight,
		        blh,
		        blv
		        ).bottomLeft.subdivide(0.5),

		      bottomLeftInner: getCurvePoints(
		        x + borders[3].width,
		        y + leftHeight,
		        Math.max(0, blh - borders[3].width),
		        Math.max(0, blv - borders[2].width)
		        ).bottomLeft.subdivide(0.5)
		    };
		  }

		  function getBorderClip(element, borderPoints, borders, radius, bounds) {
		    var backgroundClip = getCSS(element, 'backgroundClip'),
		    borderArgs = [];

		    switch(backgroundClip) {
		      case "content-box":
		      case "padding-box":
		        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
		        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
		        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
		        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
		        break;

		      default:
		        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
		        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
		        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
		        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
		        break;
		    }

		    return borderArgs;
		  }

		  function parseBorders(element, bounds, borders){
		    var x = bounds.left,
		    y = bounds.top,
		    width = bounds.width,
		    height = bounds.height,
		    borderSide,
		    bx,
		    by,
		    bw,
		    bh,
		    borderArgs,
		    // http://www.w3.org/TR/css3-background/#the-border-radius
		    borderRadius = getBorderRadiusData(element),
		    borderPoints = calculateCurvePoints(bounds, borderRadius, borders),
		    borderData = {
		      clip: getBorderClip(element, borderPoints, borders, borderRadius, bounds),
		      borders: []
		    };

		    for (borderSide = 0; borderSide < 4; borderSide++) {

		      if (borders[borderSide].width > 0) {
		        bx = x;
		        by = y;
		        bw = width;
		        bh = height - (borders[2].width);

		        switch(borderSide) {
		          case 0:
		            // top border
		            bh = borders[0].width;

		            borderArgs = drawSide({
		              c1: [bx, by],
		              c2: [bx + bw, by],
		              c3: [bx + bw - borders[1].width, by + bh],
		              c4: [bx + borders[3].width, by + bh]
		            }, borderRadius[0], borderRadius[1],
		            borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
		            break;
		          case 1:
		            // right border
		            bx = x + width - (borders[1].width);
		            bw = borders[1].width;

		            borderArgs = drawSide({
		              c1: [bx + bw, by],
		              c2: [bx + bw, by + bh + borders[2].width],
		              c3: [bx, by + bh],
		              c4: [bx, by + borders[0].width]
		            }, borderRadius[1], borderRadius[2],
		            borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
		            break;
		          case 2:
		            // bottom border
		            by = (by + height) - (borders[2].width);
		            bh = borders[2].width;

		            borderArgs = drawSide({
		              c1: [bx + bw, by + bh],
		              c2: [bx, by + bh],
		              c3: [bx + borders[3].width, by],
		              c4: [bx + bw - borders[3].width, by]
		            }, borderRadius[2], borderRadius[3],
		            borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
		            break;
		          case 3:
		            // left border
		            bw = borders[3].width;

		            borderArgs = drawSide({
		              c1: [bx, by + bh + borders[2].width],
		              c2: [bx, by],
		              c3: [bx + bw, by + borders[0].width],
		              c4: [bx + bw, by + bh]
		            }, borderRadius[3], borderRadius[0],
		            borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
		            break;
		        }

		        borderData.borders.push({
		          args: borderArgs,
		          color: borders[borderSide].color
		        });

		      }
		    }

		    return borderData;
		  }

		  function createShape(ctx, args) {
		    var shape = ctx.drawShape();
		    args.forEach(function(border, index) {
		      shape[(index === 0) ? "moveTo" : border[0] + "To" ].apply(null, border.slice(1));
		    });
		    return shape;
		  }

		  function renderBorders(ctx, borderArgs, color) {
		    if (color !== "transparent") {
		      ctx.setVariable( "fillStyle", color);
		      createShape(ctx, borderArgs);
		      ctx.fill();
		      numDraws+=1;
		    }
		  }

		  function renderFormValue (el, bounds, stack){

		    var valueWrap = doc.createElement('valuewrap'),
		    cssPropertyArray = ['lineHeight','textAlign','fontFamily','color','fontSize','paddingLeft','paddingTop','width','height','border','borderLeftWidth','borderTopWidth'],
		    textValue,
		    textNode;

		    cssPropertyArray.forEach(function(property) {
		      try {
		        valueWrap.style[property] = getCSS(el, property);
		      } catch(e) {
		        // Older IE has issues with "border"
		        Util.log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
		      }
		    });

		    valueWrap.style.borderColor = "black";
		    valueWrap.style.borderStyle = "solid";
		    valueWrap.style.display = "block";
		    valueWrap.style.position = "absolute";

		    if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === "SELECT"){
		      valueWrap.style.lineHeight = getCSS(el, "height");
		    }

		    valueWrap.style.top = bounds.top + "px";
		    valueWrap.style.left = bounds.left + "px";

		    textValue = (el.nodeName === "SELECT") ? (el.options[el.selectedIndex] || 0).text : el.value;
		    if(!textValue) {
		      textValue = el.placeholder;
		    }

		    textNode = doc.createTextNode(textValue);

		    valueWrap.appendChild(textNode);
		    body.appendChild(valueWrap);

		    renderText(el, textNode, stack);
		    body.removeChild(valueWrap);
		  }

		  function drawImage (ctx) {
		    ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));
		    numDraws+=1;
		  }

		  function getPseudoElement(el, which) {
		    var elStyle = window.getComputedStyle(el, which);
		    if(!elStyle || !elStyle.content || elStyle.content === "none" || elStyle.content === "-moz-alt-content" || elStyle.display === "none") {
		      return;
		    }
		    var content = elStyle.content + '',
		    first = content.substr( 0, 1 );
		    //strips quotes
		    if(first === content.substr( content.length - 1 ) && first.match(/'|"/)) {
		      content = content.substr( 1, content.length - 2 );
		    }

		    var isImage = content.substr( 0, 3 ) === 'url',
		    elps = document.createElement( isImage ? 'img' : 'span' );

		    elps.className = pseudoHide + "-before " + pseudoHide + "-after";

		    Object.keys(elStyle).filter(indexedProperty).forEach(function(prop) {
		      // Prevent assigning of read only CSS Rules, ex. length, parentRule
		      try {
		        elps.style[prop] = elStyle[prop];
		      } catch (e) {
		        Util.log(['Tried to assign readonly property ', prop, 'Error:', e]);
		      }
		    });

		    if(isImage) {
		      elps.src = Util.parseBackgroundImage(content)[0].args[0];
		    } else {
		      elps.innerHTML = content;
		    }
		    return elps;
		  }

		  function indexedProperty(property) {
		    return (isNaN(window.parseInt(property, 10)));
		  }

		  function injectPseudoElements(el, stack) {
		    var before = getPseudoElement(el, ':before'),
		    after = getPseudoElement(el, ':after');
		    if(!before && !after) {
		      return;
		    }

		    if(before) {
		      el.className += " " + pseudoHide + "-before";
		      el.parentNode.insertBefore(before, el);
		      parseElement(before, stack, true);
		      el.parentNode.removeChild(before);
		      el.className = el.className.replace(pseudoHide + "-before", "").trim();
		    }

		    if (after) {
		      el.className += " " + pseudoHide + "-after";
		      el.appendChild(after);
		      parseElement(after, stack, true);
		      el.removeChild(after);
		      el.className = el.className.replace(pseudoHide + "-after", "").trim();
		    }

		  }

		  function renderBackgroundRepeat(ctx, image, backgroundPosition, bounds) {
		    var offsetX = Math.round(bounds.left + backgroundPosition.left),
		    offsetY = Math.round(bounds.top + backgroundPosition.top);

		    ctx.createPattern(image);
		    ctx.translate(offsetX, offsetY);
		    ctx.fill();
		    ctx.translate(-offsetX, -offsetY);
		  }

		  function backgroundRepeatShape(ctx, image, backgroundPosition, bounds, left, top, width, height) {
		    var args = [];
		    args.push(["line", Math.round(left), Math.round(top)]);
		    args.push(["line", Math.round(left + width), Math.round(top)]);
		    args.push(["line", Math.round(left + width), Math.round(height + top)]);
		    args.push(["line", Math.round(left), Math.round(height + top)]);
		    createShape(ctx, args);
		    ctx.save();
		    ctx.clip();
		    renderBackgroundRepeat(ctx, image, backgroundPosition, bounds);
		    ctx.restore();
		  }

		  function renderBackgroundColor(ctx, backgroundBounds, bgcolor) {
		    renderRect(
		      ctx,
		      backgroundBounds.left,
		      backgroundBounds.top,
		      backgroundBounds.width,
		      backgroundBounds.height,
		      bgcolor
		      );
		  }

		  function renderBackgroundRepeating(el, bounds, ctx, image, imageIndex) {
		    var backgroundSize = Util.BackgroundSize(el, bounds, image, imageIndex),
		    backgroundPosition = Util.BackgroundPosition(el, bounds, image, imageIndex, backgroundSize),
		    backgroundRepeat = getCSS(el, "backgroundRepeat").split(",").map(Util.trimText);

		    image = resizeImage(image, backgroundSize);

		    backgroundRepeat = backgroundRepeat[imageIndex] || backgroundRepeat[0];

		    switch (backgroundRepeat) {
		      case "repeat-x":
		        backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
		          bounds.left, bounds.top + backgroundPosition.top, 99999, image.height);
		        break;

		      case "repeat-y":
		        backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
		          bounds.left + backgroundPosition.left, bounds.top, image.width, 99999);
		        break;

		      case "no-repeat":
		        backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
		          bounds.left + backgroundPosition.left, bounds.top + backgroundPosition.top, image.width, image.height);
		        break;

		      default:
		        renderBackgroundRepeat(ctx, image, backgroundPosition, {
		          top: bounds.top,
		          left: bounds.left,
		          width: image.width,
		          height: image.height
		        });
		        break;
		    }
		  }

		  function renderBackgroundImage(element, bounds, ctx) {
		    var backgroundImage = getCSS(element, "backgroundImage"),
		    backgroundImages = Util.parseBackgroundImage(backgroundImage),
		    image,
		    imageIndex = backgroundImages.length;

		    while(imageIndex--) {
		      backgroundImage = backgroundImages[imageIndex];

		      if (!backgroundImage.args || backgroundImage.args.length === 0) {
		        continue;
		      }

		      var key = backgroundImage.method === 'url' ?
		      backgroundImage.args[0] :
		      backgroundImage.value;

		      image = loadImage(key);

		      // TODO add support for background-origin
		      if (image) {
		        renderBackgroundRepeating(element, bounds, ctx, image, imageIndex);
		      } else {
		        Util.log("html2canvas: Error loading background:", backgroundImage);
		      }
		    }
		  }

		  function resizeImage(image, bounds) {
		    if(image.width === bounds.width && image.height === bounds.height) {
		      return image;
		    }

		    var ctx, canvas = doc.createElement('canvas');
		    canvas.width = bounds.width;
		    canvas.height = bounds.height;
		    ctx = canvas.getContext("2d");
		    drawImage(ctx, image, 0, 0, image.width, image.height, 0, 0, bounds.width, bounds.height );
		    return canvas;
		  }

		  function setOpacity(ctx, element, parentStack) {
		    return ctx.setVariable("globalAlpha", getCSS(element, "opacity") * ((parentStack) ? parentStack.opacity : 1));
		  }

		  function removePx(str) {
		    return str.replace("px", "");
		  }

		  var transformRegExp = /(matrix)\((.+)\)/;

		  function getTransform(element, parentStack) {
		    var transform = getCSS(element, "transform") || getCSS(element, "-webkit-transform") || getCSS(element, "-moz-transform") || getCSS(element, "-ms-transform") || getCSS(element, "-o-transform");
		    var transformOrigin = getCSS(element, "transform-origin") || getCSS(element, "-webkit-transform-origin") || getCSS(element, "-moz-transform-origin") || getCSS(element, "-ms-transform-origin") || getCSS(element, "-o-transform-origin") || "0px 0px";

		    transformOrigin = transformOrigin.split(" ").map(removePx).map(Util.asFloat);

		    var matrix;
		    if (transform && transform !== "none") {
		      var match = transform.match(transformRegExp);
		      if (match) {
		        switch(match[1]) {
		          case "matrix":
		            matrix = match[2].split(",").map(Util.trimText).map(Util.asFloat);
		            break;
		        }
		      }
		    }

		    return {
		      origin: transformOrigin,
		      matrix: matrix
		    };
		  }

		  function createStack(element, parentStack, bounds, transform) {
		    var ctx = h2cRenderContext((!parentStack) ? documentWidth() : bounds.width , (!parentStack) ? documentHeight() : bounds.height),
		    stack = {
		      ctx: ctx,
		      opacity: setOpacity(ctx, element, parentStack),
		      cssPosition: getCSS(element, "position"),
		      borders: getBorderData(element),
		      transform: transform,
		      clip: (parentStack && parentStack.clip) ? Util.Extend( {}, parentStack.clip ) : null
		    };

		    setZ(element, stack, parentStack);

		    // TODO correct overflow for absolute content residing under a static position
		    if (options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(element, "overflow")) === true && /(BODY)/i.test(element.nodeName) === false){
		      stack.clip = (stack.clip) ? clipBounds(stack.clip, bounds) : bounds;
		    }

		    return stack;
		  }

		  function getBackgroundBounds(borders, bounds, clip) {
		    var backgroundBounds = {
		      left: bounds.left + borders[3].width,
		      top: bounds.top + borders[0].width,
		      width: bounds.width - (borders[1].width + borders[3].width),
		      height: bounds.height - (borders[0].width + borders[2].width)
		    };

		    if (clip) {
		      backgroundBounds = clipBounds(backgroundBounds, clip);
		    }

		    return backgroundBounds;
		  }

		  function getBounds(element, transform) {
		    var bounds = (transform.matrix) ? Util.OffsetBounds(element) : Util.Bounds(element);
		    transform.origin[0] += bounds.left;
		    transform.origin[1] += bounds.top;
		    return bounds;
		  }

		  function renderElement(element, parentStack, pseudoElement, ignoreBackground) {
		    var transform = getTransform(element, parentStack),
		    bounds = getBounds(element, transform),
		    image,
		    stack = createStack(element, parentStack, bounds, transform),
		    borders = stack.borders,
		    ctx = stack.ctx,
		    backgroundBounds = getBackgroundBounds(borders, bounds, stack.clip),
		    borderData = parseBorders(element, bounds, borders),
		    backgroundColor = (ignoreElementsRegExp.test(element.nodeName)) ? "#efefef" : getCSS(element, "backgroundColor");


		    createShape(ctx, borderData.clip);

		    ctx.save();
		    ctx.clip();

		    if (backgroundBounds.height > 0 && backgroundBounds.width > 0 && !ignoreBackground) {
		      renderBackgroundColor(ctx, bounds, backgroundColor);
		      renderBackgroundImage(element, backgroundBounds, ctx);
		    } else if (ignoreBackground) {
		      stack.backgroundColor =  backgroundColor;
		    }

		    ctx.restore();

		    borderData.borders.forEach(function(border) {
		      renderBorders(ctx, border.args, border.color);
		    });

		    if (!pseudoElement) {
		      injectPseudoElements(element, stack);
		    }

		    switch(element.nodeName){
		      case "IMG":
		        if ((image = loadImage(element.getAttribute('src')))) {
		          renderImage(ctx, element, image, bounds, borders);
		        } else {
		          Util.log("html2canvas: Error loading <img>:" + element.getAttribute('src'));
		        }
		        break;
		      case "INPUT":
		        // TODO add all relevant type's, i.e. HTML5 new stuff
		        // todo add support for placeholder attribute for browsers which support it
		        if (/^(text|url|email|submit|button|reset)$/.test(element.type) && (element.value || element.placeholder || "").length > 0){
		          renderFormValue(element, bounds, stack);
		        }
		        break;
		      case "TEXTAREA":
		        if ((element.value || element.placeholder || "").length > 0){
		          renderFormValue(element, bounds, stack);
		        }
		        break;
		      case "SELECT":
		        if ((element.options||element.placeholder || "").length > 0){
		          renderFormValue(element, bounds, stack);
		        }
		        break;
		      case "LI":
		        renderListItem(element, stack, backgroundBounds);
		        break;
		      case "CANVAS":
		        renderImage(ctx, element, element, bounds, borders);
		        break;
		    }

		    return stack;
		  }

		  function isElementVisible(element) {
		    return (getCSS(element, 'display') !== "none" && getCSS(element, 'visibility') !== "hidden" && !element.hasAttribute("data-html2canvas-ignore"));
		  }

		  function parseElement (element, stack, pseudoElement) {
		    if (isElementVisible(element)) {
		      stack = renderElement(element, stack, pseudoElement, false) || stack;
		      if (!ignoreElementsRegExp.test(element.nodeName)) {
		        parseChildren(element, stack, pseudoElement);
		      }
		    }
		  }

		  function parseChildren(element, stack, pseudoElement) {
		    Util.Children(element).forEach(function(node) {
		      if (node.nodeType === node.ELEMENT_NODE) {
		        parseElement(node, stack, pseudoElement);
		      } else if (node.nodeType === node.TEXT_NODE) {
		        renderText(element, node, stack);
		      }
		    });
		  }

		  function init() {
		    var background = getCSS(document.documentElement, "backgroundColor"),
		      transparentBackground = (Util.isTransparent(background) && element === document.body),
		      stack = renderElement(element, null, false, transparentBackground);
		    parseChildren(element, stack);

		    if (transparentBackground) {
		      background = stack.backgroundColor;
		    }

		    body.removeChild(hidePseudoElements);
		    return {
		      backgroundColor: background,
		      stack: stack
		    };
		  }

		  return init();
		};

		function h2czContext(zindex) {
		  return {
		    zindex: zindex,
		    children: []
		  };
		}

		_html2canvas.Preload = function( options ) {

		  var images = {
		    numLoaded: 0,   // also failed are counted here
		    numFailed: 0,
		    numTotal: 0,
		    cleanupDone: false
		  },
		  pageOrigin,
		  Util = _html2canvas.Util,
		  methods,
		  i,
		  count = 0,
		  element = options.elements[0] || document.body,
		  doc = element.ownerDocument,
		  domImages = element.getElementsByTagName('img'), // Fetch images of the present element only
		  imgLen = domImages.length,
		  link = doc.createElement("a"),
		  supportCORS = (function( img ){
		    return (img.crossOrigin !== undefined);
		  })(new Image()),
		  timeoutTimer;

		  link.href = window.location.href;
		  pageOrigin  = link.protocol + link.host;

		  function isSameOrigin(url){
		    link.href = url;
		    link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/
		    var origin = link.protocol + link.host;
		    return (origin === pageOrigin);
		  }

		  function start(){
		    Util.log("html2canvas: start: images: " + images.numLoaded + " / " + images.numTotal + " (failed: " + images.numFailed + ")");
		    if (!images.firstRun && images.numLoaded >= images.numTotal){
		      Util.log("Finished loading images: # " + images.numTotal + " (failed: " + images.numFailed + ")");

		      if (typeof options.complete === "function"){
		        options.complete(images);
		      }

		    }
		  }

		  // TODO modify proxy to serve images with CORS enabled, where available
		  function proxyGetImage(url, img, imageObj){
		    var callback_name,
		    scriptUrl = options.proxy,
		    script;

		    link.href = url;
		    url = link.href; // work around for pages with base href="" set - WARNING: this may change the url

		    callback_name = 'html2canvas_' + (count++);
		    imageObj.callbackname = callback_name;

		    if (scriptUrl.indexOf("?") > -1) {
		      scriptUrl += "&";
		    } else {
		      scriptUrl += "?";
		    }
		    scriptUrl += 'url=' + encodeURIComponent(url) + '&callback=' + callback_name;
		    script = doc.createElement("script");

		    window[callback_name] = function(a){
		      if (a.substring(0,6) === "error:"){
		        imageObj.succeeded = false;
		        images.numLoaded++;
		        images.numFailed++;
		        start();
		      } else {
		        setImageLoadHandlers(img, imageObj);
		        img.src = a;
		      }
		      window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
		      try {
		        delete window[callback_name];  // for all browser that support this
		      } catch(ex) {}
		      script.parentNode.removeChild(script);
		      script = null;
		      delete imageObj.script;
		      delete imageObj.callbackname;
		    };

		    script.setAttribute("type", "text/javascript");
		    script.setAttribute("src", scriptUrl);
		    imageObj.script = script;
		    window.document.body.appendChild(script);

		  }

		  function loadPseudoElement(element, type) {
		    var style = window.getComputedStyle(element, type),
		    content = style.content;
		    if (content.substr(0, 3) === 'url') {
		      methods.loadImage(_html2canvas.Util.parseBackgroundImage(content)[0].args[0]);
		    }
		    loadBackgroundImages(style.backgroundImage, element);
		  }

		  function loadPseudoElementImages(element) {
		    loadPseudoElement(element, ":before");
		    loadPseudoElement(element, ":after");
		  }

		  function loadGradientImage(backgroundImage, bounds) {
		    var img = _html2canvas.Generate.Gradient(backgroundImage, bounds);

		    if (img !== undefined){
		      images[backgroundImage] = {
		        img: img,
		        succeeded: true
		      };
		      images.numTotal++;
		      images.numLoaded++;
		      start();
		    }
		  }

		  function invalidBackgrounds(background_image) {
		    return (background_image && background_image.method && background_image.args && background_image.args.length > 0 );
		  }

		  function loadBackgroundImages(background_image, el) {
		    var bounds;

		    _html2canvas.Util.parseBackgroundImage(background_image).filter(invalidBackgrounds).forEach(function(background_image) {
		      if (background_image.method === 'url') {
		        methods.loadImage(background_image.args[0]);
		      } else if(background_image.method.match(/\-?gradient$/)) {
		        if(bounds === undefined) {
		          bounds = _html2canvas.Util.Bounds(el);
		        }
		        loadGradientImage(background_image.value, bounds);
		      }
		    });
		  }

		  function getImages (el) {
		    var elNodeType = false;

		    // Firefox fails with permission denied on pages with iframes
		    try {
		      Util.Children(el).forEach(getImages);
		    }
		    catch( e ) {}

		    try {
		      elNodeType = el.nodeType;
		    } catch (ex) {
		      elNodeType = false;
		      Util.log("html2canvas: failed to access some element's nodeType - Exception: " + ex.message);
		    }

		    if (elNodeType === 1 || elNodeType === undefined) {
		      loadPseudoElementImages(el);
		      try {
		        loadBackgroundImages(Util.getCSS(el, 'backgroundImage'), el);
		      } catch(e) {
		        Util.log("html2canvas: failed to get background-image - Exception: " + e.message);
		      }
		      loadBackgroundImages(el);
		    }
		  }

		  function setImageLoadHandlers(img, imageObj) {
		    img.onload = function() {
		      if ( imageObj.timer !== undefined ) {
		        // CORS succeeded
		        window.clearTimeout( imageObj.timer );
		      }

		      images.numLoaded++;
		      imageObj.succeeded = true;
		      img.onerror = img.onload = null;
		      start();
		    };
		    img.onerror = function() {
		      if (img.crossOrigin === "anonymous") {
		        // CORS failed
		        window.clearTimeout( imageObj.timer );

		        // let's try with proxy instead
		        if ( options.proxy ) {
		          var src = img.src;
		          img = new Image();
		          imageObj.img = img;
		          img.src = src;

		          proxyGetImage( img.src, img, imageObj );
		          return;
		        }
		      }

		      images.numLoaded++;
		      images.numFailed++;
		      imageObj.succeeded = false;
		      img.onerror = img.onload = null;
		      start();
		    };
		  }

		  methods = {
		    loadImage: function( src ) {
		      var img, imageObj;
		      if ( src && images[src] === undefined ) {
		        img = new Image();
		        if ( src.match(/data:image\/.*;base64,/i) ) {
		          img.src = src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, '');
		          imageObj = images[src] = {
		            img: img
		          };
		          images.numTotal++;
		          setImageLoadHandlers(img, imageObj);
		        } else if ( isSameOrigin( src ) || options.allowTaint ===  true ) {
		          imageObj = images[src] = {
		            img: img
		          };
		          images.numTotal++;
		          setImageLoadHandlers(img, imageObj);
		          img.src = src;
		        } else if ( supportCORS && !options.allowTaint && options.useCORS ) {
		          // attempt to load with CORS

		          img.crossOrigin = "anonymous";
		          imageObj = images[src] = {
		            img: img
		          };
		          images.numTotal++;
		          setImageLoadHandlers(img, imageObj);
		          img.src = src;
		        } else if ( options.proxy ) {
		          imageObj = images[src] = {
		            img: img
		          };
		          images.numTotal++;
		          proxyGetImage( src, img, imageObj );
		        }
		      }

		    },
		    cleanupDOM: function(cause) {
		      var img, src;
		      if (!images.cleanupDone) {
		        if (cause && typeof cause === "string") {
		          Util.log("html2canvas: Cleanup because: " + cause);
		        } else {
		          Util.log("html2canvas: Cleanup after timeout: " + options.timeout + " ms.");
		        }

		        for (src in images) {
		          if (images.hasOwnProperty(src)) {
		            img = images[src];
		            if (typeof img === "object" && img.callbackname && img.succeeded === undefined) {
		              // cancel proxy image request
		              window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
		              try {
		                delete window[img.callbackname];  // for all browser that support this
		              } catch(ex) {}
		              if (img.script && img.script.parentNode) {
		                img.script.setAttribute("src", "about:blank");  // try to cancel running request
		                img.script.parentNode.removeChild(img.script);
		              }
		              images.numLoaded++;
		              images.numFailed++;
		              Util.log("html2canvas: Cleaned up failed img: '" + src + "' Steps: " + images.numLoaded + " / " + images.numTotal);
		            }
		          }
		        }

		        // cancel any pending requests
		        if(window.stop !== undefined) {
		          window.stop();
		        } else if(document.execCommand !== undefined) {
		          document.execCommand("Stop", false);
		        }
		        if (document.close !== undefined) {
		          document.close();
		        }
		        images.cleanupDone = true;
		        if (!(cause && typeof cause === "string")) {
		          start();
		        }
		      }
		    },

		    renderingDone: function() {
		      if (timeoutTimer) {
		        window.clearTimeout(timeoutTimer);
		      }
		    }
		  };

		  if (options.timeout > 0) {
		    timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);
		  }

		  Util.log('html2canvas: Preload starts: finding background-images');
		  images.firstRun = true;

		  getImages(element);

		  Util.log('html2canvas: Preload: Finding images');
		  // load <img> images
		  for (i = 0; i < imgLen; i+=1){
		    methods.loadImage( domImages[i].getAttribute( "src" ) );
		  }

		  images.firstRun = false;
		  Util.log('html2canvas: Preload: Done.');
		  if (images.numTotal === images.numLoaded) {
		    start();
		  }

		  return methods;
		};

		_html2canvas.Renderer = function(parseQueue, options){

		  // http://www.w3.org/TR/CSS21/zindex.html
		  function createRenderQueue(parseQueue) {
		    var queue = [],
		    rootContext;

		    rootContext = (function buildStackingContext(rootNode) {
		      var rootContext = {};
		      function insert(context, node, specialParent) {
		        var zi = (node.zIndex.zindex === 'auto') ? 0 : Number(node.zIndex.zindex),
		        contextForChildren = context, // the stacking context for children
		        isPositioned = node.zIndex.isPositioned,
		        isFloated = node.zIndex.isFloated,
		        stub = {node: node},
		        childrenDest = specialParent; // where children without z-index should be pushed into

		        if (node.zIndex.ownStacking) {
		          // '!' comes before numbers in sorted array
		          contextForChildren = stub.context = { '!': [{node:node, children: []}]};
		          childrenDest = undefined;
		        } else if (isPositioned || isFloated) {
		          childrenDest = stub.children = [];
		        }

		        if (zi === 0 && specialParent) {
		          specialParent.push(stub);
		        } else {
		          if (!context[zi]) { context[zi] = []; }
		          context[zi].push(stub);
		        }

		        node.zIndex.children.forEach(function(childNode) {
		          insert(contextForChildren, childNode, childrenDest);
		        });
		      }
		      insert(rootContext, rootNode);
		      return rootContext;
		    })(parseQueue);

		    function sortZ(context) {
		      Object.keys(context).sort().forEach(function(zi) {
		        var nonPositioned = [],
		        floated = [],
		        positioned = [],
		        list = [];

		        // positioned after static
		        context[zi].forEach(function(v) {
		          if (v.node.zIndex.isPositioned || v.node.zIndex.opacity < 1) {
		            // http://www.w3.org/TR/css3-color/#transparency
		            // non-positioned element with opactiy < 1 should be stacked as if it were a positioned element with z-index: 0 and opacity: 1.
		            positioned.push(v);
		          } else if (v.node.zIndex.isFloated) {
		            floated.push(v);
		          } else {
		            nonPositioned.push(v);
		          }
		        });

		        (function walk(arr) {
		          arr.forEach(function(v) {
		            list.push(v);
		            if (v.children) { walk(v.children); }
		          });
		        })(nonPositioned.concat(floated, positioned));

		        list.forEach(function(v) {
		          if (v.context) {
		            sortZ(v.context);
		          } else {
		            queue.push(v.node);
		          }
		        });
		      });
		    }

		    sortZ(rootContext);

		    return queue;
		  }

		  function getRenderer(rendererName) {
		    var renderer;

		    if (typeof options.renderer === "string" && _html2canvas.Renderer[rendererName] !== undefined) {
		      renderer = _html2canvas.Renderer[rendererName](options);
		    } else if (typeof rendererName === "function") {
		      renderer = rendererName(options);
		    } else {
		      throw new Error("Unknown renderer");
		    }

		    if ( typeof renderer !== "function" ) {
		      throw new Error("Invalid renderer defined");
		    }
		    return renderer;
		  }

		  return getRenderer(options.renderer)(parseQueue, options, document, createRenderQueue(parseQueue.stack), _html2canvas);
		};

		_html2canvas.Util.Support = function (options, doc) {

		  function supportSVGRendering() {
		    var img = new Image(),
		    canvas = doc.createElement("canvas"),
		    ctx = (canvas.getContext === undefined) ? false : canvas.getContext("2d");
		    if (ctx === false) {
		      return false;
		    }
		    canvas.width = canvas.height = 10;
		    img.src = [
		    "data:image/svg+xml,",
		    "<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>",
		    "<foreignObject width='10' height='10'>",
		    "<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>",
		    "sup",
		    "</div>",
		    "</foreignObject>",
		    "</svg>"
		    ].join("");
		    try {
		      ctx.drawImage(img, 0, 0);
		      canvas.toDataURL();
		    } catch(e) {
		      return false;
		    }
		    _html2canvas.Util.log('html2canvas: Parse: SVG powered rendering available');
		    return true;
		  }

		  // Test whether we can use ranges to measure bounding boxes
		  // Opera doesn't provide valid bounds.height/bottom even though it supports the method.

		  function supportRangeBounds() {
		    var r, testElement, rangeBounds, rangeHeight, support = false;

		    if (doc.createRange) {
		      r = doc.createRange();
		      if (r.getBoundingClientRect) {
		        testElement = doc.createElement('boundtest');
		        testElement.style.height = "123px";
		        testElement.style.display = "block";
		        doc.body.appendChild(testElement);

		        r.selectNode(testElement);
		        rangeBounds = r.getBoundingClientRect();
		        rangeHeight = rangeBounds.height;

		        if (rangeHeight === 123) {
		          support = true;
		        }
		        doc.body.removeChild(testElement);
		      }
		    }

		    return support;
		  }

		  return {
		    rangeBounds: supportRangeBounds(),
		    svgRendering: options.svgRendering && supportSVGRendering()
		  };
		};
		window.html2canvas = function(elements, opts) {
		  elements = (elements.length) ? elements : [elements];
		  var queue,
		  canvas,
		  options = {
		    // general
		    logging: false,
		    elements: elements,
		    background: "#fff",

		    // preload options
		    proxy: null,
		    timeout: 0,    // no timeout
		    useCORS: false, // try to load images as CORS (where available), before falling back to proxy
		    allowTaint: false, // whether to allow images to taint the canvas, won't need proxy if set to true

		    // parse options
		    svgRendering: false, // use svg powered rendering where available (FF11+)
		    ignoreElements: "IFRAME|OBJECT|PARAM",
		    useOverflow: true,
		    letterRendering: false,
		    chinese: false,

		    // render options

		    width: null,
		    height: null,
		    taintTest: true, // do a taint test with all images before applying to canvas
		    renderer: "Canvas"
		  };

		  options = _html2canvas.Util.Extend(opts, options);

		  _html2canvas.logging = options.logging;
		  options.complete = function( images ) {

		    if (typeof options.onpreloaded === "function") {
		      if ( options.onpreloaded( images ) === false ) {
		        return;
		      }
		    }
		    queue = _html2canvas.Parse( images, options );

		    if (typeof options.onparsed === "function") {
		      if ( options.onparsed( queue ) === false ) {
		        return;
		      }
		    }

		    canvas = _html2canvas.Renderer( queue, options );

		    if (typeof options.onrendered === "function") {
		      options.onrendered( canvas );
		    }


		  };

		  // for pages without images, we still want this to be async, i.e. return methods before executing
		  window.setTimeout( function(){
		    _html2canvas.Preload( options );
		  }, 0 );

		  return {
		    render: function( queue, opts ) {
		      return _html2canvas.Renderer( queue, _html2canvas.Util.Extend(opts, options) );
		    },
		    parse: function( images, opts ) {
		      return _html2canvas.Parse( images, _html2canvas.Util.Extend(opts, options) );
		    },
		    preload: function( opts ) {
		      return _html2canvas.Preload( _html2canvas.Util.Extend(opts, options) );
		    },
		    log: _html2canvas.Util.log
		  };
		};

		window.html2canvas.log = _html2canvas.Util.log; // for renderers
		window.html2canvas.Renderer = {
		  Canvas: undefined // We are assuming this will be used
		};
		_html2canvas.Renderer.Canvas = function(options) {
		  options = options || {};

		  var doc = document,
		  safeImages = [],
		  testCanvas = document.createElement("canvas"),
		  testctx = testCanvas.getContext("2d"),
		  Util = _html2canvas.Util,
		  canvas = options.canvas || doc.createElement('canvas');

		  function createShape(ctx, args) {
		    ctx.beginPath();
		    args.forEach(function(arg) {
		      ctx[arg.name].apply(ctx, arg['arguments']);
		    });
		    ctx.closePath();
		  }

		  function safeImage(item) {
		    if (safeImages.indexOf(item['arguments'][0].src ) === -1) {
		      testctx.drawImage(item['arguments'][0], 0, 0);
		      try {
		        testctx.getImageData(0, 0, 1, 1);
		      } catch(e) {
		        testCanvas = doc.createElement("canvas");
		        testctx = testCanvas.getContext("2d");
		        return false;
		      }
		      safeImages.push(item['arguments'][0].src);
		    }
		    return true;
		  }

		  function renderItem(ctx, item) {
		    switch(item.type){
		      case "variable":
		        ctx[item.name] = item['arguments'];
		        break;
		      case "function":
		        switch(item.name) {
		          case "createPattern":
		            if (item['arguments'][0].width > 0 && item['arguments'][0].height > 0) {
		              try {
		                ctx.fillStyle = ctx.createPattern(item['arguments'][0], "repeat");
		              }
		              catch(e) {
		                Util.log("html2canvas: Renderer: Error creating pattern", e.message);
		              }
		            }
		            break;
		          case "drawShape":
		            createShape(ctx, item['arguments']);
		            break;
		          case "drawImage":
		            if (item['arguments'][8] > 0 && item['arguments'][7] > 0) {
		              if (!options.taintTest || (options.taintTest && safeImage(item))) {
		                ctx.drawImage.apply( ctx, item['arguments'] );
		              }
		            }
		            break;
		          default:
		            ctx[item.name].apply(ctx, item['arguments']);
		        }
		        break;
		    }
		  }

		  return function(parsedData, options, document, queue, _html2canvas) {
		    var ctx = canvas.getContext("2d"),
		    newCanvas,
		    bounds,
		    fstyle,
		    zStack = parsedData.stack;

		    canvas.width = canvas.style.width =  options.width || zStack.ctx.width;
		    canvas.height = canvas.style.height = options.height || zStack.ctx.height;

		    fstyle = ctx.fillStyle;
		    ctx.fillStyle = (Util.isTransparent(zStack.backgroundColor) && options.background !== undefined) ? options.background : parsedData.backgroundColor;
		    ctx.fillRect(0, 0, canvas.width, canvas.height);
		    ctx.fillStyle = fstyle;

		    queue.forEach(function(storageContext) {
		      // set common settings for canvas
		      ctx.textBaseline = "bottom";
		      ctx.save();

		      if (storageContext.transform.matrix) {
		        ctx.translate(storageContext.transform.origin[0], storageContext.transform.origin[1]);
		        ctx.transform.apply(ctx, storageContext.transform.matrix);
		        ctx.translate(-storageContext.transform.origin[0], -storageContext.transform.origin[1]);
		      }

		      if (storageContext.clip){
		        ctx.beginPath();
		        ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);
		        ctx.clip();
		      }

		      if (storageContext.ctx.storage) {
		        storageContext.ctx.storage.forEach(function(item) {
		          renderItem(ctx, item);
		        });
		      }

		      ctx.restore();
		    });

		    Util.log("html2canvas: Renderer: Canvas renderer done - returning canvas obj");

		    if (options.elements.length === 1) {
		      if (typeof options.elements[0] === "object" && options.elements[0].nodeName !== "BODY") {
		        // crop image to the bounds of selected (single) element
		        bounds = _html2canvas.Util.Bounds(options.elements[0]);
		        newCanvas = document.createElement('canvas');
		        newCanvas.width = Math.ceil(bounds.width);
		        newCanvas.height = Math.ceil(bounds.height);
		        ctx = newCanvas.getContext("2d");

		        ctx.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);
		        canvas = null;
		        return newCanvas;
		      }
		    }

		    return canvas;
		  };
		};
		})(window,document);
	</script>

	<!--- SCRIPT END -->

	<style type="text/css">
		/* IE8 */
		.qrcodetable { border-width: 0px; border-style: none; border-color: #0000ff; border-collapse: collapse; }
		.qrcodetddark { border-width: 0px; border-style: none; border-color: #0000ff; border-collapse: collapse; padding: 0; margin: 0; width: 2px; height: 2px; background-color: #000000; }
		.qrcodetdlight { border-width: 0px; border-style: none; border-color: #0000ff; border-collapse: collapse; padding: 0; margin: 0; width: 2px; height: 2px; background-color: #ffffff; }



		@media screen
		{
			/* Styling for screen display ... */
			
			body{
				padding:0;
				margin:0;
				background-color:#D7F2F7;
				font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;
				color:#313131;
			}

			a{
				color: #29C4E3;
			}

			p{
				font-size: 0.8em;
			}
			#main{
				min-height:500px;
				width:996px;
				margin:25px auto;
				background-color:#fff;
				border-radius:5px;
				box-shadow:0 0 2.5px #508586;
				padding: 15px;
			}
			#wizard{
				margin-top: 75px;
				border-radius: 10px;
				border: 1px dotted #888;
				padding: 10px 25px;
			}

      #wallets { display: none; }

			#decryptkey, #retrievecoins{
				float: right;
			}

			.decryptkeyinfo{
				padding: 8px;
				border: 1px solid #aaa;
				height: 110px;
			}

			.decryptkeyqrcode{
				display: block;
				float: left;
				width: 100px;
				margin-right: 10px;
			}
			.footer_inner{
				width:996px;
				margin:25px auto;
				color:#fff;
				text-align: center;
				font-size:0.8em;
			}
			.footer_inner a{
				color:#fff;
			}
			.footer_inner a:hover{
				text-decoration: none;
			}

			#paperkeyarea{
				clear:both;
				padding-top:80px;
			}

			#generate{
				border-radius:10px;
				line-height:1.5;
				background:#f7e8be;
				border:1px solid #ead8a7;
				color:#71643f;
				padding:5px 20px;
				font-size:13px;
			}

			#paperwalletdetailscommands{
				margin-bottom: 10px;
			}

			#paperwalletdesignsarea{
				margin-top: 10px;
			}

			#paperwalletdesignaligment{
				margin: 10px 0px;
			}

			#paperwalletprintcommands{
				width: 430px;
				font-size: 0.8em;
			}
			#paperwalletdetailstext{
				float: right;
				width: 490px;
			}

			#barcode-box {
        border: 1px solid #ccc;
        display: inline-block;
		   }

			.wallet-thumbnail{
				display: block;
				width: 425px;
				height: 150px;
				margin: 5px 23px 0px 0px;
				float: left;
				padding: 10px;
				border: 1px solid #ccc;
			}

			.wallet-thumbnail-selected{
				border-left: 2px dotted green;
				border-right: 2px dotted green;
			}

			.wallet-background{
				display: none;
			}
			.aliasdetailcolumn{
				width: 255px;
				display: inline-block;
			}
			.aliasdetail{
				font-size: 0.9em;
				width: 255px;
				display: inline-block;
			}
			.addressdetailcolumn{
				width: 325px;
				display: inline-block;
			}
			.addressdetail{
				font-size: 0.8em;
				width: 325px;
				display: inline-block;
			}
			.privatekeydetailcolumn{
				width: 300px;
				display: inline-block;
			}
			.privatekeydetail{
				font-size: 0.9em;
				width: 300px;
				display: inline-block;
			}

			#keytodecrypt, #passphrasetodecrypt{
				font-size: 0.9em;
				width: 300px;
				display: inline-block;
				margin-bottom: 5px;
			}
			#privatekeytosendcoinsfrom , #addresstosendcoins{
				font-size: 0.8em;
				width: 400px;
				display: inline-block;
				margin-bottom: 5px;
			}

			.errors{
				margin: 5px 0px 5px 0px;
				color: red;
			}

			a .logo{
				color: #fff;
				text-shadow: 0 0 1px #444;
			}

			.logo{
				font-size: 1.5em;
				float:left;
				margin: 8px 55px 0 0;
				padding: 10px 25px;
				border-radius:8px;
				border: 1px solid #30BFD9;

				background: #2bc9ce; /* Old browsers */
				background: -moz-linear-gradient(top, #2bc9ce 0%, #20AFC9 100%); /* FF3.6+ */
				background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#2bc9ce), color-stop(100%,#20AFC9)); /* Chrome,Safari4+ */
				background: -webkit-linear-gradient(top, #2bc9ce 0%,#20AFC9 100%); /* Chrome10+,Safari5.1+ */
				background: -o-linear-gradient(top, #2bc9ce 0%,#20AFC9 100%); /* Opera 11.10+ */
				background: -ms-linear-gradient(top, #2bc9ce 0%,#20AFC9 100%); /* IE10+ */
				background: linear-gradient(to bottom, #2bc9ce 0%,#20AFC9 100%); /* W3C */
				filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#2bc9ce', endColorstr='#20AFC9',GradientType=0 ); /* IE6-9 */
			}

			input[type="number"]{
				width: 75px;
			}

			input[type="password"]{
				border:1px solid #c4c4c4;
				border-radius:5px;
				height:22px;
				line-height:22px;
				outline:none!important;
				margin-bottom: 5px; 
			}
			
			input[type="text"]{
				border:1px solid #c4c4c4;
				border-radius:5px;
				height:22px;
				line-height:22px;
				outline:none!important; 
				width: 50px;
			}
			input[type="button"]{
				overflow:hidden;
				outline:none!important;
				text-shadow:0 -1px 0 #006879;
				cursor:pointer;
				display:inline-block;
				padding:4px 15px;
				color:#fff;
				border-radius:5px;
				border:1px solid #1c7f80;
				background: #2bc9ce; /* Old browsers */
				background: -moz-linear-gradient(top, #2bc9ce 0%, #00849c 100%); /* FF3.6+ */
				background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#2bc9ce), color-stop(100%,#00849c)); /* Chrome,Safari4+ */
				background: -webkit-linear-gradient(top, #2bc9ce 0%,#00849c 100%); /* Chrome10+,Safari5.1+ */
				background: -o-linear-gradient(top, #2bc9ce 0%,#00849c 100%); /* Opera 11.10+ */
				background: -ms-linear-gradient(top, #2bc9ce 0%,#00849c 100%); /* IE10+ */
				background: linear-gradient(to bottom, #2bc9ce 0%,#00849c 100%); /* W3C */
				filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#2bc9ce', endColorstr='#00849c',GradientType=0 ); /* IE6-9 */
			}
			input[type="button"]:hover{
				background: #2bc9ce; /* Old browsers */
				background: -moz-linear-gradient(top, #2bc9ce 0%, #2398a3 100%); /* FF3.6+ */
				background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#2bc9ce), color-stop(100%,#2398a3)); /* Chrome,Safari4+ */
				background: -webkit-linear-gradient(top, #2bc9ce 0%,#2398a3 100%); /* Chrome10+,Safari5.1+ */
				background: -o-linear-gradient(top, #2bc9ce 0%,#2398a3 100%); /* Opera 11.10+ */
				background: -ms-linear-gradient(top, #2bc9ce 0%,#2398a3 100%); /* IE10+ */
				background: linear-gradient(to bottom, #2bc9ce 0%,#2398a3 100%); /* W3C */
				filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#2bc9ce', endColorstr='#2398a3',GradientType=0 ); /* IE6-9 */
			}
			#paperlabelpagestogenerate{
				display: inline-block;
				font-size:0.8em;
			}

			.qrcode_public { width: 66px; height: 66px; }
			.qrcode_private { width: 82px; height: 82px; display: none; }
			
			.keyarea{
				padding-bottom:25px;
				margin-bottom:25px;
				border-bottom:1px dotted #c4c4c4;
			}

			.keyarea:last-child{
				border:none;
				margin-bottom:0;
			}
			.keyarea>.stub,
			.keyarea>.note{
				display:inline-block;
				clear:both;
				width:100%;
			}
			.keyarea>.note{
				margin-bottom:10px;
			}
			.stub .public,
			.note .public{
				float:left;
				margin-bottom:10px;
			}
			.stub .private,
			.note .private{
				float:right;
			}
			.stub .public>div,
			.note .public>div{
				float:left;
				margin-right:20px;
			}
			.pubaddress{
                position: absolute; left: 1.5in; top: 0.185in;
                border: 0; padding: 0.025in 0.05in; margin: 0;
                width: 2.65in; height: 0.15in;
                white-space: nowrap;
			}
			.pubaddressprefix{
				display:block;
				border-radius:5px;
				line-height:1.5;
				background:#f7e8be;
				border:1px solid #ead8a7;
				color:#71643f;
				text-align:center;
				padding:5px 20px;
				font-size:13px;
			}
			.note .pubaddressprefix span{
				margin-top:18px;
			}
			.keyarea canvas{
				border:2px solid #fff;
				box-shadow:0 1px 5px #c4c4c4;
			}
		}

		@page { margin: 0.5in; }

		@media print
		{
			.logo,.footer,
			.commands, #paperwalletdetailsarea, #wizard { display: none; }

			body, div { margin: 0; padding: 0; -webkit-print-color-adjust: exact; font-family: "Geneva";}
			#main { margin: 0; padding: 0; width: 100%; }
			#wallets{ display: block; }
			#decryptkey, #retrievecoins{display: none;}

			#paperarea .keyarea {
				position: relative;
				width: 7.5in; height: 2.5in;
				margin: 0; padding: 0; border: 0;
				font-size: 0.1in; line-height: 0.15in;
			}

			#paperarea .wallet-background{
				width: 7.5in;
			}

			#paperarea .first {
				page-break-before: always;
			}

			#paperarea .keyarea .notes { display: none; }

			#paperarea .keyarea .note .pubaddressprefix { display: none; }

			#paperarea .keyarea .note .qrcode_public {
				position: absolute; left: 0.25in; top: 0.185in;
				border: 0; padding: 0.08in; margin: 0;
				width: 0.84in; height: 0.84in;
			}
			#paperarea .keyarea .note .qrcode_private {
				position: absolute; right: 2.0in; top: 1.3in;
				border: 0; padding: 0.08in; margin: 0;
				width: 0.84in; height: 0.84in;
				display: block;
			}
			#paperarea .keyarea .note .pubaddress {
				position: absolute; left: 1.5in; top: 0.185in;
				border: 0; padding: 0.025in 0.05in; margin: 0;
				width: 2.65in; height: 0.15in;
                white-space: nowrap;
			}

			#paperarea .keyarea .stub .qrcode_public {
				position: absolute; right: 0.1875in; top: 0.185in;
				border: 0; padding: 0.08in; margin: 0;
				width: 0.84in; height: 0.84in;
			}
			#paperarea .keyarea .stub .qrcode_private {
				position: absolute; right: 0.1875in; top: 1.3in;
				border: 0; padding: 0.08in; margin: 0;
				width: 0.84in; height: 0.84in;
				display: block;
                white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
                white-space: -pre-wrap;      /* Opera 4-6 */
                white-space: -o-pre-wrap;    /* Opera 7 */
                white-space: pre-wrap;       /* css-3 */
                word-wrap: break-word;       /* Internet Explorer 5.5+ */
                word-break: break-all;
                white-space: normal;
			}
			#paperarea .keyarea .stub .pubaddressprefix {
				position: absolute; left: 5.937in; top: 1.185in;
				border: 0; padding: 0.025in 0.05in; margin: 0;
				width: 0.9in; height: 0.15in;
				overflow: hidden;

				-webkit-transform-origin:top left; -webkit-transform:rotate(-90deg);
				-moz-transform-origin:top left;    -moz-transform:rotate(-90deg);
				-ms-transform-origin:top left;     -ms-transform:rotate(-90deg);
				-o-transform-origin:top left;      -o-transform:rotate(-90deg);
				transform-origin:top left;         transform:rotate(-90deg);
			}
		}
	</style>
</head>
<body onclick="SecureRandom.seedTime();" onkeypress="SecureRandom.seedTime();" onload="opw.ui.nextStep(0)">
	<div id="main">
		
		<a href="/"><h1 class="logo">Open Paper Wallet</h1></a>
		<div id="decryptkey"><input type="button" value="Decrypt Keys" onclick="opw.ui.nextStep(6)" /></div>
		<div id="retrievecoins"><input type="button" value="Retrieve Coins from Paper Wallet" onclick="opw.ui.nextStep(7)" /></div>
		<div id="wizard">
		</div>

		<div id="wallets">
			<div id="paperarea">
				<div id="paperkeyarea"></div>
			</div>
		</div>
	</div>
	

	<script type="text/javascript">
		var ninja = {paperwallet: {}};

		ninja.privateKey = {
			isPrivateKey: function (key) {
				return (
					Bitcoin.ECKey.isWalletImportFormat(key) ||
					Bitcoin.ECKey.isCompressedWalletImportFormat(key) ||
					Bitcoin.ECKey.isHexFormat(key) ||
					Bitcoin.ECKey.isBase64Format(key) ||
					Bitcoin.ECKey.isMiniFormat(key)
				);
			},
			getECKeyFromAdding: function (privKey1, privKey2) {
				var n = EllipticCurve.getSECCurveByName("secp256k1").getN();
				var ecKey1 = new Bitcoin.ECKey(privKey1);
				var ecKey2 = new Bitcoin.ECKey(privKey2);
				// if both keys are the same return null
				if (ecKey1.getBitcoinHexFormat() == ecKey2.getBitcoinHexFormat()) return null;
				if (ecKey1 == null || ecKey2 == null) return null;
				var combinedPrivateKey = new Bitcoin.ECKey(ecKey1.priv.add(ecKey2.priv).mod(n));
				// compressed when both keys are compressed
				if (ecKey1.compressed && ecKey2.compressed) combinedPrivateKey.setCompressed(true);
				return combinedPrivateKey;
			},
			getECKeyFromMultiplying: function (privKey1, privKey2) {
				var n = EllipticCurve.getSECCurveByName("secp256k1").getN();
				var ecKey1 = new Bitcoin.ECKey(privKey1);
				var ecKey2 = new Bitcoin.ECKey(privKey2);
				// if both keys are the same return null
				if (ecKey1.getBitcoinHexFormat() == ecKey2.getBitcoinHexFormat()) return null;
				if (ecKey1 == null || ecKey2 == null) return null;
				var combinedPrivateKey = new Bitcoin.ECKey(ecKey1.priv.multiply(ecKey2.priv).mod(n));
				// compressed when both keys are compressed
				if (ecKey1.compressed && ecKey2.compressed) combinedPrivateKey.setCompressed(true);
				return combinedPrivateKey;
			},

			//Thanks to Zalieps for this Javascript implementation
			BIP38PrivateKeyToEncryptedKeyAsync: function (base58Key, passphrase, compressed, callback) {
				var privKeyBytes = ninja.privateKey.anyPrivateKeyToByteArray(base58Key);

				var privKey = new Bitcoin.ECKey(privKeyBytes);
				var address = compressed? privKey.getBitcoinAddressCompressed() : privKey.getBitcoinAddress();

				// compute sha256(sha256(privKey)) and take first 4 bytes
				var salt = Bitcoin.Util.dsha256(address).slice(0, 4);

				// derive key using scrypt
				var AES_opts = {mode: new Crypto.mode.ECB(Crypto.pad.NoPadding), asBytes: true};

				Crypto_scrypt(passphrase, salt, 16384, 8, 8, 64, function(derivedBytes) {
					for(var i = 0; i < 32; ++i) {
						privKeyBytes[i] ^= derivedBytes[i];
					}

					// 0x01 0x42 + flagbyte + salt + encryptedhalf1 + encryptedhalf2
					var flagByte = compressed? 0xe0 : 0xc0;
					var encryptedKey = [ 0x01, 0x42, flagByte ].concat(salt);

					var encryptedKey = encryptedKey.concat(Crypto.AES.encrypt(privKeyBytes, derivedBytes.slice(32), AES_opts));

					encryptedKey = encryptedKey.concat(Bitcoin.Util.dsha256(encryptedKey).slice(0,4));

					callback(Bitcoin.Base58.encode(encryptedKey));
				});
			},

			//Thanks to pointbiz for this Javascript implementation
			BIP38DecryptKeyAsync: function (base58Encrypted, passphrase, callback) {
				var hex;
				try {
					hex = Bitcoin.Base58.decode(base58Encrypted);
				} catch (e) {
					callback('Not a valid private key');
					return;
				}

				// 43 bytes: 2 bytes prefix, 37 bytes payload, 4 bytes checksum
				if (hex.length != 43) {
					callback('Not a valid private key');
					return;
				}
				// first byte is always 0x01 
				else if (hex[0] != 0x01) {
					callback('Not a valid private key');
					return;
				}

				var expChecksum = hex.slice(-4);
				hex = hex.slice(0, -4);
				var checksum = Bitcoin.Util.dsha256(hex);
				if (checksum[0] != expChecksum[0] || checksum[1] != expChecksum[1] || checksum[2] != expChecksum[2] || checksum[3] != expChecksum[3]) {
					callback('Not a valid private key');
					return;
				}

				var isCompPoint = false;
				var isECMult = false;
				var hasLotSeq = false;
				// second byte for non-EC-multiplied key
				if (hex[1] == 0x42) {
					// key should use compression
					if (hex[2] == 0xe0) {
						isCompPoint = true;
					}
					// key should NOT use compression
					else if (hex[2] != 0xc0) {
						callback('Not a valid private key');
						return;
					}
				}
				// second byte for EC-multiplied key 
				else if (hex[1] == 0x43) {
					isECMult = true;
					isCompPoint = (hex[2] & 0x20) != 0;
					hasLotSeq = (hex[2] & 0x04) != 0;
					if ((hex[2] & 0x24) != hex[2]) {
						callback('Not a valid private key');
						return;
					}
				} 
				else {
					callback('Not a valid private key');
					return;
				}

				var decrypted;
				var AES_opts = { mode: new Crypto.mode.ECB(Crypto.pad.NoPadding), asBytes: true };

				var verifyHashAndReturn = function (decryptedbytearray) {
					var tmpkey = new Bitcoin.ECKey(decryptedbytearray); // decrypted using closure
					tmpkey.setCompressed(isCompPoint);
					var base58AddrText = tmpkey.getBitcoinAddress(); // isCompPoint using closure
					checksum = Bitcoin.Util.dsha256(base58AddrText); // checksum using closure

					if (checksum[0] != hex[3] || checksum[1] != hex[4] || checksum[2] != hex[5] || checksum[3] != hex[6]) {
						callback('Incorrect passphrase'); // callback using closure
						return;
					}
					else{
						callback(tmpkey); // callback using closure
					}
				};

				if (!isECMult) {
					var addresshash = hex.slice(3, 7);
					Crypto_scrypt(passphrase, addresshash, 16384, 8, 8, 64, function (derivedBytes) {
						var k = derivedBytes.slice(32, 32 + 32);
						decrypted = Crypto.AES.decrypt(hex.slice(7, 7 + 32), k, AES_opts);
						for (var x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];
						verifyHashAndReturn(decrypted);
					});
				} 
				else {
					var ownerentropy = hex.slice(7, 7 + 8);
					var ownersalt = !hasLotSeq ? ownerentropy : ownerentropy.slice(0, 4);
					Crypto_scrypt(passphrase, ownersalt, 16384, 8, 8, 32, function (prefactorA) {
						var passfactor;
						if (!hasLotSeq) { // hasLotSeq using closure
							passfactor = prefactorA;
						} else {
							var prefactorB = prefactorA.concat(ownerentropy); // ownerentropy using closure
							passfactor = Bitcoin.Util.dsha256(prefactorB);
						}
						var kp = new Bitcoin.ECKey(passfactor);
						kp.setCompressed(true);
						var passpoint = kp.getPub();
						
						var encryptedpart2 = hex.slice(23, 23 + 16);

						var addresshashplusownerentropy = hex.slice(3, 3 + 12);
						Crypto_scrypt(passpoint, addresshashplusownerentropy, 1024, 1, 1, 64, function (derived) {
							var k = derived.slice(32);

							var unencryptedpart2 = Crypto.AES.decrypt(encryptedpart2, k, AES_opts);
							for (var i = 0; i < 16; i++) { unencryptedpart2[i] ^= derived[i + 16]; }

							var encryptedpart1 = hex.slice(15, 15 + 8).concat(unencryptedpart2.slice(0, 0 + 8));
							var unencryptedpart1 = Crypto.AES.decrypt(encryptedpart1, k, AES_opts);
							for (var i = 0; i < 16; i++) { unencryptedpart1[i] ^= derived[i]; }

							var seedb = unencryptedpart1.slice(0, 0 + 16).concat(unencryptedpart2.slice(8, 8 + 8));

							var factorb = Bitcoin.Util.dsha256(seedb);

							var ps = EllipticCurve.getSECCurveByName("secp256k1");
							var privateKey = BigInteger.fromByteArrayUnsigned(passfactor).multiply(BigInteger.fromByteArrayUnsigned(factorb)).remainder(ps.getN());

							decrypted = privateKey.toByteArrayUnsigned();
							verifyHashAndReturn(decrypted);
						});
					});
				}
			},

			anyPrivateKeyToByteArray: function (privKey) {
				var keyFormat = ninja.privateKey;
				var bytes = null;
				if (Bitcoin.ECKey.isWalletImportFormat(privKey)) {
					bytes = Bitcoin.Base58.decode(privKey);
					bytes.shift();
					bytes = bytes.slice(0, bytes.length - 4);
				}
				else if (Bitcoin.ECKey.isCompressedWalletImportFormat(privKey)) {
					bytes = Bitcoin.Base58.decode(privKey);
					bytes.shift();
					bytes.pop();
					bytes = bytes.slice(0, bytes.length - 4);
				}
				else if (Bitcoin.ECKey.isHexFormat(privKey)) {
					bytes = Crypto.util.hexToBytes(privKey);
				}
				else if (Bitcoin.ECKey.isBase64Format(privKey)) {
					bytes = Crypto.util.base64ToBytes(privKey);
				}
				else if (Bitcoin.ECKey.isMiniFormat(privKey)) {
					bytes = Crypto.SHA256(privKey, { asBytes: true });
				}

				if (bytes != null && bytes.length != 32) {
					bytes = null;
				}
				return bytes;
			}
		};

		ninja.publicKey = {
			isPublicKeyHexFormat: function (key) {
				key = key.toString();
				return ninja.publicKey.isUncompressedPublicKeyHexFormat(key) || ninja.publicKey.isCompressedPublicKeyHexFormat(key);
			},
			// 130 characters [0-9A-F] starts with 04
			isUncompressedPublicKeyHexFormat: function (key) {
				key = key.toString();
				return /^04[A-Fa-f0-9]{128}$/.test(key);
			},
			// 66 characters [0-9A-F] starts with 02 or 03
			isCompressedPublicKeyHexFormat: function (key) {
				key = key.toString();
				return /^0[2-3][A-Fa-f0-9]{64}$/.test(key);
			},
			getBitcoinAddressFromByteArray: function (pubKeyByteArray) {
				var pubKeyHash = Bitcoin.Util.sha256ripe160(pubKeyByteArray);
				var addr = new Bitcoin.Address(pubKeyHash);
				return addr.toString();
			},
			getHexFromByteArray: function (pubKeyByteArray) {
				return Crypto.util.bytesToHex(pubKeyByteArray).toString().toUpperCase();
			},
			getByteArrayFromAdding: function (pubKeyHex1, pubKeyHex2) {
				var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
				var curve = ecparams.getCurve();
				var ecPoint1 = curve.decodePointHex(pubKeyHex1);
				var ecPoint2 = curve.decodePointHex(pubKeyHex2);
				// if both points are the same return null
				if (ecPoint1.equals(ecPoint2)) return null;
				var compressed = (ecPoint1.compressed && ecPoint2.compressed);
				var pubKey = ecPoint1.add(ecPoint2).getEncoded(compressed);
				return pubKey;
			},
			getByteArrayFromMultiplying: function (pubKeyHex, ecKey) {
				var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
				var ecPoint = ecparams.getCurve().decodePointHex(pubKeyHex);
				var compressed = (ecPoint.compressed && ecKey.compressed);
				// if both points are the same return null
				ecKey.setCompressed(false);
				if(ecPoint.equals(ecKey.getPubPoint())) {
					return null;
				}
				var bigInt = ecKey.priv;
				var pubKey = ecPoint.multiply(bigInt).getEncoded(compressed);
				return pubKey;
			},
			// used by unit test
			getDecompressedPubKeyHex: function (pubKeyHexComp) {
				var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
				var ecPoint = ecparams.getCurve().decodePointHex(pubKeyHexComp);
				var pubByteArray = ecPoint.getEncoded(0);
				var pubHexUncompressed = ninja.publicKey.getHexFromByteArray(pubByteArray);
				return pubHexUncompressed;
			}
		};
	</script>

	<script type="text/javascript">
		ninja.seeder = {
			// number of mouse movements to wait for
			seedLimit: (function () {
				var num = Crypto.util.randomBytes(12)[11];
				return 50 + Math.floor(num);
			})(),

			seedCount: 0, // counter

			// seed function exists to wait for mouse movement to add more entropy before generating an address
			seed: function (evt) {
				if (!evt) var evt = window.event;

				// seed a bunch (minimum seedLimit) of times based on mouse moves
				SecureRandom.seedTime();
				// seed mouse position X and Y
				if (evt) SecureRandom.seedInt((evt.clientX * evt.clientY));

				ninja.seeder.seedCount++;
				// seeding is over now we generate and display the address
				if (ninja.seeder.seedCount == ninja.seeder.seedLimit) {
					opw.ui.nextStep();
				}
			},

			// If user has not moved the mouse or if they are on a mobile device
			// we will force the generation after a random period of time.
			forceGenerate: function () {
				// if the mouse has not moved enough
				if (ninja.seeder.seedCount < ninja.seeder.seedLimit) {
					SecureRandom.seedTime();
					ninja.seeder.seedCount = ninja.seeder.seedLimit - 1;
					ninja.seeder.seed();
				}
			}
		};

		ninja.qrCode = {
			// determine which type number is big enough for the input text length
			getTypeNumber: function (text) {
				var lengthCalculation = text.length * 8 + 12; // length as calculated by the QRCode
				if (lengthCalculation < 72) { return 1; }
				else if (lengthCalculation < 128) { return 2; }
				else if (lengthCalculation < 208) { return 3; }
				else if (lengthCalculation < 288) { return 4; }
				else if (lengthCalculation < 368) { return 5; }
				else if (lengthCalculation < 480) { return 6; }
				else if (lengthCalculation < 528) { return 7; }
				else if (lengthCalculation < 688) { return 8; }
				else if (lengthCalculation < 800) { return 9; }
				else if (lengthCalculation < 976) { return 10; }
				return null;
			},

			createCanvas: function (text, sizeMultiplier) {
				sizeMultiplier = (sizeMultiplier == undefined) ? 2 : sizeMultiplier; // default 2
				// create the qrcode itself
				var typeNumber = ninja.qrCode.getTypeNumber(text);
				var qrcode = new QRCode(typeNumber, QRCode.ErrorCorrectLevel.H);
				qrcode.addData(text);
				qrcode.make();
				var width = qrcode.getModuleCount() * sizeMultiplier;
				var height = qrcode.getModuleCount() * sizeMultiplier;
				// create canvas element
				var canvas = document.createElement('canvas');
				var scale = 10.0;
				canvas.width = width * scale;
				canvas.height = height * scale;
				//canvas.style.width = width + 'px';
				//canvas.style.height = height + 'px';
				canvas.style.width = '100%';
				canvas.style.height = '100%';
				var ctx = canvas.getContext('2d');
				ctx.scale(scale, scale);
				// compute tileW/tileH based on width/height
				var tileW = width / qrcode.getModuleCount();
				var tileH = height / qrcode.getModuleCount();
				// draw in the canvas
				for (var row = 0; row < qrcode.getModuleCount(); row++) {
					for (var col = 0; col < qrcode.getModuleCount(); col++) {
						ctx.fillStyle = qrcode.isDark(row, col) ? "#000000" : "#ffffff";
						ctx.fillRect(col * tileW, row * tileH, tileW, tileH);
					}
				}
				// return just built canvas
				return canvas;
			},

			// generate a QRCode and return it's representation as an Html table 
			createTableHtml: function (text) {
				var typeNumber = ninja.qrCode.getTypeNumber(text);
				var qr = new QRCode(typeNumber, QRCode.ErrorCorrectLevel.H);
				qr.addData(text);
				qr.make();
				var tableHtml = "<table class='qrcodetable'>";
				for (var r = 0; r < qr.getModuleCount(); r++) {
					tableHtml += "<tr>";
					for (var c = 0; c < qr.getModuleCount(); c++) {
						if (qr.isDark(r, c)) {
							tableHtml += "<td class='qrcodetddark'/>";
						} else {
							tableHtml += "<td class='qrcodetdlight'/>";
						}
					}
					tableHtml += "</tr>";
				}
				tableHtml += "</table>";
				return tableHtml;
			},

			// show QRCodes with canvas OR table (IE8)
			// parameter: keyValuePair 
			// example: { "class1": "string1", "class2": "string2"}
			//		"class1" is the class of a div element where you want a QRCode inserted.
			//		"string1" is the string you want encoded into the QRCode.
			showQrCode: function (keyValuePair, sizeMultiplier) {
				for (var key in keyValuePair) {
					var value = keyValuePair[key];
					var elements = document.getElementsByClassName(key);

					for (var i = 0; i < elements.length; i++) {
						try {
							elements[i].innerHTML = "";
                            if(opw.paperwallet.stubtype == 'plaintext' && (' ' + elements[i].className + ' ').indexOf(' ' + 'stub_private' + ' ') > -1) elements[i].innerHTML = value;
                            else elements[i].appendChild(ninja.qrCode.createCanvas(value, sizeMultiplier));
						} catch (e) {
							// for browsers that do not support canvas (IE8)
							elements[i].innerHTML = ninja.qrCode.createTableHtml(value);
						}
					}
				}
			}
		};

		ninja.getQueryString = function () {
			var result = {}, queryString = location.search.substring(1), re = /([^&=]+)=([^&]*)/g, m;
			while (m = re.exec(queryString)) {
				result[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
			}
			return result;
		};
	</script>

	<script>
		//Init Open Paper Wallet Functions
		var opw = {paperwallet: {}, designs: {}, ui: {}, alignmentwidget: {}};
		opw.currency = "bitcoin"; //default currency is bitcoin
	</script>

	<script type="text/javascript">
		//Original bitaddress.org functions have been heavily modified and/or with lots more functions added. Thus it's better to rename the core function object.

		opw.paperwallet = {
			remaining: null, // use to keep track of how many addresses are left to process when building the paper wallet
			count: 0,
			numPages: 1,
			pageBreakAt: 4, // number of notes per page
			show_alias: true, // variable to show alias or not
			wallet_details: [], // fill this with details for showWallet and export to CSV
			invalid_keys: false, // variable to check if everything is good with keys
			wallet_design_id: 0, // reference the chosen wallet design
			encryptkeys: false, // does the user want to encrypt the keys or not
            stubtype: 'qrcode', // how do you want to print the private key in the stub? default is qrcode

			savePageNumber: function(){
				var pages = document.getElementById("paperlimit").value;
				opw.paperwallet.numPages = pages;
			},

      setStubType: function(){
          opw.paperwallet.stubtype = document.getElementById('selectstubtype').value;
      },

			setCurrency: function(currency){
				if(currency) opw.currency = currency;
				else opw.currency = document.getElementById("selectcurrency").value;

				if(opw.currency == 'bitcoin'){
					Bitcoin.ECKey.privateKeyPrefix = 0x80;
					Bitcoin.Address.networkVersion = 0x00;
				}
				if(opw.currency == 'litecoin'){
					Bitcoin.ECKey.privateKeyPrefix = 0xb0;
					Bitcoin.Address.networkVersion = 0x30;
				}
				
			},

			showCurrentCurrency: function(){
				document.getElementById(opw.currency+"option").setAttribute('selected', 'selected');
			},

			build: function () {
				if (numPages < 1) numPages = 1;
				numPages = opw.paperwallet.numPages;
				opw.paperwallet.remaining = numPages * opw.paperwallet.pageBreakAt;
				opw.paperwallet.count = 0;
				document.getElementById("paperkeyarea").innerHTML = "";
				setTimeout(opw.paperwallet.batch, 0);
			},

			startGeneration: function(){
				numPages = opw.paperwallet.numPages;
				if (numPages < 1) numPages = 1;
				opw.paperwallet.remaining = numPages * opw.paperwallet.pageBreakAt;
				opw.paperwallet.count = 0;
				document.getElementById("paperwalletdetailskeys").innerHTML = "";
				setTimeout(opw.paperwallet.batchGenerate, 0);
			},

			startSeed: function(){
				document.body.setAttribute('onmousemove', 'ninja.seeder.seed(event)');
			},

			batch: function () {
				if (opw.paperwallet.remaining > 0) {
					var paperArea = document.getElementById("paperkeyarea");
					opw.paperwallet.count++;
					var i = opw.paperwallet.count;
					var pageBreakAt = opw.paperwallet.pageBreakAt;
					var div = document.createElement("div");
					div.setAttribute("id", "keyarea" + i);
					div.innerHTML = opw.paperwallet.templateHtml(i);
					div.setAttribute("class", "keyarea");
					img = document.createElement('img');
					img.setAttribute("class", "wallet-background");
					img.src = opw.designs[opw.paperwallet.wallet_design_id].source;
					div.appendChild(img);

					if (paperArea.innerHTML != "") {
						// page break
						if (i % pageBreakAt == 1 && opw.paperwallet.count >= pageBreakAt) {
							var pBreak = document.createElement("div");
							pBreak.setAttribute("class", "pagebreak");
							document.getElementById("paperkeyarea").appendChild(pBreak);
							div.className = "first " + div.className;
						}
					}
					document.getElementById("paperkeyarea").appendChild(div);
					opw.paperwallet.showWallet(i);
					opw.paperwallet.remaining--;
					setTimeout(opw.paperwallet.batch, 0);
				}
				else{
					ninja.print(); //When generation finishes
					//document.getElementById("paperkeyarea").innerHTML = ''; //Clear the wallet area
				}
			},

			batchGenerate: function(){
				if(opw.paperwallet.remaining > 0) {
					var detail_area = document.getElementById("paperwalletdetailskeys");
					opw.paperwallet.count++;
					var i = opw.paperwallet.count;

					var div = document.createElement('div');
					div.innerHTML = opw.paperwallet.templateWalletDetailsHtml(i);
					detail_area.appendChild(div);

					opw.paperwallet.generateNewWallet(i);
					opw.paperwallet.remaining--;
					setTimeout(opw.paperwallet.batchGenerate, 0);
				}
				if(opw.paperwallet.remaining == 0) opw.paperwallet.validateKeys();
			},

			// Generate addresses and private keys
			generateNewWallet: function (idPostFix) {
				var key = new Bitcoin.ECKey(false);
				opw.paperwallet.wallet_details[idPostFix] = {
					bitcoinAddress: key.getBitcoinAddress(),
					privateKeyWif: key.getBitcoinWalletImportFormat(),
					alias: opw.paperwallet.generateAlias(key.getBitcoinAddress()),
				}
				opw.paperwallet.showWalletDetails(idPostFix);
			},

			generateAlias: function(bitcoinAddress){
				var adjectives = ['ADORABLE', 'AGILE', 'BOSSY', 'CANDID', 'CLEVER', 'COLD', 'COLORFUL', 'CUDDLY', 'CURIOUS', 'CUTE', 'DEADLY', 'DOMESTIC', 'DOMINANT', 'FAST', 'FEISTY', 'FIERCE', 'FLUFFY', 'FRIENDLY', 'FURRY', 'FUZZY', 'GRUMPY', 'HAIRY', 'HEAVY', 'JEALOUS', 'LARGE', 'LAZY', 'LOUD', 'LOVABLE', 'LOVING', 'MEAN', 'MESSY', 'NOISY', 'NOSY', 'PICKY', 'PLAYFUL', 'QUICK', 'ROUGH', 'SASSY', 'SCALY', 'SHORT', 'SHY', 'SLIMY', 'SLOW', 'SMALL', 'SMART', 'SMELLY', 'SOFT', 'SPIKEY', 'STINKY', 'STRONG', 'STUBBORN', 'TALL', 'TAME', 'TENACIOUS', 'TINY', 'VICIOUS', 'WARM', 'WILD'];

                var colors = ['AMBER', 'AMETHYST', 'AQUA', 'AZURE', 'BLACK', 'BLUE', 'BRONZE', 'BURGUNDY', 'CANARY', 'CHESTNUT', 'CHOCOLATE', 'CHROME', 'COBALT', 'COPPER', 'CREAM', 'CRIMSON', 'CYAN', 'DRAB', 'DULL', 'EBONY', 'EMERALD', 'FUCHSIA', 'GOLD', 'GREEN', 'HENNA', 'INDIGO', 'IVORY', 'JADE', 'KHAKI', 'LAVENDER', 'LEMON', 'LILAC', 'LIME', 'MAGENTA', 'MAHOGANY', 'MAROON', 'MAUVE', 'MUSTARD', 'NAVY', 'OLIVE', 'ORANGE', 'PEACH', 'PINK', 'PURPLE', 'RED', 'ROSE', 'RUBY', 'RUST', 'SAFFRON', 'SAPPHIRE', 'SCARLET', 'SILVER', 'TAN', 'TOPAZ', 'TURQUOISE', 'VIOLET', 'WHITE', 'YELLOW'];

				var animals = ['ALLIGATOR', 'ANACONDA', 'ANTELOPE', 'BEAR', 'BEAVER', 'BEETLE', 'BIRD', 'CAMEL', 'CAT', 'CHICKEN', 'COBRA', 'CROW', 'DOLPHIN', 'DONKEY', 'DUCK', 'EAGLE', 'EEL', 'ELEPHANT', 'FERRET', 'FLEA', 'FOX', 'FROG', 'GIRAFFE', 'GOAT', 'GORILLA', 'HAMSTER', 'HIPPO', 'HORSE', 'HYENA', 'IGUANA', 'JAGUAR', 'KANGAROO', 'KIWI', 'LEOPARD', 'LION', 'LOBSTER', 'MEERKAT', 'MONKEY', 'MOUSE', 'NARWHAL', 'OCTOPUS', 'ORCA', 'OWL', 'PELICAN', 'PENGUIN', 'PIG', 'QUAIL', 'RABBIT', 'RAT', 'RHINO', 'SCORPION', 'SEAL', 'TIGER', 'TUNA', 'VIPER', 'WALRUS', 'WHALE', 'ZEBRA'];

				var base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
				var alias_seed = bitcoinAddress.substring(1,4);
				var alias = [];

				var i=0;
				for(; i<alias_seed.length; i++){
					var character = alias_seed.substr(i, 1);
					var index = base58.indexOf(character);
					if(i == 0) alias.push(adjectives[index]);
					if(i == 1) alias.push(colors[index]);
					if(i == 2) alias.push(animals[index]);
				}
				return alias;
			},

			toggleAlias: function(){
				opw.paperwallet.show_alias = !opw.paperwallet.show_alias;
			},

			exportToCSV: function(){
				var csvContent = "data:text/csv;charset=utf-8,";
				var csv = 'label,public address';

				for(var i = 1; i < opw.paperwallet.wallet_details.length; i++){
					var alias = opw.paperwallet.wallet_details[i].alias;
					var alias_full = alias[0] + " " + alias[1] + " " + alias[2];
					var address = opw.paperwallet.wallet_details[i].bitcoinAddress;
					csv = csv +'\n'+ alias_full + "," + address;
				}

				var encoded = encodeURI(csvContent+csv);
				window.open(encoded);
			},

			showWalletDetails: function(idPostFix){
				//Show Alias
				var alias = opw.paperwallet.wallet_details[idPostFix].alias;
				var alias_full = alias[0] + " " + alias[1] + " " + alias[2];
				var elements = document.getElementsByClassName("aliasdetail" + idPostFix);
				for (var i = 0; i < elements.length; i++) {
					elements[i].innerHTML = alias_full + ": ";
				}

				//Show Bitcoin Address
				var bitcoinAddress = opw.paperwallet.wallet_details[idPostFix].bitcoinAddress;
				var elements = document.getElementsByClassName("addressdetail" + idPostFix);
				for (var i = 0; i < elements.length; i++) {
					elements[i].innerHTML = bitcoinAddress;
				}

				//Show Private Key
				var privateKeyWif = opw.paperwallet.wallet_details[idPostFix].privateKeyWif;
				var elements = document.getElementsByClassName("privatekeydetail" + idPostFix);
				for (var i = 0; i < elements.length; i++) {
					elements[i].value = privateKeyWif;
				}
			},

			validateKeys: function(){
				opw.paperwallet.invalid_keys = false; //Assume everything is fine
				var keypairs = [];

				//Reset Errors
				var reset_errors = document.getElementsByClassName('errors');
				for(var i = 0; i < reset_errors.length; i++){
					reset_errors[i].innerHTML = '';
				}

				//Get the keys from the inputs and validate keys.
				var keys = document.getElementsByClassName('keypair');
				var i = 1;
				for(; i < keys.length+1; i++){
					var div = document.getElementsByClassName('keypair'+i)[0];

					keypairs[i] = {error: null};
					keypairs[i].public_address = {string: div.getElementsByClassName('addressdetail'+i)[0].innerHTML, error: null};
					keypairs[i].private_key = {string: div.getElementsByClassName('privatekeydetail'+i)[0].value, error: null};

					if(!ninja.privateKey.isPrivateKey(keypairs[i].private_key.string)){
						keypairs[i].private_key.error = 'Not a valid private key';
						div.getElementsByClassName('addressdetail'+i)[0].innerHTML = "Invalid private key";
						div.getElementsByClassName('aliasdetail'+i)[0].innerHTML = "Invalid private key";
					}
					else{
						opw.paperwallet.wallet_details[i].privateKeyWif = keypairs[i].private_key.string;
						
						var public_address_test = new Bitcoin.ECKey(keypairs[i].private_key.string).getBitcoinAddress();
						opw.paperwallet.wallet_details[i].bitcoinAddress = public_address_test;

						if(public_address_test != keypairs[i].public_address.string){
							div.getElementsByClassName('addressdetail'+i)[0].innerHTML = public_address_test;

							var alias = opw.paperwallet.generateAlias(public_address_test);
							var alias_full = alias[0] + " " + alias[1] + " " + alias[2];
							div.getElementsByClassName('aliasdetail'+i)[0].innerHTML = alias_full;
							opw.paperwallet.wallet_details[i].alias = alias;
						}
					}
				}

				//Check for errors and update page accordingly
				var i = 1;
				for(; i < keys.length+1; i++){
					if(keypairs[i].private_key.error){
						opw.paperwallet.invalid_keys = true;
						document.getElementsByClassName('keypair'+i)[0].getElementsByClassName('errors')[0].innerHTML = " [ ! ]";
						document.getElementsByClassName('keypair'+i)[0].getElementsByClassName('errors')[0].style.color = "red";
					}
					else{
						document.getElementsByClassName('keypair'+i)[0].getElementsByClassName('errors')[0].innerHTML = " [  ]";
						document.getElementsByClassName('keypair'+i)[0].getElementsByClassName('errors')[0].style.color = 'green';
					}
				}
			},

			confirm: function(){
				opw.paperwallet.validateKeys();
				if(!opw.paperwallet.invalid_keys){
					opw.ui.nextStep();
				}
				else{
					alert('One or more private keys are invalid. Make sure you entered them correctly and press confirm again.');
				}
			},

			confirmAndEncrypt: function(){
				opw.paperwallet.validateKeys();
				if(!opw.paperwallet.invalid_keys){
					opw.paperwallet.encryptkeys = true;
					opw.ui.nextStep();
				}
				else{
					alert('One or more private keys are invalid. Make sure you entered them correctly and press confirm again.');
				}
			},

			startEncryption: function(){
				//Validate Passwords
				var passphrase1 = document.getElementById('bippassphrase').value;
				var passphrase2 = document.getElementById('bippassphraseconfirm').value;

				if(passphrase1 == '' || passphrase2 == '') alert('Please enter a passphrase before encrypting.');
				else{
					if(passphrase1 == passphrase2){
						var total_keys = opw.paperwallet.wallet_details.length-1;
						var index = 1;
						encrypt(index);

						function encrypt(index){
							document.getElementById('busyencrypting').innerHTML = "Encrypting... This may take a minute or two. Encrypting key " + index + " of " + total_keys + ".";
							var privatekey = opw.paperwallet.wallet_details[index].privateKeyWif;
							ninja.privateKey.BIP38PrivateKeyToEncryptedKeyAsync(privatekey, passphrase1, false, function(eckey){
								opw.paperwallet.wallet_details[index].privateKeyEnc = eckey;
								index = ++index;
								if(index == total_keys+1) opw.ui.nextStep();
								else encrypt(index);
							});
						};
					}
					else{
						alert('The passphrases do not match. Please type them again.');
					}
				}
			},

			decryptKey: function(){
				document.getElementById('busydecrypting').innerHTML = "Decrypting... give it a few seconds."
				var encryptedkey = document.getElementById('keytodecrypt').value;
				var passphrase = document.getElementById('passphrasetodecrypt').value;

				ninja.privateKey.BIP38DecryptKeyAsync(encryptedkey, passphrase, function(deckey){
					document.getElementById('busydecrypting').innerHTML = '';
					document.getElementById('decryptioninfo').innerHTML = 
						"<div><h4>Key Details:</h4>"+
						"<div class='decryptkeyinfo'><span class='decryptkeyqrcode'></span><span style='text-decoration: underline'>Address: </span><br><span class='decryptkeytext'>"+deckey.getBitcoinAddress()+ "</span></div>" +
						"<div class='decryptkeyinfo'><span class='decryptkeyqrcode'></span><span style='text-decoration: underline'>Private Key - Wallet Import Format: </span><br><span class='decryptkeytext'>"+deckey.getBitcoinWalletImportFormat()+ "</span></div>" +
						"<div class='decryptkeyinfo'><span class='decryptkeyqrcode'></span><span style='text-decoration: underline'>Private Key - Hex Format: </span><br><span class='decryptkeytext'>"+deckey.getBitcoinHexFormat()+ "</span></div>" +
						"<div class='decryptkeyinfo'><span class='decryptkeyqrcode'></span><span style='text-decoration: underline'>Private Key - Base64 Format: </span><br><span class='decryptkeytext'>"+deckey.getBitcoinBase64Format()+ "</span></div>" +
						"</div>";
					var elements = document.getElementsByClassName('decryptkeyqrcode');
					var data = document.getElementsByClassName('decryptkeytext');
					for(var i=0; i<elements.length; i++){
						try {
							elements[i].innerHTML = "";
							var value = data[i].innerHTML;
							elements[i].appendChild(ninja.qrCode.createCanvas(value));
						} catch (e) {
							// for browsers that do not support canvas (IE8)
							elements[i].innerHTML = ninja.qrCode.createTableHtml(value);
						}
					}
				});
			},

			showDesigns: function(){
				var designs = opw.designs;
				var walletsarea = document.getElementById('paperwalletdesignoptions');

				for(var i=0; i < designs.length; i++){
					var div = document.createElement('div');
					if(designs[i].name == "Pre-printed"){
						div.innerHTML = '<span class="wallet-thumbnail wallet-thumbnail-selected wallet-thumbnail-no-design" onclick="opw.paperwallet.selectDesign('+i+')">No background - Can be used for pre-printed paper.</span>';
					}
					else{
						div.innerHTML = '<span><img class="wallet-thumbnail" src='+ designs[i].source +' onclick="opw.paperwallet.selectDesign('+i+')" /></span>';
					}
					walletsarea.appendChild(div);
				}
			},

			selectDesign: function(id){
				var elements = document.getElementsByClassName('wallet-thumbnail');
				for(var i = 0; i < elements.length; i++){
					if(i == id) {
						document.getElementsByClassName('wallet-thumbnail')[i].setAttribute('class', "wallet-thumbnail wallet-thumbnail-selected");
					}
					else{
						document.getElementsByClassName('wallet-thumbnail')[i].setAttribute('class', "wallet-thumbnail");
					}
				}
				opw.paperwallet.wallet_design_id = id;
			},

			templateWalletDetailsHtml: function(i){
				var walletdetailsHtml =
					"<div class='keypair keypair"+ i + "'>" +
						"<span class='aliasdetail aliasdetail"+ i + "'></span><span class='addressdetail addressdetail"+ i +"'></span>"+
						"<input type='password' class='privatekeydetail privatekeydetail"+ i +"'"+
						" onkeypress='opw.paperwallet.validateKeys("+i+")' onblur='opw.paperwallet.validateKeys("+i+")'/>" +
						"<span class='errors'></span>" +
					"</div>";
				return walletdetailsHtml;
			},

			templateHtml: function (i) {
				var walletHtml =
							"<div class='note'>" +
								"<div class='public'>" +
									"<div class='qrcode_public" + i + " qrcode_public'></div>" +
									"<div class='pubaddress'>" +
										"<span class='notes'>Bitcoin address: </span>" +
										"<span class='addressandalias'><span class='output alias alias" + i + "'></span><span class='output btcaddress btcaddress" + i + "'></span></span>" +
									"</div>" +
									"<div class='pubaddressprefix'>" +
										"<span class='output btcaddressprefix" + i + "'></span>" +
									"</div>" +
								"</div>" +
								"<div class='private'>" +
									"<div class='qrcode_private" + i + " qrcode_private note_private'></div>" +
								"</div>" +
							"</div>" +
							"<div class='stub'>" +
								"<div class='public'>" +
									"<div class='qrcode_public" + i + " qrcode_public'></div>" +
									"<div class='pubaddressprefix'>" +
										"<span class='output aliasprefix aliasprefix" + i + "'></span><span class='output btcaddressprefix" + i + "'></span>" +
									"</div>" +
								"</div>" +
								"<div class='private'>" +
									"<div class='qrcode_private" + i + " qrcode_private stub_private'></div>" +
								"</div>" +
							"</div>";
				return walletHtml;
			},

			showWallet: function (idPostFix) {
				var alias = opw.paperwallet.wallet_details[idPostFix].alias;
				var bitcoinAddress = opw.paperwallet.wallet_details[idPostFix].bitcoinAddress;
				var privateKey = opw.paperwallet.wallet_details[idPostFix].privateKeyWif;
				if(opw.paperwallet.encryptkeys) privateKey = opw.paperwallet.wallet_details[idPostFix].privateKeyEnc;

				var addressPrefix = bitcoinAddress.substr(0, 7);
				var alias_full = alias[0] + " " + alias[1] + " " + alias[2];
				var alias_short = alias[0].substring(0,1)+alias[1].substring(0,1)+alias[2].substring(0,1);

				// Assign address prefixes to elements
				var elements = document.getElementsByClassName("btcaddressprefix" + idPostFix);
				for (var i = 0; i < elements.length; i++) {
					elements[i].innerHTML = addressPrefix;
				}

				if(opw.paperwallet.show_alias){
					var elements = document.getElementsByClassName("aliasprefix" + idPostFix);
					for (var i = 0; i < elements.length; i++) {
						elements[i].innerHTML = alias_short + ": ";
					}
				}
				
				// Assign addresses to elements
				var elements = document.getElementsByClassName("btcaddress" + idPostFix);
				for (var i = 0; i < elements.length; i++) {
					elements[i].innerHTML = bitcoinAddress;
				}

				if(opw.paperwallet.show_alias){
					var elements = document.getElementsByClassName("alias" + idPostFix);
					for (var i = 0; i < elements.length; i++) {
						elements[i].innerHTML = alias_full + ": ";
					}
				}

        var keyValuePair = {};
				keyValuePair["qrcode_public" + idPostFix] = "bitcoin:"+bitcoinAddress+"?label="+alias[0]+alias[1]+alias[2];
				keyValuePair["qrcode_private" + idPostFix] = privateKey;
				ninja.qrCode.showQrCode(keyValuePair);
				document.getElementById("keyarea" + idPostFix).style.display = "block";
			},

			spendAllCoinsFromWIFPrivateKeyToAddress: function(){
				var private_key = document.getElementById('privatekeytosendcoinsfrom').value;
				var address_destination = document.getElementById('addresstosendcoins').value;

				try{
					var addr = new Bitcoin.Address(address_destination);
					if(ninja.privateKey.isPrivateKey(private_key)){
						var eckey = new Bitcoin.ECKey(private_key);
						if(window.confirm('Do you want to send all the coins from ' + eckey.getBitcoinAddress() + ' to ' + address_destination + '?')){
							TX.init(eckey);
							tx_fetch('http://blockchain.info/unspent?address='+eckey.getBitcoinAddress(), parseInputs);
						}
					}
					else{
						alert('Not a valid private key.');
					}
				}
				catch (e){
					alert('Address not valid');
				}

				function parseInputs(unspent){
					TX.parseInputs(unspent, TX.getAddress());

					getBalance(TX.getAddress(), function(balance){
						if(balance > 5430){
							var fee = parseFloat(document.getElementById('feeforsending').value);
							var total_coins = parseFloat((balance-(fee*100000000))/100000000);
							TX.addOutput(address_destination, total_coins);
							var sendTx = TX.construct();
							var txJSON = TX.toBBE(sendTx);
							var buf = sendTx.serialize();
							var txHex = Crypto.util.bytesToHex(buf);

							var r = '';
							var url = 'http://blockchain.info/pushtx';
			        var postdata = '?tx=' + txHex;
			        if(url != null && url != "") {
			        	var xhr = new XMLHttpRequest();
			        	xhr.onreadystatechange = function(){
			        		if (xhr.readyState == 4) {
			        			alert("Transaction sent");
			        		}
			        	};

			        	try{
			        		xhr.open("POST", url+postdata, true);
			        		xhr.send();
			        	}
			        	catch(e){
			        		throw e;
			        	}
			        }
						}
						else{
							alert('There are too few coins in your address. Add more more coins first to prevent it from being stuck in the network');
						}
						
					});
				}

				function getBalance(address, callback){
					tx_fetch('http://blockchain.info/q/addressbalance/'+address+"?confirmations=1", function(balance){
						callback(balance);
					});
				}
			}
		};
	</script>

	<script type="text/javascript">
		var x = y = offsetX = offSetY = 0,
    dragged, lastDragged, lastZIndex, dropPosition,
    imageScale = 1;

		var initialHeight,
    initialWidth,
    initialLeft,
    initialTop;

		opw.alignmentwidget = {
			main: '',
			mmX: '',
			mmY: '',
			mouse: '',

			init: function(){
				if(opw.paperwallet.wallet_design_id == 0){
					opw.alignmentwidget.main = document.getElementById('paperwalletdesignaligment');
					opw.alignmentwidget.mmX = document.getElementById('paperhorizontaloffset');
					opw.alignmentwidget.mmY = document.getElementById('paperverticaloffset');
					opw.alignmentwidget.mouse = opw.alignmentwidget.mouseInit();
					opw.alignmentwidget.addImage();
				}
			},

			mouseInit: function(){
				var main = opw.alignmentwidget.main;
				var mmX = opw.alignmentwidget.mmX;
				var mmY = opw.alignmentwidget.mmY;

				var _parseInt = function (n) {
				  n = parseInt(n, 10);
				  return n == null || isNaN(n) ? 0 : n;
				};

				var _hasClass = function (element, className) {
				  return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
				};

				var mousedown = function (e) {
				  var target;

				  e = e || window.event;
				  target = e.target !== null ? e.target : e.srcElement;

				  if ((e.button == 1 && window.event != null || e.button == 0) && _hasClass(target, "drag")) {
			      x = e.clientX;
			      y = e.clientY;
			      offsetX = _parseInt(target.style.left);
			      offsetY = _parseInt(target.style.top);

			      // bring the clicked element to the front while it is being dragged
			      lastZIndex = target.style.zIndex;
			      target.style.zIndex = 10000;
			      
			      // we need to access the element in OnMouseMove
			      dragged = target;

			      // tell our code to start moving the element with the mouse
			      document.onmousemove = mousemove;
			      
			      // cancel out any text selections
			      document.body.focus();

			      // prevent text selection in IE
			      document.onselectstart = function () { return false; };
			      // prevent IE from trying to drag an image
			      target.ondragstart = function() { return false; };
			      
			      // prevent text selection (except IE)
			      return false;
				  }
				};

				var mouseup = function (e) {
				  if (dragged != null) {
				    dragged.style.zIndex = lastZIndex;

				    document.onmousemove = null;
				    document.onselectstart = null;
				    dragged.ondragstart = null;

				    lastDragged = dragged;
				    dragged = null;

				    lastDragged.style.left = lastDragged.style.left === "" ? 0 : lastDragged.style.left;
				    lastDragged.style.top = lastDragged.style.top === "" ? 0 : lastDragged.style.top;

				    var lastDraggedPosition = {
				        x: lastDragged.style.left,
				        y: lastDragged.style.top,
				        mmX: (parseInt(lastDragged.style.left, 10) * 0.264583333).toFixed(3),
				        mmY: (parseInt(lastDragged.style.top, 10) * 0.264583333).toFixed(3)
				    };

				    lastDraggedPosition;

				    initialLeft = lastDragged.style.left;
				    initialTop = lastDragged.style.top;

				    setInputs(lastDraggedPosition);
					}
				};

				var mousemove = function (e) {
				  e = e || window.event;

				  // limit the box
				  if ((offsetX + e.clientX - x) > dragged.width/ 2) {
				      dragged.style.left = dragged.width / 2 + 'px';
				  } else if ((offsetX + e.clientX - x) < -dragged.width / 2) {
				      dragged.style.left = -dragged.width / 2 + 'px';
				  } else {
				      dragged.style.left = (offsetX + e.clientX - x) + 'px';
				  }

				  if ((offsetY + e.clientY - y) > dragged.height / 2) {
				      dragged.style.top = dragged.height / 2 + 'px';
				  } else if ((offsetY + e.clientY - y) < -dragged.height / 2) {
				      dragged.style.top = -dragged.height / 2 + 'px';
				  } else {
				      dragged.style.top = (offsetY + e.clientY - y) + 'px';  
				  }

				  var position = {
				      x: dragged.style.left,
				      y: dragged.style.top,
				      mmX: (parseInt(dragged.style.left, 10) * 0.264583333).toFixed(3),
				      mmY: (parseInt(dragged.style.top, 10) * 0.264583333).toFixed(3)
				  };

				  initialLeft = dragged.style.left;
				  initialTop = dragged.style.top;

				  setInputs(position);
				};

				var setInputs = function (position) {
					// inverted coordinate system for print
				  mmX.value = -position.mmX;
				  mmY.value = -position.mmY;
				};

				return {
				  down: mousedown,
				  up: mouseup
				};
			},
			
			addImage: function(){

				var barcode = new Image(),
		        box = document.createElement('div');
		        box.id = 'barcode-box';
		    var scale = imageScale;
		    barcode.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALIAAACxCAIAAADvfHCRAAAXh2lDQ1BJQ0MgUHJvZmlsZQAAeAGtWXc81f/3f73fd3Hda+957ZW9995kZpZ17e3aIyFkRSgJpagkFSkzK0WJJEWlZSSRSkMU8ntTfb6fP77f/37vx+O+30/ndc55ndfrvMY5BwAc170iIkJgegBCw6Ipdib6JGcXVxLuJYABETAAfsDhRY6K0LOxsQT/8/k+AaDtxkdS27r+J9t/b2Dw8Y0iAwDZIM3ePlHkUARfBwBuIUdQogFAb+sTjIuO2MZHEMxMQQxE8Nlt7P8bt21j7994eIfHwc4A4ZkCgIrg5UXxB4CwhNBJsWR/RA+RAACWMcwnMAwAJhKCtckBXj4AcHgiPLtCQ8O3cT6Cxbz/pcf/X9jLy/sfnV5e/v/g32NBJJGODQOjIkK8Enb++P98hYbEIPO187Aib0JEtL4d8mVH5o09MNrMAcHMCJYNiDHd8wcbJgY4OG3zInTnMO/d1ghmRLAPOcoAmUuA6IFig8MttvVs8+T7+BoaIRhZFVBZVKz9X3whMcBg9x8e5yAv822f0SI8bV4UBP3udyAi2mbbhm2dk2Ehuy3/4GU/ivG2foQOY32jjOwRjNgAc0dTHLbpiM2wtF+gsRmCkX5h/YiQnTW3zWNHibHbHosQgn18w/b8lc328TK0QOjcCL0cWAIDYAhIyDschCA/CggEPsj3L538L7o9SAQfQBjwBVGIxA6HR2A65S8GxsALkfdH2qX+yOvvUHxBLCK1+ZdvZKl16S/+I+P9j4QxeLOj448G2XrZBdmNv9wkur92YY2whlhTrDFW/C8F6en3KCg79lkgo/EFMYguX6Tvv/b8e1Qx/3D8m/p7Dux2pIIRjsC/fQPHHcsC/9Fl8c/M/JkLtAhaHq2E1kdrobXRaoCEZkVzAim0IloVrYfWQWsgbWr/muc/Un/slwJ+O3MVu2N9MHiLWI7s6mjf+GjEV8AgPCKBEugfEE3SQ04L310kszCy9C6SvKycAtg+e7Z5APhqt3OmQKwP/kMLlwNAbfusOPgfmudHAFqDkO3G+B+aSCsAdPIADB4nx1Bif+tDb38wAA/okJXGAXiBIBBDxi8PlIEG0AVGwBxYAwfgAtwBGQQg9lJAHEgGaSAL5IEj4BgoB1WgBlwAl0ETaAWd4CYYAENgFIyD52AKzIH3YBl8B+sQBOEgIsQEcUB8kDAkCclDqpA2ZARZQnaQC+QJ+UNhUAyUDB2E8qBiqBw6A9VBV6F26CY0CD2EnkHT0AL0BfoJo2ACzAzzwCKwDKwK68EWsAO8D/aHI+FEOAMugMvgavgS3ALfhIfgcXgKfg+voACKBsWK4kdJoVRRBihrlCvKD0VBpaByUaWoatQVVAfqDuoRagq1hPqBxqKZ0CS0FOJLU/QeNBkdiU5B56PL0RfQLejb6EfoafQy+heGiOHGSGLUMWYYZ4w/Jg6ThSnFnMc0Y/ox45g5zHcsFsuKFcWqIOvXBRuETcLmY09iG7C92IfYWewKDofjwEnitHDWOC9cNC4LdwJ3CdeDG8PN4daoaKj4qOSpjKlcqcKo0qlKqS5SdVONUc1TrVPTUwtTq1NbU/tQJ1AXUp+l7qB+QD1HvY5nwIvitfAO+CB8Gr4MfwXfj3+B/0pDQyNAo0ZjSxNIk0pTRtNIc5dmmuYHgZEgQTAg7CXEEAoItYRewjPCVyKRKELUJboSo4kFxDriLeIr4hotE600rRmtD+0B2graFtox2o901HTCdHp07nSJdKV01+ge0C3RU9OL0BvQe9Gn0FfQt9M/oV9hYGKQY7BmCGXIZ7jIMMjwjhHHKMJoxOjDmMFYw3iLcZYJxSTIZMBEZjrIdJapn2mOGcssymzGHMScx3yZeYR5mYWRRZHFkSWepYKli2WKFcUqwmrGGsJayNrEOsH6k42HTY/Nly2H7QrbGNsqOxe7Lrsvey57A/s4+08OEocRRzBHEUcrx0tONKcEpy1nHOcpzn7OJS5mLg0uMlcuVxPXJDfMLcFtx53EXcM9zL3Cw8tjwhPBc4LnFs8SLyuvLm8Q71Hebt4FPiY+bb5AvqN8PXyLJBaSHimEVEa6TVrm5+Y35Y/hP8M/wr8uICqwRyBdoEHgpSBeUFXQT/CoYJ/gshCfkJVQslC90KQwtbCqcIDwceE7wqsioiJOIodEWkXeibKLmokmitaLvhAjiumIRYpViz0Wx4qrigeLnxQflYAllCQCJCokHkjCksqSgZInJR/uwuxS2xW2q3rXEymClJ5UrFS91LQ0q7SldLp0q/RHGSEZV5kimTsyv2SVZENkz8o+l2OUM5dLl+uQ+yIvIU+Wr5B/rEBUMFY4oNCm8FlRUtFX8ZTiUyUmJSulQ0p9SpvKKsoU5SvKCypCKp4qlSpPVJlVbVTzVe+qYdT01Q6odar9UFdWj1ZvUv+kIaURrHFR452mqKav5lnNWS0BLS+tM1pT2iRtT+3T2lM6/DpeOtU6M7qCuj6653Xn9cT1gvQu6X3Ul9Wn6DfrrxqoG+w36DVEGZoY5hqOGDEa7TEqN3plLGDsb1xvvGyiZJJk0muKMbUwLTJ9YsZjRjarM1s2VzHfb37bgmBhb1FuMWMpYUmx7LCCrcytSqxe7BbeHba71RpYm1mXWL+0EbWJtLlhi7W1sa2wfWsnZ5dsd8eeyd7D/qL9dwd9h0KH53vE9sTs6XOkc9zrWOe46mToVOw05SzjvN95yIXTJdClzRXn6uh63nXFzcjtmNvcXqW9WXsn9onui9836M7pHuLe5UHn4eVxzRPj6eR50XPDy9qr2mvF28y70nuZbEA+Tn7vo+tz1GfBV8u32HfeT8uv2O+dv5Z/if9CgE5AacBSoEFgeeDnINOgqqDVYOvg2uCtEKeQhlCqUM/Q9jDGsOCw2+G84fHhDyMkI7IipiLVI49FLlMsKOejoKh9UW3RzEiQNxwjFpMZMx2rHVsRuxbnGHctniE+LH44QSIhJ2E+0TjxXBI6iZzUl8yfnJY8vV9v/5kUKMU7pe+A4IGMA3OpJqkX0vBpwWn302XTi9O/HXQ62JHBk5GaMZtpklmfRZtFyXpySONQVTY6OzB7JEch50TOr1yf3Ht5snmleRv55Px7h+UOlx3eKvArGClULjx1BHsk7MhEkU7RhWKG4sTi2RKrkpajpKO5R78d8zg2WKpYWnUcfzzm+FSZZVnbCaETR05slAeUj1foVzRUclfmVK6e9Dk5dkr31JUqnqq8qp+nA08/PWNypqVapLq0BlsTW/P2rOPZO+dUz9Wd5zyfd36zNqx26oLdhdt1KnV1F7kvFtbD9TH1C5f2Xhq9bHi57YrUlTMNrA15jaAxpnHxqufViSaLpr5rqteuXBe+XtnM1JzbArUktCy3BrROtbm0PWw3b+/r0OhoviF9o7aTv7Oii6WrsBvfndG91ZPYs9Ib0bt00//mbJ9H3/Nbzrce37a9PdJv0X93wHjg1h29Oz13te52DqoPtt9Tvdc6pDzUMqw03Hxf6X7ziPJIywOVB22jaqMdDzUfdo/pjN18ZPho4LHZ46Hx3eMPJ/ZMPH2y98nUU5+n756FPPs8GTu5/jz1BeZF7kv6l6WvuF9VvxZ/3TClPNU1bTg9PGM/83yWPPv+TdSbjbmMt8S3pfN883Xv5N91LhgvjC66Lc69j3i/vpT1geFD5Uexj9c/6X4aXnZenvtM+bz1Jf8rx9fab4rf+lZsVl59D/2+vpq7xrF24Yfqjzs/nX7Or8dt4DbKNsU3O35Z/HqxFbq1FeFF8dqJBVDIG/bzA+BLLZILuCA5wCgAeNrfucEOBwAoCOFBMA6JFMyRCGAWkkDu7V6YA46GJ1FmqFtoE/RjTCiWAduHS6bSpsZRv8S301QSCom1tC/o6RksGHOYBlkYWPeyXeJAc3pxdfGQePP51vh9BCaFdgsPisqIFYi/lzTbVSX1XcZA9rDcqAJRUV8pSrlSpVd1Sm1Tg01TUktN20jHTpesF6WfYXDcsN6ox/iRyYLpljmLxS5LAyu33YHWsTaZtsV2Vfb1Dq3Irh9yGnN+5vLaddbt3d4P+965v/AY8ezxavA+RT7sk+jr52frrxEgFEgb+D3odfBASF3o4bCIcPsIlUjOyA3Kq6je6JqYzFi/OLN4yQR8wmLicFJjctn+jJS4A5GplLTE9NyDZzK6Ml8fos7WzInIrcmbOIwv0CwMPXKqaKR48+iuY26lucdbyqbKaSqUKj1O5pxqqnp+Bl0tVeN49sC5C+cf1q7VkS5a1idfarr8uUG9sfDqp2tu1x+0WLc+btfsiL5R1/mim6ZHodfxZmRf5q2i26X9pQNFd7LvHhw8dO/w0OHhzPvRI04PpB+sj/Y+TBpTHvv+6Mnj9vHyif1PPJ7qPxOepJ788Pzhi+aX5a/2v/acMpwWn6Gf+TH79s3E3ODbm/M33rUvtC+ee1+wFPvB/aPRJ8ll+uWVz5Nfur+e+Za5EvDdYlVmjWlt9ceLn73r1RsZm76/DLcEtrYQ/2MBJxIdxoN+JKKzhI5Ar2EFJPb6ivJATSBR00tMBJYW24rzpeKkmqSuxPvT6BO0iA60AXSp9KcZbjIuMLOwGLImsDWwf+KU5qJwd/LS8DmSLvJvCeoJpQn3iGyIqYgHSZyUHNr1RZpFRkHWVM5N3l8hUjFBab9yokqQqpuapbqWhqymgBaLNpX2T50PutN64/r3DLoNrxnVGpeZZJvGmQWYu1iYWqpaie5msUZbf7OZsX1o12vf6HBqT7ZjlJO7s5mLgiuPG9btI3LSd7nXeOR6hns5eCuSCeQZn3bfQj8/f80AhoC3gTeCioJ9Q9RD6UJnw1rDsyNcIiWRdTESdTqaEmMQyxI7H9cen5/gniibBCc9SW7Yn5cSemBPqmGaerraQa0M00znrLBDh7LP5dzKnc77dZi7QK3Q8UhU0ZHiSyWDR9+Wwse5y5RP2JaHVuRVXjo5eur7aYEzNtUHa9rPfj4vXRt54Xrdar3apeTL3Q2gUe/qwab+65hmk5bs1jvtuA6jG+mdXV3fekR67W8m9Z26deP2eP/CwOpd9CDTPf4hmWGt+5Yjrg8CRuMeZo0de1T9uGG8c2LwycTTuWffnqNeML8UfqX62nLKf7pmZuGN6Jzr26z5i+/uLEwvri3RfhD+qPPJbTn18+hXhW8lK19X7dau/2Rfz9xY+xW34380UgORALtBKuhF4np1KBpqhWHYCj4Nr6PcUffQmugWjCqmD2uDncUlUXFR3aE+jCfTaBK4CL+IM7RDdM305xjKGAuYspkzWbJY89hK2Ks46jnbuLq4u3i6eXv4ukk3+JsF6gVPCuUJx4jsFdUVExAH4s8lWiXzdjlKkaQWpZtlUmUt5FjlpuXrFWIUdZSolR4pn1QJUFVUXVPrVs/UsNBk1JzUqtYO0pHX2dAd0CvS32cgYbBqeMuo0NjNRNTki2m3Wa65owW/xXvLFqvU3ZbWrNbTNvW2UXYa9rD9PYfiPa6OJMd5pyvOMS4arrDroFvhXvt9rPueuVd47PPk8XzpddJ7H5mbPOlT5uvox+T3wD8vwCgQIOslNlgueCmkNtQ7jDvsSXhJxO5IqsiblMQohail6HMx7rFssQ/iDsXrxK8lNCYGJpGSniUf3e+QwpEyd6At9WhaQrrfwb0ZLpluWb6HYrIzc0pzz+e15A8cHi+YK/xWhCpmKhE4KntMvdTguHmZ7QmXcu+K8MoDJ0tOXaoaOv2pWrgm4ezoedHalAsTF6XqMy49vyLXkN34qkn5Wt711y0KrYfaXnQo3MjtnOnW7Cnr/d7ncKu5X3Tg7F2pwf6h4PtCI0ujd8auPq6baHx6c/LlS/Badrr2TdZ87mLrR7rP2Svsa80bTtv+/10j2r4TsMoAnJsFwPEMALZuANRKAiBcgZQ/kLqFDREABzUA6xcC6NkJAJlc+ef+IAJRpC7gBw4hmeMgeA/RQnLQHigROgl1Qs+hDSS/04G94Sz4IvwA/obiQumhAlBHUO2oGTQNkmN7IhlZG/oNhhGjgwnDnMGMY/FYPWw8tgm7hBPD+eNqcQtU0lQxVD3UNNSu1JfwEN4Z30RDSxNGM0ZQJZwmUhEpxFe05rTtdGJ05fRE+jT6VYZwJF8hM75m8maaZw5l/s6SxkrLepJNhu0Wuxv7CkcRpxznI644bh7uUZ5DvPp8gO8mKZPfSoBD4J3gDaEi4SARY1FhMYLYiviMxJjk7V0dUtekG2UaZJvk2uR7FYYUXyl9VkGrsqgJqktpyGnKaklok3QYdWHdT3rP9XsMqg2zjcKNnU30TWXMeM3pLFAWa5bLVou756xnbKZt39i9t//qsOlI7cTmLOqi5mrlRt6btO+YeyNyj33wpiUr+Lj4HvCr8e8PmA3cDGYM4Q+VCJMOl4oQjxSgsEZRR/2MXojljLOKz0joSfyVbLS/JOV9qlXajYOKGe1ZZodmcw7l8edfKdAtnCoqKnE+pnXc7ERcRf8prtO01XDNj3Nfaj/WLdUvXf7UsHJ18zpVC1ebTIdhp0t3YG9sX8rt1IH9d2PvhQx7juSNto0tjvM/2fes6vnbV3JTaTPjc5Lz2QvzSyYfL36m/5q08mHN7+f8ZsTO+UEHpIEtUrspBz3gDUSDVAPcoAwk4x+CPiHZvTrsCWfDjfAzFArJ2V1QmairqNdoInKqBKMr0PeR/FsO44OpRPxOh7XE5mDv4vA4K1wxbpJKmIpC1UfNSh1CPYAXxKfj52jMaToIkoQqIgsxnxZLm04H6NLoUfTZDLQMxxkFGBuYdJnGmUNZsCzVrHqsM2xZ7FLsExxpnLKcU1wl3KY8aJ4+3oN8xiQCaYK/WiBK0FiIV2hNeEKkVfS02HHxIokCyYJdxVLl0udlmmXvyr2SX1VkUVJXJqsUqHapfdIQ1vTQqtB+rsur56PfYLBuZGScZzJkhjFXsfC2zLI6v/um9aTNsh3antVBYo+uo4tTlHOhyxXXEbfP+1jdtTz8PIu8ur0/+gj6OvsV+g8EbAYpBgeGnAp9GA5HyEd6UgqibkS/i6WLU4n3TMhLbEua38+WYnZgf2pT2uJBwYx9meVZT7PZclxyT+W9OSxVEF84UMReHF4yfEy2tKKM9kROBaHy2CnRqjtnAmsIZ5vOu15A1zXWe1ymv3KrMb5J5tq75trWwHapji+dHd3pvZZ9bLdm+xvvJA+aD3EMj47seTD7MPER7+ORibyn9pMiL6CXM68HputnC+co8/YLXItVS6Ifrn7SXh754vH100rqKt3aiZ+861WbnL8Kd/zPBvRABFI5egC2EN/7QSegfugrLADbITWcVngJqdU4I/t9EI1C6myJ6Fb0CkYJE4vpwmKw1tgK7CJOA3cE947KkOosNRV1BPULvCW+l0YF8bQ+YZjoQlykTaFjoWukt6b/zFDKqM24wHSS2Z6FyHKPNYfNkp2RfZLjHCeFS4+bifs9zwDvWb4sUjC/g4CeoLyQqDCfCJcopxhJXFJCTdJil5dUsnS5TJfsG3laBU1FitIV5U+qSmpp6mOaYloZ2m91LfVaDSQNzxrzm9SYiZs3WxpaPbWOsCXYNTq4Ifu1yyXWTXHvmnuv52Fvdx9lP4L/s8DyYLOQhbCE8I3IaMpctE3MtTiGeErC4yT15DMpNAfiU+fTnQ8OZ+pndWQr5rTkaeUPFrgUvi9KKWE4Wl0qc7z9hHZ5T6XmyZYqzGnLM8eqX5+VOBd3vv8CS53fxY5LtJd9rnQ2slyNaBq6LoZkPh/abNtbb/B2ZnV97HHqvdkneevY7a2BoDuPB3Xv1Q+z3o8auTfK9TBg7NKjxXHBCacn6U8vPLs3Ofd84yX9K77XklNK0+oz2rO6b3TntN+qz6u8k1uQWBR4T/t+Yan9Q9xHpY9Ln84tu3zGf+784veV/mvbt70rYKX6u/73mdUDa9xr7T/2/Fj+mb8uut634b6xtlnyS+bX4JbPtv+j/BSQOiTyQAR9pPz4amvrqwiSVBQDsFm0tbVevbW1WYMkGy8A6A35/X+HbWYsUv+uROj//fk/9MaP5mWnDcoAAAAJcEhZcwAACxMAAAsTAQCanBgAACAASURBVHgB7Z0HrG5F9bc/29/u3+5nQ69i7yK2iEJEo0QES9RYEUsQxN4bREpEVCCCCgbFFluwURTESMSGggV776iIBctn1+/Z57msO3dm9rzz7vOee+6Bs5O775o1v1VmzZrZM+8u5xL//e9//8/6sR6BzSNwaYrXvOY1//rXv27OX7XS//zP//zjH//48Ic/vPPOO//rX/+69KUHD//+979f9rKXfdSjHnXCCSdc6lKX+ve//w1T5LHHHgv/n//852Uuc5lA7rPPPscddxyyaAjkIYcc8vSnPx3lCAZy//33P/TQQ1UVyOc///nwNQpTkSOPPPKFL3xhIOF3Hjq86667vuc97wmdNu20007bbbfdJujsND0BdvnLX/78888fgv6nP/2Jlk9QsRIif/vb3/7zn//YnTGTSfy/pSOMiiQh4GRIshxshrSNGRIlIFUFXoJzqRPxFBnKOwn9yazTzOXo7DQ9F8zIXxIZR+RcwisH1plLXnJw7BKXuISGJBh2FD1DzERGu+ZFaiKzrkuhU8d6zqnbi9LZY3caZmOspgmvS120IzAMyvVjPQJZBIa1xZo+uFrHQUOkqy0KGEQbGbUpMuiq8osYc22khV3i6tJtCN3gEpIrNxdsNxcw2bBQZNEK7eopkPA5AMDhEKnmWHHHslQkZ5GcvejKGeS7Dx3Olsbd0qsDHE2L73//+1e72tWI2oRAdDaFPqA7d9lllzPPPBMr9lBV1r5kgxf9B0zx5zznOWxHSQ6jzzaVDjjooIPYdpIW9qXIAw888OpXvzoc00Uk4r/97W8FhM43vOENIAXANAhuT8IBLT7ucY87/PDDQ7zqvEwTN5KyijQId7vb3U4++eQenVUlPUxb9Pvf/37bbbet4kfT4trXvvaVr3zlqsyimIxplvfGq50WpuaVrnSl1LTi/BJA81I+ND1KvwZTJHlTItEMUgB4CZglMrRJ6BK7/FQ8w5RFpUp+6KTDCMhcOse0zeQTpTHMaFqQrbjI0W7JmN4ePiYYPfQEYAw1RHQjwyge+0bnAGIKH52AmTZsuUgbEnOASGAcAnBAAg60gDGvxJBqqfgYWD4OAG7EU506Hy61dU6r1Q1MjImPpgXe2wDPY/LL4S9Z2GTFoFQVVj1RfAyfKVdDCQ6YgCiWyIyT4S1mmLLYhlFrh0F4lBoWxWnrX9+gLirOFyk9o7NF1kqz2GVdVtVfZMInSVXVLwVSEWfXEMQZ/UGtB1US4K2lCFM6amWKxJ9QGARMa0XKRydHYKQ5q1xPrFWcqqry0NBJqIezV9tOqRLGGrnfpd60sIWoLu3Ny5kQLEXSTsLoFa5wBc4sKYhXXCbdL+Cnh76JBMbBElWmSIvES6YETJAC5JdnXWKlgiH1Z5gJzcw0WFQPZwxVAf3Mfpd604LRgFt3uMMdzjvvvH4/AulC72Mf+xgaVBVVPQT9xOJ0zz33/OhHP4obDk11su1ki5iuLlkqHnDAAS972cuyvehzn/vcc889N5DadXcT+0aJ5z3veXvttVc4Rs6h881vfvN+++0XK1ZXuG9729s+9KEPBVKLD33oQ4866ih9jqrJhOH66le/+oAHPCCsz6uNfSUa+iPfmxYOo5/97Gczd24Njx3TMTQbyKxKkV//+te/+tWvsipG6nWve92MSZeUSPqsRCoYw0iCnXm5OXfHG0gFuVXLkVn/zW9+A2dCMzM9FtVD6MoWVfFVJgGB3+9S75LTcMSoqtpuMElzar0KZJFtSEWVIgxZODGXWmQE0FqixpmDmZ+zhsgDNYhcqv8vAZKIMxhokRJRJaEI00yKFJ+dtWhjJzQz02ZRPbZIzVVYm2nH9bvUO1u0ra5iLU2NAzekq/4EDCIDBEciisIoeqg/k71IFntni4tk49cbNRaBtTRbMJFyBYmLiDRbBlZ/HAxoGgkhwFovCkEvAf/lhDwWEfgAOJBVZwMJAGQAMKSUhvTEWpBRG/itllgbaWHv8nAhKwkOo+laj3UDV3Qv6vAl6JUSSf8tAXubPDMnMIdj4Q9FaRY6Y4Z6dNq61T33xmh1vXTF9I53vOMvf/kLkTVL3GoefPDBL37xi+lypg2cpD/ICe6LvvzlL6eTHK8iuS96k5vcBE7akVm73AHuvffe7FFZaTaW2Op55CMfiQPkQax/4X/iE5/AkJ6gX9/ud7/7HX300W2dmTOrWFwbaeEgu851rlNG6s9//vOPfvSjjM+NTTomY9J5JTLDWGQnDGHyVQEwdemqV71qaYjnBEpD7O1n6hyzteX5m66LW952v0V7iDNTQhxcRKAZnfQQo5wzB+ObM/MBVQxNwSIZtVQxrAfcyKG4Qx9Iw0NdYmbChPrDItaRVRUE04ZFtLV1Nsxt4aq1NFsQ0zSsdDMH8aKHPIIGZq0A6agFPBbl0DMGCL6eVA3B3OjQkqF+naF81Ym1MVusepgubg6sjdmi0SvMBOmyH5rJ3KGcSQUynS28ygTSKq4CrFI5nGwgUOhCNZUNqYwArEsop8rLHOcMtjUX13Ba2EMXXHCBPxIYZWgI967RhRLsb1NktVfMpyte8YosVjjESHiXpJpwoUpD/ACfGtKlP/zhD8DCpRDZOok1nBYuDN/4xje+6lWviuDSbYTeW2LRryK5rfrsZz9bAHh3lUccccQxxxwDkilBJmeY7373u9FjEkj87ne/CwBE9dDiwx72sLvf/e5hSKRZpSdV2a2KuYbTwhn++ktHNaZ2KlUi/+/SkSFNoEBay7PgHBmyp6ie/106qng9qVZtVcw1nBYOYq/fWUzpHo5suFPkCKS/LDFnwEn5AhAPpESJyQAUwWi3CiYnBJSCWxtnDaeFPdcYf9G1Epwl7AMEOeSkfGur/Tqz80JbqVDZMf5MzVsYsL5B3cIBXxvm5pst2HfFOm6u9ik1eaw497Kkr14yOj1hi8iRTeNMGPjGMe/0QChoDgpT6yrHSXcfaRWGEMmsp4A2jS39bMPGajE9VlXl96KNGs+NlQ2u6s2Y6Tp/3g5Alfk0b9syHyxGaurGH//4R3zTvSp+jKlItu1UORkwtuMI62NqS75+sgZacnPYLk04fOCvP/K9aeGwOPvssydEkGYQDny65S1vCZ2NsJ5GupnkGd3TTz8dcX9Z6hEUwzjDbcQf/ehHQ1CEb8+94AUvePzjH697/QpBKsL3pUIVhMp5DpkHjDUKU4d33HHH1772tTYEZv9huG53u9udddZZE/zUkE3uj3xvWuAQBm5/+9v3t2cMqaqx2irfa8fXv/71L33pS1VAD/PnP/85sLgMMaYpNva3PTrFqAra4cgN2NJPEyis9ys3XPzCtt122/VLVZH9ke9NCxqMUlrVPxGVnhE+lKiqrG1wIjRomDBbMDHEMI3QLKRFaMOlaJHKGZowNUqjdJh+hQ7rjcZmVSrnPCGlQlXmZ/DHiN60sD20dkxRP39CaFRuaBCfN0DgS5EVbZEWNarDON8fohSpn5z7LwGpeEqrKuWM0Qvo5jHV6/y1G4HR2YJZl98BncFWqHmYQLNDavJgYgylw0iHe7aygfSpGR1gPEGgMN1MigSGWgERkAwZ/GmEPhAQIm9wpumZKWWLGiZG04IbCDO1LxPgk5Kes3D3a6a3OPrxgXRGpfs5gpkSAuBIDNm3+a8UAQ5kcKYR6KHDCIjHNCX9Uo0urkcE1dwDZOlkWvVbmgvJsGCxcs455yDlnDGXON3J8OVRXp6eJTPsM7eIr371q0888UQ4jYxhrLAq5PYpTw6rCusSfProqU99qgCY6nzf+973+te/PpAqf9CDHsSnfQM5l/8l2CDwK8AOO+xgcErMQjh2K+0a0zaaFjynOiazlfBd/97xjnckiJlLfGULTnsQ2wff/va3P/3pT2fi22+/PZzIVAme2i2R22yzTYrM9Ewr8gtbaWiaqslSo2mxkE1Hj1sR/R5wiiHlKfKKAFOCA5qi90X9BoGAVCSlTRrebKalsZmU8MMEkVUSl7vc5VKk08bkbWfqSUmvevBH02Jyb5WNXCGOvUUEmc/x1osIZw7DGv3acIDUQdYDmEQ1n/qRDXOdVbjRiVwh2PoGdYUCu7bVDrMFM+e0G2Ar0XScQW11oDNvU8tk4EJSJAOLCwcXEUcYtOLUgnfaELnFZub+sNBMfNO9fqkVRerMkBbeBlxRY/3K3UxniwNndT4nYq3apHmBLN3OQVPrvj/AEjziS1X1AtHv3qKQukEz8U33FqV5mXp0ZkiLj3/846t+MYvGMIAI2Z3vfGc4TAzyTeHDDjvMD83IZIZjPjjppJPYZDIT2ATnkvvf//6nnHJK7FrVeYtb3AJB7yWqYRXPNu0e97gHfureKjqTmnZOHdKCv/OTVmw9dEz7Ene6051K3/ikFWmd8fl7RGRGxrQYOqu1W4ypG9xWHfNzi3lSNTSkxdazsAgXGUyOIc4wmT8gGP3pJcC9KBMJYLeLICkyDdIijti1qpae4FBVGFotQjc4u05aLTeqdgnmkBaeq4jVZZoT+CDhxBsuEVA9hzBpqIK2SBVBL5sWOkPPqhC6wbn0cFX8yYyub1CzgKwXhwgMs4WbuiwezMbkcky5Ej3ITE+jqE7mfIgGLKoYWEwY4VLwF0joCRcgWhqN1UOYGApXJZiZUqT7ZM4pst89m8baWQ2pIH1BjwhI+SltLWd3E2kVNHu0EJ+JHNLCTV2mxaJzHbRED7Kqp8pUJ62t1o4xw6UxwHL4KudjJrQ0GiuRfZdTJK8QLgE3/ekarF/rWtfiPMFPRVgAhemsLW2d1nKeKT4TOaQFX/op8+vtb387bY78YlgwUp/4xCemP3LQAFKbt0C5RQtBMWtGu+iS8CUvecm3vvUtHMXWGJ55gsHKvUru6+rJGHKZfIfpcccd94UvfCEM2TT+7g7KYxxTS5G/1/rTn/40Q/rhm0D2u6Seb37zmy996UttMrJGhm/u8ISwERtTqJ885P20pz3Nrgkkif7Wt741/LRb+SGHx5sDI8Eofe9737tpVsyq+YUAYRRx5sAhztWR/d3vfpcqum3AzXPwXjlwnmnOTI8VfV3YKR1BfgvizMPc4GPhpof8kkFVIKHLQ3GSEvFqu8bcmJfvSnn33XfHB42WzsgxyHx6qzRBWswUtwvojlKcBiKufgi7Nf0RKBUBMMwWzAr+8da0zqHvbANfgukx/cQwDY4EDGSqpE0rwp++Qk+W3ZkgraKPuYcZnmSAxRZxrJz5CBbDMTPUj8wEq0UDwg9uBMQmAzMy17jGNaAFVGWjFlkPuiaQ2XVNPWgGGRgJ7x4PaYF8qiLDpcUS2SmYKsloYo2SatADqV0wwVlRAkOd7epHzuWw7dUHI9Ppj1YEpyIpnXpS8uXMtxpINa7TF+EIDLMF85W7r5ntBMkRMKagMt2iNiVIeSYuL/bBdweIEnTOvIgghS1EcFWjiiOIOGsLCDC6xwxELZfSdNrHEDA9CR+0njZKQ53tCj0NAovqxCWOBhKj+EOUwCg1BrYVtI42BoYiQUCc5qAnbULWwBAZI4a0SDcXgTOgEUS9ZNUdgCBMqXYzvJhlzrmP4i9RGIhQWBIC+Nsf5W6QVRG1AhCUEFbdp8XlWYe1HuKl6eVztMhzXKnzDbXVL7FkeHWSBGUbES+bY8e1+yg1MaQFTz6Ws4Uf9YkgOhaPP/54P0ulCmqxZDMEpKpTGv2MVPZdP/7xj5WiVuLJT34yPwmgJ2ylgtKOg1NPPZXHcaNWcf5qKH/WRQBVEl/72tce85jHhCFM48BjH/vYBz7wgXoC0lupT3rSk9j04rzDwFq2ne9///uzARd25yXUzOOZuOR8MKbBIPiHfPBkDAbfZvL6JJv2cF48Txq8853vzOIJk9p2H21mDvktcLgx27Bhw2a2lwq8cdvpAH9+pxTngexS/AlPeEKJ5G/mgmxvEVX1ute9DvFsbisVbhmOfcmTBvjGNUgPSRoI/qBQ6YN/1FjY2Jmsoqr6ISh2IlQNs0V6fQozjDBHm4MYKITeBEYiQ2a1FlXCfWR+6onsJu5Md/yoggPtYUQ4mC1JeWzFIFacbkacw9EvEhokh2NOZPY4ri3CrqNZPxVfiQd2iACeV4OTMXEsXRZktRaNp22MZsJElq0s0aDh8EOWKoo2OZgNYpA0oFWQ5qkKP6qwAIzVyqe1uBtpAUGRYOEAdCNq9BwYWgU+oqY4Z/33LBJzIOMsEsHUPVuE0dSu4nKi7anUZFrnJ4uPCabNxGGDQyig07RQvL9F6xvUsYBfrPnDbMHM2RkDZmNTspF3JCy1XB3S0WnR6Tr4ElThwMyLCB46tWbiTJiIc1a5bcmQ1dahBz8ZbYLFKE4VLeWoCqZMjDpeU+Yyabxy5lMPUx1WGPr4FlGFA59W4yRV0IARxHNkQWbtoparsE3ucW9Ii3KT05bEfANgbRZTTXjWezSIvN71rjfTAQHZ4kBxftalVkC0JdtGVb1VnJhyBEA9RJkO4Aj+liTovNL0+eefv9TKjbdq9Yc/Y7nk5mZ+/vKXvyyR4m1yT1uGiOyzzz6lH5mwOXvooYdyL66ddOQpgX7FK16Bf/gBGFVmtzchoVXuOOMzRdyAbetU/HOf+5yqUvHXvOY1/CVSAWHojDPOgE6nAUXSM0ONgfXBD37w5JNPxmGd0WG23NxsC52pVNAoZwmCIfbMEG1bIdUmtL7tttsSE90Db2R4ee4pT3lKxFM9rMFTP0WyBi+RfECWQLVbtJlvdttmrPEC+wjwhIDz2MEMRhWJPK5mS9c4dfHgOI7pHoT3b5/xjGeU3vDnjMZal/G5qYt4NjWWCjs5Xgt22mmnzArF73znO6US0rdEVredJC5IUk08+QFRRW7aoF7lKlcp76BmTjhboB0+OZvVpkVr+UtBfCQ7y25HZAqGRmdbYeBNxyhKVMWryExQo7SdqYJ+db6UoIoIkkBeUzJBi45m/1gwIa5i5mWqB7upddpCGzGEn0xvVKHWwLoX1ROYTgZcbkAigmA4wHysVHDaxHARobeqHZZKmhYpp02rU+/byNT7NrJau0xxQomrtM4IBEEHUMW5alQmtXQAtBnWQHZWGS58SK1TpI8xhIcA9FMkbddDz6aFSDIsjYxSnW4AW9+g9sfqYoQckp2Zc2Y2kbMk40oEhkxf1GgL92jONG+dxhFnJucIhRAOWQCpt4SF6HGkSEyX8QTp1NJAah3x1DqDHtNcKbASsXK2QCFIqmwsZ6yIzC4imYfhQ8mXM6RF9Q5qSKaE81IWmhQwgaYZE6RWSMQuzx7xTW1FTtiF/ExebhFTfND02cztnp3NQ2jlDpP7BqUhbqqVSJYRpaHsDqo9WHVJ2SEt+PZPmd3RHgk95jYMxQhNhpm3aEbvu+++PKhops+rocTTEMYQD6l+/vOfnzDDGQd2rXxy1WGKCf28973vza1a9cvkfN/73pcNTgxNRfjKEfcwg2noeGR1zz33DHHby/7iTW96UyBhopMP9DzrWc8K63A4GMTupAy+/UoXghQQZ5qfIuX7kw8BsagSHlQAGYISG6c0DCz2wFcU3upWt8JMO4Gcr/g272IdQBuphvWNLbxwA2mwmHU1563U/kd8eeodQbe1bYdPOOEErMf8TK9T5PH6Uorny1Mk9Nhx05vetBT/xS9+UeL5iaJEzssZZotyzimNyfHaho12f4+JZ3z0wGFc3uxmN8sGR4bsL9LrzKv8zVxE1N8vG0hGlX0ph1ZzpctmSoOA2xwhCAywvweEdQnyiTjrHninDR+tCKR6iG0kNBznPB5JQZzDbHOyYS+KOcBOcgiiyp8+Y1oK3xCk1o6T4Fy9goPcuOQM4R5iITmBIfXQMPwguGlP9LhRxdBUtKlqsp8EnSPVT/jS7g/nMaQtwVi0nwIQBL1rx3CGSZHuBBwACI+st0wLrCvoGffUgGPg07SABmPthSo3/h8BkeCstgxGcX2DWsZknTP+Durk2JC/S4NtGG0kcqqHwREJC99UJbuZWrPZAiT5jniKT1W1aUYwyhmOKAlD0m3Blag1CDSQZnJoglbDcQ7PorRYH4whZy5AnZq5Cg8XEf7rFOiBqc0up1PTNhuFUKKjXLPHHJiQE5rj6j5chy8MhATfu8R06k94sqKErcge8bXJ3CLA9IRm9juscs5jQa6qGtJi//33zzqsCu1kOu7PPfdc8NEHjFSmkL333pvb6DDTQPDYMM/TBpOBjoY99thj2jrUxRrifMZVo7ihTj72Cy2gsy0LgblM4S+M8IQzk4QOuDj44Q9/iAmYCzFUVWJgGRKHHHIIYY8eqYJhMk+TD5t6bgy3EL5rKz6Ei1vZUf3TNR/5yEeAMcoz8AKL/RtUnX/mM5+JdaXG3NBhfrQgaGOruXnj6bUve8SXkYMP3/jGN9AWie5g27BhA1WMc50Uya3vfrsIDrMFO930Mf9++SoSpfgXE7gYmBC8v8q9YAcKRTDEjosI50hk+oAmTX7dVOteuUOnBOFj2hBQ9XxFmfhA08K6BKFY0amCFmGXs4utCEijpb46MKQF3ZD1YkNsWpXOEReucF5l1GMR6zHhw6dI1JZjiAzgqGrQk2rVijJp0UoHue1/FuQxsHFb36COxedizR+GFIN45oXQSa+a74g7OzUGIjlILRMmO7T0IoL1bH5DG8yGquguXVqJ6wVTFw6rH3M6j59hGsJaZj4csPkwoeO6ACDFg6FpoVMiwClyMq1FzgQZxzhClR0nIJgNYkiLCy64oIGYWdWzi9EtniZKt0nS2TuoIlnZYbfdDFOHPuOoOtmTW1VBeisdANI8bJa6pHJyJU0XW1T9FgVtSXVW7S6TiUtYIRppkNV5gxvcAEJAj5UhoPvtt9/MrnWIH3HEETxrGno1wyd5WDbikJGK2pSwlicfXVenVQ9+8IP5Yy0hTpRJc/9iaglOBRmahIDne1mQx9JE8V122YVvu6In7bNUdoxWzz3vec8dd9xR/SBl8sVd6EhBlX/5y1/mCWGNUmuUfAcwBqtRuvnNb/7whz88dIpkg8oLwOH8mFedfGIIkt9sDjroIPWH4NzvyaGr/+BXh7AEYdAx2amBG+ipuDSR7RTPYN7M5G3jUmd2szQTtFjdoHoxPfjgg6siKZOJmmJ5Y7p0xijxYeFUXPqLX/wi+PYVnKQB07NBLU1P4Gx6xDd+kW1ocXDECBBJ2yB4b5q9cpaemSrmTxrP7Ao4Bgcc+FxEvBamI5vLMDD0N2Ygq3hPBD0MYgYiRtXZ855I5qFFW8RzSbjEkc7GuIeVcEnrGMKiRkMhodCZVCezbKrTaYO7x2A0GuLLJ/AnU4KJmReEVGS4iKSNT+tS2rTIOskiTqChnRYggaGEPIi0QD9FYo24+lOL0Jm5rNYi8UVJ2hMWq+CZTC3qEuAyMplL2MUcSM9V/YqQVWrzbJL1r6+rmseYDWfGRDL++gY1C8h6cYjAMFv0JJejOZvuLPprWHu20AQYzIWSVDybLRivMy8ig/vFoU6nEBwLWwAZoBxwshGf6hDvrIbPDaTKvVikVlJt0tY6r4ROBOE4sc8lrk6jPSbuJFR6UnLUUPKHtCgvRSVODmFNq4wav2fP1CDAM1IGQnHuIo6JN3oldSOlFeFZJnRW1bZ1Wss7RWPiYUvl2ad9ozYl1MmPyqlOxX33bqZLhEtZpUL52EtBY50dgjOJIS2OPPJIs76BNj3d5wQMJjQvprKWxPVG85wMstuqMBE/+uij00d8yTz4D3nIQ250oxtpNMz1EOr8wAc+wBuwGkVKnfe5z31m7loV/+QnP8mCnJgwaY0ZVbmvxSo1hjRKfJv38MMPD502zVcI2+IOIUKHuEYxZLT9Rqr6wzo5zWOnPaFjL0bwQ3AzQqubsbaCAl+vwjGmXM5jhzvMR2/+Fd+G7wcccACqlAqi/xHfhuatpMphyZvNYxEr+aXnmzaovBYx8x1U5V0iZLq4kjXmiRTM5IZnKQc6E2eexIr38TrVZgopujQJvjoZRnB6dDK7cIR4g2BQzpxoFWepVM49/eK4Xa4YCGZ6vTC2+MNOOKalqvMgUejvtlXAxiVntb+rAiUz9aysnckpxZ0kZgo2AGVXoTObbBvizNUcDcCEKqwvJ8h05Exxetr+Zg9MWpdZGG4HLDgZsb5BzQKyXhwiMMwWpFUjsxYYp3IQo5y8Tid2PGFgMViZRcCT1+EAyM5da1UnqtDJoTkItDkrpFYwB58j7ErgFUfGRBW2MibaysmmiswEl1nEBKazroQjPw2+TCIwZnFIC599HUOsND+LoN7zozKX0vJqijM0cqZLVZ30X6pT5dWfyasZUDVKfNNwVzEy+5ENJT1Vbk8wJ9hwcS6D6QPGVZ1DWvDk7czrVlW4n0mgGX+825l+gQUOfG6fsv82f1FoavMGKX97RimYInfeeecNs26+iLzXve7FPdgQVyfPD/DXMYPJWCFSn/nMZ9AfaaQ4jwff5S53CaQEL0Wm77Wqk7+tusMOO2RIvgV1+umnqypaxH6bZ4wDCX/hhy7xEjOasa5+A8uW4l3veldYlJneDI+qjQSILXbwIWashsf+OMOGvnTAu9iZrzQMJBksvrpBVSevJpc6+URYprAsKl69g3rssceCFwDhXM03lkpDJ554Yor0KlO9g1rKLpxDxqOz/xHfTRtU9jNlgBbLoS8JqIbwUuUS/FDDz1l4b/jAsJDmqWPwcBzH0GjIvrRX9VCdvJyJHucDYOqkI9HDDJFeU9GvidSl7A6qzmeP4WiI3/dQrn40aNG/6pM1M7uDWnV+UUwCiHUmDxR6JpK0PSawMETTgk6J4SLiPb2Uu3Aa53QLzc51Epzh4wB9Y1rAsYjHkRYwKTIDQ7QPo0Dfo4QoxAXVNqKEeKVpkWlTnAQS71nnnR4EICWBhylSixptIzO7Cy+G9dBM28u0iNqMyNfbWfV68eIZgWG2aIyeLCiMGNIwJqis1qK1Oy7adAAAEf1JREFU2d4SEwiSrWiInIVmAmCeoJazkwF0AFAVOiHQSW1oFola9HCIhEBPOVao1TqAUKtIelYcDsrVL41CrzUN2VRPSiuCV6nOFLBY2oBgNAsCTYvANiwCo3b4FzNtA51WZfbSKmhr1R5VmmAvkG7npLO9qMiYvdWgTm5XUisAvgQLT/SoCqaEv+VHF0qwD18Ctt7sUxz8kp3hGXQODfX/dq5UnHWeF6JSnVG7QkT0kflBTkeI2hb9tWJIC9btM2UwgwG+EsTdCi2NaWdYkJWsxtMHymXySaHtt98+BNX52c9+ls8ChU48IaX81hNSgh2p6GRTrir4Ehs2bOBumapgIouG2972ttC4obirFu6g8vhnul6xNj2rByXsesKQLn3qU58CqSepyEzaVvzgBz9Ap6pmiiwHwKePdtttt3CeFqGN1XoapYZ+lnpDLf3RAGVV7HPAExrOYwfLcqp8KD4T/973vldKVd9BzQQbRV9rLtUuh8OT0w2LVjkd8qeTMBR3ZV3SLvYd1JmeZAB3mHoyOQjDbNFzB9XLksPOBMy8iaK117/+9dm8OfioYv7kysq+8YY3vCFZpR73db6Dml32ANOk0ClBT8QEAIe8pvFcL9AD3qk+kJhAg85IMFJnjnVdYqihXP3hA7IzxQNcEnhuJpVVi+IYbSKMQhsOYds5E6tOQ1zBh7RAYKZM1m0zDdBP6Iy0wC17DpME17RAiUWQPfrp18wugqhCCeJpWgiL0EjQKz0dgzbwBsRzZnRakVRboLaqD0Y7s2LbOdOuqlSVub5BrYbl4s4cZgsGHEc7EgxH864Ni1p1mr+acOUVgCDQDLhHPxqYdUJQmrmHWYRjpnuY4EBqJjJMLJDAKNaXo7B6CUs7zminnMnmhrTIntCs6tInu7YdWXuLZUTaDGk6D+UCguD1IWoFVE2PMe1dfibvvDqoZ1VywsZOaONY24Nf6iTymgvMBGJIi0c84hHZBalUZCb2PEvnmOB9S14gCz2kMA3w5l50jHnNHVS+Rar+wGcEsoDPPPNMHtyNKnOUe5UQAqIqI3AJDN/R5TlHiGWO2kx5Z5Hn47lT2PazqspByG0aWppFib0od5WzFvk0+XLbiNW1cnATksBNniSzR3yrrXareeCBB2KInUi1n2S6eu3ZoOrwMu+g8meFsRvLaocWiV5txfKZw2zBrsymzjwTKRNWt6p4fKKW6QciA9AqslgAVQ1kJui+0ecDMrV0z8yR4VaTyw1qG55nRhdV1OHJd1CdYLJ3KdRJkMvNOQ2kvcZ2chOGtJhr6wK+HVlrG0MtxGci01bhpMMuxK11vZIiqzQRJL7VqpVm6jDOG+d5o21aGM9oOwQdz3hAG+eYRaItgQzOXMSy1sZzWVoHr6EIDLNF54Dbkq1ibDkgpmU9UumVBW0cDC9aypFWQXNkUy7iinAea7UKp7mHTi1yLucwrWcuZW5QqxJbNNONTGfDOmqHnZ3/ZVa3kuLM1o75mYXbz0vSkUODL7wFn8qGIcPND+r0VvujlHbn5D9FoEXOVX/wLVxK/QyaWlxttCiQKRE6JTiPWR/S4rTTTmOTk8qvIm2D+fgLu9ls69XjleK3vvWtuSnjmECK8NGLLPpOPfVUCIowRbJlTd+AZeagCnEex+WCzQ/2Y0bV6Q1hpcaQVb5N4zcGvu6rJwHjFtVd73rXdttNX26C0yImjLHeDZ0sTXbccccIiASt423bwEjQFja9m35cyqpXt5h9xdd94+67745XduqYey7N+CAVLc+O6iO+L3rRi4D5vaUMP6Ho/iu7g6rDOI/C7F4rzSwbwl/oSV2i1ymeddZZIMulZSle5Zh55IGNYmxA+MxpiadqmC167qCWwivEoV8J7nK+4otjPI6b7tzc3zKkUB5zgIayXSsRIYL0hNeImW1kbKFQqZngFIAVijQTN/SEItqYJHg9AlpAKlLSYDoTJfvmvMoxh+lMLffl4QxpQTdwZNWrWMQZAj3NARtMBmQ7N7eFao5LA8Ws+0N85rScuqdUyumkaaaR92xahHszlYT4TOSYTu2m4jZ8fYOaxmSd3hiBYbaoHmRulb9wJtNmp04GJV5xpHNJJm4VTKYBDsAol4ZYkh5OQWcDHXE4iKcmdE/rAuBUkVrUpVKDerJz5hK1upfB5iqWGuBEEFCl8xGfVLmyo2mRhTuV3PK0IWY3iFdtx+xmHl1koedaD2+9XirLOkP/Wf1BuAuNLlS8DGs0WQDFKlKL/a85MbfjlZ6g06b5kG24FKb7iTJEPFe7FI/NfoZhTVki3XKPpgW3+6Ytpubyng4455xzDERD0H7ivVB6EdrGcIbmO0PpitoqdJ5xxhmxc5Pg9i/vpoY4F1H4/DEb7KofQp08YPyTn/wkkGQAncSON93KiuSRYx5QDaSGvvKVr6iq0SKzio+K4pKeANaQD7eGSw0l1SpWUWybcVgTEtxrJSD6HFIEE+uBlO8ibJhPHEyBloC/ZY6ddtoJixEF18annHIK1hlMM33Yc889Ee9ZIfJl6pna3Kmya82iQTH7O6jMOmjje1YlMuM4hWQb1JmeBIBUg+7ZoJoH1Y8kxYSU+RZWMmJ0tmAczPySd2Zj3iLLYJLAWR23GuLU0man3IApXr2tmk2Ybkq5lGILJW7qHJrkE2D1o9nI+qU9pWBKEI0ABMEopAmBhM+RXsXllGctMnzxR08CwwhBYbgU/JkEImBII5rpvEVRPXwuGD9jVlMVFxGT21bLhAY5mhbUMZ9McE7tnWdMOE9kocnE9ZtgZXzEHYtpw8CUHUMOgQHPmaZlejJxesudm2eCQOehM5OimCFLwBhHi7Qdl6qYzKUqJmMiYn8ZFmdQOYSOtmRpQaNAVrt4C203sgasF7fyCIzOFpnf5hSDAyKr6i+SrZHR/VLLR+ozzjuLVMe9VgSApLiclqY+q4fzTOupVNB6O+aSc63giK2GnG+wC1EV1yUBYQ6CCbg3LbSROpEqmotW1VwiywRrkZ0IDfZx1DGFrr57Hlkd01Dytc40jvXq6r4USTleJVnEwCxDZ3+neHaYiCgV/HiBliQIJtoyWFT1poU5xcaPC1II9xN4gAY+XMSevkzPfj3TkMaObxedffbZ+F+uUUItF2BWHv550jLiAZuLsCe4WYp19c8lztCn8/hkFFKqCnFuqXCzN+JpkLnzjCGlFIFffRycZSnIEFctI59vHY9uUPnIFQKEhjMH0eTcsw8Mp0uCTyGHKghvJ7J1BhnzkOvBng2q4rxxi/gyHStdTTmmUfZ3UOlgmnDMMceALNewqfhK0PQ0ankDGx+ywwxYjlEU9s4W+sHNPf8yyrxWiSyJZfhUNa+G5eMZc5F8bW0MtUVNFWGIVi8nd+kqBndoowgNh+yM+Q+faSBp4QWLVqT4VDz45cTpZa43LVSEapwIpXMRzjdziSwWTJjSSC1W+UxtdOTk0JXKSTIUcmakcbZ3TQtHIHRPY0uX5KxvUMuYr3OWnrdY02FgrMQRDXGOjWIQIIOW6EGqPxNsF0tD4Ku2+pFti2mtDmeaO60rNd9FJLW96rTt9C5GORlW3auGZiaS6zeYnh/pQ9U0QyE+jdAolw+I6kqiVFv66c2ENZwWrh+5q8nDj6zmDATtJN95VZWXNrMo8OAaX98SQJXEeeedl35YWBE+5cObnIFU+TbbbENtz6KVHwnSB4zVyfvf6Uu5MtmuozYMyeS5c+7fSs91dqDzezYBYX2dri0IDnd6M220ha8QZ8yNv+vgU/U3lmyDil6QPmaYKeopuibiNiBKVAWxzA0qGsYOn+aNlb87IP7STol/5Stfif+xw5SAWSIzTnWDqsU99tgjA1PkEe3UkL8j8Wd8S6T35cOlanjNAB8G1pNST8rxG3NZTjtIUljQa3i2oA1EhzHBtBmxY6pnuHBlgQNAvgTjlWsNQTTiIrMbsCJhghQQmokpfanRYGaE4qR7Ks4wIF2cvQQgJYGJFElbMJF9Ljgz0SjqG2csBkxm9mFha4kb1gUEHoIxvIbTwhFDHDmiVTSVVjksBFAVSKqIglOXSGWrSAGhWSKQGT+txTomQhwR0oIDTIhLZEgzL0NWDVWZ6uRsA8XY63KoohiyIsu0ALC+QY0orRObIrA2ZgszmjPHJt+XKFKeAz7nrGpCUf2cGeseY0qsDbywKF4oPVzdArnk6XCCKR21YKTho8RakfA51CwdRZipoahNCbWpv1QCX0AqwqS1NtLCABmstAFBpxEM5gRCPUy5hKZ9r5UVDPpdpoR1Ca4CqbgYmHQAiwm98vLPpT1FQqszRVZbgSEw4Dn0pAoLprsKpYJJEfEopsTaSAszmtsxLAajbRLsJLnpLCBt2DQaPQhyW4GbqLE4rapyIelHm5QCJsFj1qm4C0mWnBs2bCA5TAj6g5HK3U6QJIfXfjjwaWaKtGnk07nnnhueaAgm4noSVVWiuuTEMcQzPA7c+MY3Hlqy9W9Q/c2K14WzNlB8y1veQhMIEGcON718u4gq124QjtfDDjsMQIbcYn8HtboXLd8MxtvttttuqSmbnfj+NVXpWpLiCh0YXhuzBRMDIeCj8Uvbjs3+9oxTqIBFhQltY7NrZoIIetlO+Zk4PjMu8ZNhTVLqsEOcJKaWrGVmQoNTCKM0RTrZ+AF1zKWGoN1JZcxqET0lvxR3jlgbaWF76ADbFmeIMlJl4+floLMaxE49pbh+MntBxBwGQR7A8UA5grSRc4okyeg8+6/MfmQ7varCSnE59RVHVcU68+ITgbU0WyyzVxiFcaAqo5epvCGOodRcVqwKZr5ZrCJXiNmbFjaGS+M0P1hsI+hlWFVz6VHEC3DMe2kxdEpojiu0VkQyA3PEds5PaDilw5/Ln7nAKucqAKFRxF08al33YBofnE+RYsTbrrmszwtmuYNIb1rYNv4oQYR1Lnu0iiZlu/x+DVrnFij36oivmeFKLXsPWCQbP5AE1MzQOjT7SdwwxK7+qks5dPpnc1MPudtUvivLbxt+OCVFEtn0/q2ZijjWsyUn1vFT99DgkpM7WCDJFcNFY2kye+a0RZqjReWTm4B5tTX1Zy5647YUp3s2qMAWfriZnPyI77z+7LvvvjMDZE/st99+pfKjjjoKcQEQDuK99tqrRPKXb1Jkwyh/EKkU50HoUuQ2t7lNifRXBz1BxCHBkwYlcl5O72yBXqzGBF763cNhNKBEVT34wCjiKj2YEpnOKtIxCpIjhqbi4DlCpzR4Whoj24Hr7BpgCeaeFOlUlN2/DeVYD9o5j6k3FYeGj12QzoXgoWk4Vx9qYwqBA796+5cqkEwkkS5htJPAh960MBMR6FTdgKmqASirFEnDmmFCZxWJ23pOyDwy8SiGuCJKSWs9M0QxRaKcYoYM5dQGjSBFcisVp1ZxnQx8iUQcK5khmCjUJTWHuXmJTfk7r+Q6/iIcgdHZgnTzWLnGX2hh4/6tYQikQ6GBaVRNaEjmW2iAaBhaiSothj9ZEYsTXEKkEU+qRtOCaxvVHCvRVHVqImbCRvN0Y7IzGlI/l/9Gi9wrGjWlAEt4qZ7sQ2aUyz8cnWk0HAwWARAliHCJaw1VbqkmuKRIQ3A0LXj2FacNUNakRRVdQEVPNNTqBi/dCm4gq1UaIpR8uoTedddaRbogJV48OacUMAn/RlO7C6s6ZaI5vdOLM2RG9imVqrgW6YvUJVYbJIoPJ09wyXiiJN1Ia522D1GqugKTb+2MVa0Ev902FucsxflLLSeddNJk69xB9THJhgbjxd9Brf4dVwTbk01Vsxmw6667Hn/88erPYO2fgowML4WPueTEk+lsF3WDPwfGDzwZEm8ZNmtjyel055yJ31lLZhaZe8EQCw4yTKJ6jlrwSs1UPhOAITB0XtU6VQJm6lkgwHh6ztSao6OzRYa+CBSJQhxjzZkJGBNs8NFJbWi2mOJLTlq7KvTamC1WJTQXZ6PraXFx7v3Rtg9p0ViZj8qtWIXO+ANfXHTj8ozZCSusqs5qCzSk9XZYrNWZzM9MXEyGbFhXW9t6Q1zBcKmBrGIUH9YWvDPpy2hVFVuYyUKPDWH2I4FXX27pcbiwn8srdbqEbF/IrWXZhSGlxgy50c2+sqU4S+NUXIfhoKrHOvhUfMyBko9yetp7vz2GwOhVqkrO/wf9k0UXfXDgxAAAAABJRU5ErkJggg==";

		    barcode.onload = function () {
		       // set the width and height to attributes
	        var imageBox = {};

	        barcode.width = barcode.width;
	        barcode.height = barcode.height;

	        initialWidth = barcode.width;
	        initialHeight = barcode.height;

	        barcode.width = scale * (initialWidth);
	        barcode.height = scale * (initialHeight);

	        box.style.width = barcode.width + (barcode.width * 0.2);
	        box.style.height = barcode.height + (barcode.height * 0.2);

	        imageBox.width = barcode.width + (barcode.width * 0.2);
	        imageBox.height = barcode.height + (barcode.height * 0.2);

	        box.setAttribute('style', 'height: ' + imageBox.height + 'px; width: ' + imageBox.width + 'px;');

	        marginTop = Math.floor((parseInt(box.style.height, 10) - parseInt(barcode.height, 10)) / 2) || 0;

	        barcode.setAttribute('style', 'margin: ' + marginTop +  'px auto; display: block; position: relative;');
	        barcode.className = "drag";

	        var newdiv = document.createElement('div');
	        newdiv.innerHTML = "<p>Click and drag the QR code below to align for printing</p>";
	   			
	        box.appendChild(barcode);
	        newdiv.appendChild(box);

	        // the image has loaded, so put a div with it
	        opw.alignmentwidget.main.appendChild(newdiv);
  				box.setAttribute('onmousedown', 'opw.alignmentwidget.mouse.down(event)');
      		box.setAttribute('onmouseup', 'opw.alignmentwidget.mouse.up(event)');
		    }
			}
		}
	</script>

	<script type="text/javascript">
		opw.designs = [
			{name: 'Pre-printed', source: ''},
			{name: '75RTUGA', source: 'img/wallet_designs/75RTUGA.jpg'},
			{name: 'MBesser', source: 'img/wallet_designs/pw1-01.png'},
			{name: 'Timbo-Green', source: 'img/wallet_designs/timbo-green.svg'},
			{name: 'Timbo-Grey', source: 'img/wallet_designs/timbo-grey.svg'},
			{name: 'Canton', source: 'img/wallet_designs/canton.jpg'}
		];
	</script>

	<script type="text/javascript">
		opw.ui = {
			current_step: 0,

			steps: [
				{
					//0 - Start - Select number of pages
					pre_actions: [],
					html: "<div>Welcome to Open Paper Wallet. Follow these easy steps to create your paper wallet. <br>First select which currency you want and how many pages you want to print. There are four wallets per page. Press next when you've entered a number.</div><div align='center'><label>Currency: </label><select id='selectcurrency' onchange='opw.paperwallet.setCurrency()' value><option id='bitcoinoption' value='bitcoin'>Bitcoin</option><option id='litecoinoption' value='litecoin'>Litecoin</option></select><label id='paperlabelpagestogenerate'>Pages to generate:</label><input type='number' id='paperlimit' value=1 /><input type='button' onclick='opw.ui.nextStep()' value='Next'/></div>",
					post_actions: [{fnc: opw.paperwallet.showCurrentCurrency, parameters: null}]
				},
				{
					//1 - Save the page number for later use. Then start seeding for key generation. Display notice.
					pre_actions: [{fnc: opw.paperwallet.savePageNumber, parameters: null}, {fnc: opw.paperwallet.startSeed, parameters: null}],
					html: '<div id="generate"><span id="generatelabelbitcoinaddress">Generating addresses...</span><br /><span id="generatelabelmovemouse">MOVE your mouse around to add some extra randomness...</span><br /></div>',
					post_actions: []
				},
				{
					//2 - Prep HTML for keys then generate keys.
					pre_actions: [],
					html: '<h4>Bitcoin Wallets</h4><div id="paperwalletdetailskeyarea"><div id="paperwalletdetailscolumns"><span class="aliasdetailcolumn">Alias</span><span class="addressdetailcolumn">Address</span><span class="privatekeydetailcolumn">Private Key</span></div></div><div id="paperwalletdetailskeys"></div><div id="paperwalletdetailscommands"><div id="papercommands" class="commands"><span id="paperwalletdetailsconfirm">'+
					'<p style="float: left">The browser has safely generated your keys and addresses. However, you can also use your own private keys. Just replace the existing keys in the private key input fields. Once your done confirm your keys.</p><p>You also have the option to <strong>encrypt your private keys</strong> using a passphrase. This is based on the <a href="https://en.bitcoin.it/wiki/BIP_0038" target="_blank">BIP-0038</a> specification. If you want to encrypt them, click "Confirm and Encrypt". You will be prompted for a passphrase.</p><input type="button" value="Confirm Keys" onclick="opw.paperwallet.confirm();" /> | <input type="button" value="Confirm and Encrypt Keys" onclick="opw.paperwallet.confirmAndEncrypt();" /></span></div></div>',
					post_actions: [{fnc: opw.paperwallet.startGeneration, parameters: null}]
				},
				{
					//3 - Encrypt Private Keys Using BIP-0038
					pre_actions: [],
					html: '<h4>Encrypt Private Keys</h4>'+
								'<p>Enter a secure passphrase:</p>'+
								'<p>The same passphrase will be used to encrypt all your private keys. Even though the encryption is secure, it should be noted that encrypting private keys for paperwallets should be used for personal use. Do not use the same passphrase if you are generating a lot of paperwallets.</p>'+
								'<label>Enter Passphrase:</label><input type="password" name="bippassphrase" id="bippassphrase"/><br><label>Confirm Passphrase:</label><input type="password" name="bippassphraseconfirm" id="bippassphraseconfirm" /><br>'+
								'<input type="button" value="Encrypt Keys" onclick="opw.paperwallet.startEncryption()">'+
								'<br><div id="busyencrypting"></div>',
					post_actions: [{fnc: function(){ if(!opw.paperwallet.encryptkeys) {opw.ui.nextStep();} }, parameters: null}] //If the user doesn't want to encrypt skip this step.
				},
				{
					//4 - Select wallet design
					pre_actions: [],
					html:'<h4>Choose your wallet design</h4><p>Select a design for your paper wallet by clicking the notes below. The default option prints the wallet with no background. Thus, you can use pre-printed paper. Once you have selected your design press next.</p><p><input type="button" onclick="opw.ui.nextStep()" value="Next" /></p>'+
								'<div id="paperwalletdesignoptions"></div><div style="clear:both;"></div>',
					post_actions: [{fnc: opw.paperwallet.showDesigns, parameters: null}]
				},
				{
					//5 - Show Print Page - here the user can align printing and choose wallet designs
					pre_actions: [],
					html: '<h4>How do you want to print your wallet?</h4>'+
								'<div id="paperwalletdetailsarea">'+
									'<div id="paperwalletdesignsarea">'+
										'<div id="paperwalletdetailstext">'+
										'<p>Note: if you are using <strong>Firefox or Internet Explorer</strong> and you do not see the backgrounds when you print, you must change your browser print settings to allow for printing background images.</p>' +
										'<p>In Firefox: Page Setup -> Format & Options Tab under Options. Select "Print Background colours and images".</p>'+
										'<p>In IE: On the Tools menu, click Internet Options, and then click the Advanced tab. In the Settings box, under Printing, click to select the "Print background colors and images" check box, and then click OK.</p></div>'+
										'<div id="paperwalletprintcommands"><p><span><label id="paperlabelaliasoption">Show Aliases on Paper</label><input type="checkbox" id="papergeneratealias" onchange="opw.paperwallet.toggleAlias()" checked="checked"/><br>'+
                                        '<label>Wallet Stub Private Key Style: </label><select id="selectstubtype" onchange="opw.paperwallet.setStubType()"><option id="qrcodeoption" value="qrcode">QR Code</option><option id="plaintextoption" value="plaintext">Plain Text</option></select>'+
                                        '<br><br><span><label id="paperlabelverticaloffset">Vertical offset:</label> <input type="number" value="0" step="1" id="paperverticaloffset" />mm</span><span><label id="paperlabelhorizontaloffset"> Horizontal offset:</label> <input type="number" value="0" step="1" id="paperhorizontaloffset" />mm</span><div id="paperwalletdesignaligment"></div><div><input type="button" value="Print Wallet" onclick="opw.paperwallet.build()" /><input type="button" value="Export Public Keys" onclick="opw.paperwallet.exportToCSV()" /></div></p></div>'+

                                    '</div><div style="clear:both;">'+
								'</div>',
					post_actions: [{fnc: opw.alignmentwidget.init, parameters: null}]
				},
				{
					//6 - Decrypt keys
					pre_actions: [],
					html: '<h4>Decrypt your private keys</h4>'+
								'<p>Enter your encrypted private key and passphrase and click "Decrypt Key".</p>'+
								'<label>Encrypted Private Key: </label><input type="text" name="enckey" id="keytodecrypt" /><br><label>Passphrase: </label><input type="password" name="passphrase" id="passphrasetodecrypt" />'+
								'<br><label>Currency: </label><select id="selectcurrency" onchange="opw.paperwallet.setCurrency()"><option id="bitcoinoption" value="bitcoin">Bitcoin</option><option id="litecoinoption" value="litecoin">Litecoin</option></select><input type="button" value="Decrypt Key" onclick="opw.paperwallet.decryptKey()">'+
								'<br><div id="busydecrypting"></div><div id="decryptioninfo"></div>',
					post_actions: [{fnc: opw.paperwallet.showCurrentCurrency, parameters: null}]
				},
				{
					//7 - Empty Coins
					pre_actions: [{fnc: opw.paperwallet.setCurrency, parameters: 'bitcoin'}],
					html: '<h4>Retrieve coins from your paper wallet</h4>'+
								'<p>Enter your private key (wallet import format) and which you address want to send your coins to. This feature requires you to be online. To prevent accidental loss of coins, <strong>all coins in your paper wallet</strong> will be sent to the provided address. The coins in the address must have <strong>at least one confirmation</strong> before being able to retrieve them.</p><p>NB: Only Bitcoin is supported at present.</p><p>Disclaimer: Use at your own risk. Open Paper Wallet cannot be held liable for coins that get lost if they are sent to the wrong address. So please double check your information.</p>'+
								'<label>Private Key (Wallet Import Format): </label><input type="text" name="privkey" id="privatekeytosendcoinsfrom" /><br><label>Address (to send coins to): </label><input type="text" name="passphrase" id="addresstosendcoins" />'+
								'<br><label>Fee: </label><input id="feeforsending" type="number" value="0.0005" /><br> <input type="button" value="Send Coins" onclick="opw.paperwallet.spendAllCoinsFromWIFPrivateKeyToAddress();">',
					post_actions: []
				}
			],

			nextStep: function(nr){
				//Goes to next step if null, otherwise moves to specified step
				var current_step = opw.ui.current_step;
				if(nr == null) {nr = current_step+1; opw.ui.current_step = ++current_step;}
				else opw.ui.current_step = nr;

				var steps = opw.ui.steps;

				//Execute pre actions
				if(steps[nr].pre_actions.length > 0){
					for(var i = 0; i<steps[nr].pre_actions.length; i++){
						steps[nr].pre_actions[i].fnc(steps[nr].pre_actions[i].parameters);
					}
				}

				//Bind HTML
				document.getElementById('wizard').innerHTML = '';
				var div = document.createElement('div');
				div.innerHTML = steps[nr].html;
				document.getElementById('wizard').appendChild(div);

				//Execute post actions
				if(steps[nr].post_actions.length > 0){
					for(var i = 0; i<steps[nr].post_actions.length; i++){
						steps[nr].post_actions[i].fnc(steps[nr].post_actions[i].parameters);
					}
				}
			}
		}
	</script>

	<script type="text/javascript">
		ninja.print = function () {

			var doc = new jsPDF('p', 'in');
			doc.setFont('helvetica');
			doc.setFontSize(12);
			doc.setLineWidth(0.01);

			var pageMaxHeight = 11.7;
			var pageMargin = 0.5;
			var pageMaxWidth = 8.27;
			var walletLength = pageMaxWidth-1;

			var wallets = opw.paperwallet.wallet_details;

			for(var p = 0; p < opw.paperwallet.numPages; p++){
				doc.setFontSize(5);
				doc.setLineWidth(0.01);
				for(var i=0; i<4; i++){
					var alias = opw.paperwallet.wallet_details[i+1+p*4].alias;
					var bitcoinAddress = opw.paperwallet.wallet_details[i+1+p*4].bitcoinAddress;
					var privateKey = opw.paperwallet.wallet_details[i+1+p*4].privateKeyWif;
					if(opw.paperwallet.encryptkeys) privateKey = opw.paperwallet.wallet_details[i+1+p*4].privateKeyEnc;

					var addressPrefix = bitcoinAddress.substr(0, 7);
					var alias_full = alias[0] + " " + alias[1] + " " + alias[2];
					var alias_short = alias[0].substring(0,1)+alias[1].substring(0,1)+alias[2].substring(0,1);

					doc.rect(pageMargin, pageMargin+i*2.5, walletLength, 2.5); //Outside Border

					// Note
					// Qr Code - Public
					doc.rect(pageMargin+0.25, pageMargin+0.185+i*2.5, 1, 1); // Border
					var qr_code = ninja.qrCode.createCanvas(bitcoinAddress);
					var qrcode_pubaddr = qr_code.toDataURL('image/jpeg');
					doc.addImage(qrcode_pubaddr, 'JPEG', pageMargin+0.25+0.1, pageMargin+0.185+i*2.5+0.1, 0.8, 0.8); //Print

					// Qr Code - Private
					doc.rect(pageMaxWidth-pageMargin-2-0.94, pageMargin+1.3+i*2.5, 1, 1); // Border
					var qr_code = ninja.qrCode.createCanvas(privateKey);
					var qrcode_priv = qr_code.toDataURL('image/jpeg');
					doc.addImage(qrcode_priv, 'JPEG', pageMaxWidth-pageMargin-2-0.94+0.1, pageMargin+1.3+i*2.5+0.1, 0.8, 0.8); //Print

					// Pub Address
					doc.rect(pageMargin+1.5, pageMargin+0.185+i*2.5, 2.7, 0.2); // Border
					if(opw.paperwallet.show_alias) var text = alias_full+ ": "+bitcoinAddress;
					else var text = bitcoinAddress;
					doc.text(pageMargin+1.5+0.1, pageMargin+0.185+i*2.5+0.13, text); // Print
						
					// Stub
					// Qr Code Public
					doc.rect(pageMaxWidth-pageMargin-0.1875-1, pageMargin+0.185+i*2.5, 1, 1); // Border
					doc.addImage(qrcode_pubaddr, 'JPEG', pageMaxWidth-pageMargin-0.1875-1+0.1, pageMargin+0.185+i*2.5+0.1, 0.8, 0.8); // Print

					// Qr Code Private
					doc.rect(pageMaxWidth-pageMargin-0.1875-1, pageMargin+1.3+i*2.5, 1, 1);  // Border

					// TODO - Print text instead of QRCode if option is on.
					doc.addImage(qrcode_priv, 'JPEG', pageMaxWidth-pageMargin-0.1875-1+0.1, pageMargin+1.3+i*2.5+0.1, 0.8, 0.8); // Print

					// Stub info
					doc.rect(pageMargin+5.7, pageMargin+0.185+i*2.5, 0.2, 1); // Border
					if(opw.paperwallet.show_alias) var text = alias_short+ "~"+ addressPrefix;
					else var text = addressPrefix;

					var lines = doc.splitTextToSize(text, 0.01);
					doc.text(pageMargin+5.7+0.08, pageMargin+0.185+i*2.5+0.03, lines); // Print
				}
				
				if(p+1 < opw.paperwallet.numPages) doc.addPage();
			}
			
			doc.save();

			/*var style = document.getElementById("customprintstyle");
			if (!style) {
				var style = document.createElement("style");
				style.setAttribute("id", "customprintstyle");
				style.type = "text/css";
				var head = document.getElementsByTagName("head")[0];
				head.appendChild(style);
			}

			while (style.firstChild) style.removeChild(style.firstChild);

            //Fit text into pubaddress if it overflows

            document.getElementById("wallets").style.display = 'block';  //Make public so we can read widths.

            var elements = document.getElementsByClassName("addressandalias");
            for(var i = 0; i < elements.length; i++){
                var pubaddress_string = document.getElementsByClassName('alias')[i].innerHTML.concat(document.getElementsByClassName('btcaddress')[i].innerHTML);
                var length = pubaddress_string.length;
                var constant = 64;
                var increase = 1+((constant-length)/length) + ((constant-length)/constant);
                var font_size = length*increase;
                elements[i].style.fontSize = font_size+"%";
            }
            document.getElementById("wallets").removeAttribute('style');

			var offsetx = -parseInt(document.getElementById("paperhorizontaloffset").value, 10);
			var offsety = -parseInt(document.getElementById("paperverticaloffset").value, 10);
			var css = '@media print { body { margin-top: '+offsety+'mm; margin-left: '+offsetx+'mm; } }';

			if (style.styleSheet) style.styleSheet.cssText = css;
			else style.appendChild(document.createTextNode(css));


			window.print();
            document.getElementById("paperkeyarea").innerHTML = '';*/
    };
	</script>

	<script type="text/javascript">
	(function (ninja) {
		var ut = ninja.unitTests = {
			runTests: function () {
				var div = document.createElement("div");
				div.setAttribute("class", "unittests");
				var testResults = "";
				var passCount = 0;
				var testCount = 0;
				for (var test in ut.tests) {
					var exceptionMsg = "";
					var resultBool = false;
					try {
						resultBool = ut.tests[test]();
					} catch (ex) {
						exceptionMsg = ex.toString();
						resultBool = false;
					}
					if (resultBool == true) {
						var passFailStr = "pass";
						passCount++;
					}
					else {
						var passFailStr = "<b>FAIL " + exceptionMsg + "</b>";
					}
					testCount++;
					testResults += test + ": " + passFailStr + "<br/>";
				}
				testResults += passCount + " of " + testCount + " tests passed";
				div.innerHTML = "<h3>Unit Tests</h3><div>" + testResults + "</div>";
				document.body.appendChild(div);
				if (passCount < testCount) {
					alert((testCount - passCount) + " unit test(s) failed");
				}
			},

			tests: {
				//ninja.publicKey tests
				testIsPublicKeyHexFormat: function () {
					var key = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var bool = ninja.publicKey.isPublicKeyHexFormat(key);
					if (bool != true) {
						return false;
					}
					return true;
				},
				testGetHexFromByteArray: function () {
					var bytes = [4, 120, 152, 47, 64, 250, 12, 11, 122, 85, 113, 117, 131, 175, 201, 154, 78, 223, 211, 1, 162, 114, 157, 197, 155, 11, 142, 185, 225, 134, 146, 188, 181, 33, 240, 84, 250, 217, 130, 175, 76, 193, 147, 58, 253, 31, 27, 86, 62, 167, 121, 166, 170, 108, 206, 54, 163, 11, 148, 125, 214, 83, 230, 62, 68];
					var key = ninja.publicKey.getHexFromByteArray(bytes);
					if (key != "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44") {
						return false;
					}
					return true;
				},
				testHexToBytes: function () {
					var key = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var bytes = Crypto.util.hexToBytes(key);
					if (bytes.toString() != "4,120,152,47,64,250,12,11,122,85,113,117,131,175,201,154,78,223,211,1,162,114,157,197,155,11,142,185,225,134,146,188,181,33,240,84,250,217,130,175,76,193,147,58,253,31,27,86,62,167,121,166,170,108,206,54,163,11,148,125,214,83,230,62,68") {
						return false;
					}
					return true;
				},
				testGetBitcoinAddressFromByteArray: function () {
					var bytes = [4, 120, 152, 47, 64, 250, 12, 11, 122, 85, 113, 117, 131, 175, 201, 154, 78, 223, 211, 1, 162, 114, 157, 197, 155, 11, 142, 185, 225, 134, 146, 188, 181, 33, 240, 84, 250, 217, 130, 175, 76, 193, 147, 58, 253, 31, 27, 86, 62, 167, 121, 166, 170, 108, 206, 54, 163, 11, 148, 125, 214, 83, 230, 62, 68];
					var address = ninja.publicKey.getBitcoinAddressFromByteArray(bytes);
					if (address != "1Cnz9ULjzBPYhDw1J8bpczDWCEXnC9HuU1") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromAdding: function () {
					var key1 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var key2 = "0419153E53FECAD7FF07FEC26F7DDEB1EDD66957711AA4554B8475F10AFBBCD81C0159DC0099AD54F733812892EB9A11A8C816A201B3BAF0D97117EBA2033C9AB2";
					var bytes = ninja.publicKey.getByteArrayFromAdding(key1, key2);
					if (bytes.toString() != "4,151,19,227,152,54,37,184,255,4,83,115,216,102,189,76,82,170,57,4,196,253,2,41,74,6,226,33,167,199,250,74,235,223,128,233,99,150,147,92,57,39,208,84,196,71,68,248,166,106,138,95,172,253,224,70,187,65,62,92,81,38,253,79,0") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromAddingCompressed: function () {
					var key1 = "0278982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB5";
					var key2 = "0219153E53FECAD7FF07FEC26F7DDEB1EDD66957711AA4554B8475F10AFBBCD81C";
					var bytes = ninja.publicKey.getByteArrayFromAdding(key1, key2);
					var hex = ninja.publicKey.getHexFromByteArray(bytes);
					if (hex != "029713E3983625B8FF045373D866BD4C52AA3904C4FD02294A06E221A7C7FA4AEB") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromAddingUncompressedAndCompressed: function () {
					var key1 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var key2 = "0219153E53FECAD7FF07FEC26F7DDEB1EDD66957711AA4554B8475F10AFBBCD81C";
					var bytes = ninja.publicKey.getByteArrayFromAdding(key1, key2);
					if (bytes.toString() != "4,151,19,227,152,54,37,184,255,4,83,115,216,102,189,76,82,170,57,4,196,253,2,41,74,6,226,33,167,199,250,74,235,223,128,233,99,150,147,92,57,39,208,84,196,71,68,248,166,106,138,95,172,253,224,70,187,65,62,92,81,38,253,79,0") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromAddingShouldReturnNullWhenSameKey1: function () {
					var key1 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var key2 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var bytes = ninja.publicKey.getByteArrayFromAdding(key1, key2);
					if (bytes != null) {
						return false;
					}
					return true;
				},
				testGetByteArrayFromAddingShouldReturnNullWhenSameKey2: function () {
					var key1 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var key2 = "0278982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB5";
					var bytes = ninja.publicKey.getByteArrayFromAdding(key1, key2);
					if (bytes != null) {
						return false;
					}
					return true;
				},
				testGetByteArrayFromMultiplying: function () {
					var key1 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var key2 = "SQE6yipP5oW8RBaStWoB47xsRQ8pat";
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(key1, new Bitcoin.ECKey(key2));
					if (bytes.toString() != "4,102,230,163,180,107,9,21,17,48,35,245,227,110,199,119,144,57,41,112,64,245,182,40,224,41,230,41,5,26,206,138,57,115,35,54,105,7,180,5,106,217,57,229,127,174,145,215,79,121,163,191,211,143,215,50,48,156,211,178,72,226,68,150,52") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromMultiplyingCompressedOutputsUncompressed: function () {
					var key1 = "0278982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB5";
					var key2 = "SQE6yipP5oW8RBaStWoB47xsRQ8pat";
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(key1, new Bitcoin.ECKey(key2));
					if (bytes.toString() != "4,102,230,163,180,107,9,21,17,48,35,245,227,110,199,119,144,57,41,112,64,245,182,40,224,41,230,41,5,26,206,138,57,115,35,54,105,7,180,5,106,217,57,229,127,174,145,215,79,121,163,191,211,143,215,50,48,156,211,178,72,226,68,150,52") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromMultiplyingCompressedOutputsCompressed: function () {
					var key1 = "0278982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB5";
					var key2 = "L1n4cgNZAo2KwdUc15zzstvo1dcxpBw26NkrLqfDZtU9AEbPkLWu";
					var ecKey = new Bitcoin.ECKey(key2);
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(key1, ecKey);
					if (bytes.toString() != "2,102,230,163,180,107,9,21,17,48,35,245,227,110,199,119,144,57,41,112,64,245,182,40,224,41,230,41,5,26,206,138,57") {
						return false;
					}
					return true;
				},
				testGetByteArrayFromMultiplyingShouldReturnNullWhenSameKey1: function () {
					var key1 = "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44";
					var key2 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(key1, new Bitcoin.ECKey(key2));
					if (bytes != null) {
						return false;
					}
					return true;
				},
				testGetByteArrayFromMultiplyingShouldReturnNullWhenSameKey2: function () {
					var key1 = "0278982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB5";
					var key2 = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(key1, new Bitcoin.ECKey(key2));
					if (bytes != null) {
						return false;
					}
					return true;
				},
				// confirms multiplication is working and BigInteger was created correctly (Pub Key B vs Priv Key A)
				testGetPubHexFromMultiplyingPrivAPubB: function () {
					var keyPub = "04F04BF260DCCC46061B5868F60FE962C77B5379698658C98A93C3129F5F98938020F36EBBDE6F1BEAF98E5BD0E425747E68B0F2FB7A2A59EDE93F43C0D78156FF";
					var keyPriv = "B1202A137E917536B3B4C5010C3FF5DDD4784917B3EEF21D3A3BF21B2E03310C";
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(keyPub, new Bitcoin.ECKey(keyPriv));
					var pubHex = ninja.publicKey.getHexFromByteArray(bytes);
					if (pubHex != "04C6732006AF4AE571C7758DF7A7FB9E3689DFCF8B53D8724D3A15517D8AB1B4DBBE0CB8BB1C4525F8A3001771FC7E801D3C5986A555E2E9441F1AD6D181356076") {
						return false;
					}
					return true;
				},
				// confirms multiplication is working and BigInteger was created correctly (Pub Key A vs Priv Key B)
				testGetPubHexFromMultiplyingPrivBPubA: function () {
					var keyPub = "0429BF26C0AF7D31D608474CEBD49DA6E7C541B8FAD95404B897643476CE621CFD05E24F7AE8DE8033AADE5857DB837E0B704A31FDDFE574F6ECA879643A0D3709";
					var keyPriv = "7DE52819F1553C2BFEDE6A2628B6FDDF03C2A07EB21CF77ACA6C2C3D252E1FD9";
					var bytes = ninja.publicKey.getByteArrayFromMultiplying(keyPub, new Bitcoin.ECKey(keyPriv));
					var pubHex = ninja.publicKey.getHexFromByteArray(bytes);
					if (pubHex != "04C6732006AF4AE571C7758DF7A7FB9E3689DFCF8B53D8724D3A15517D8AB1B4DBBE0CB8BB1C4525F8A3001771FC7E801D3C5986A555E2E9441F1AD6D181356076") {
						return false;
					}
					return true;
				},

				// Private Key tests
				testBadKeyIsNotWif: function () {
					return !(Bitcoin.ECKey.isWalletImportFormat("bad key"));
				},
				testBadKeyIsNotWifCompressed: function () {
					return !(Bitcoin.ECKey.isCompressedWalletImportFormat("bad key"));
				},
				testBadKeyIsNotHex: function () {
					return !(Bitcoin.ECKey.isHexFormat("bad key"));
				},
				testBadKeyIsNotBase64: function () {
					return !(Bitcoin.ECKey.isBase64Format("bad key"));
				},
				testBadKeyIsNotMini: function () {
					return !(Bitcoin.ECKey.isMiniFormat("bad key"));
				},
				testBadKeyReturnsNullPrivFromECKey: function () {
					var key = "bad key";
					var ecKey = new Bitcoin.ECKey(key);
					if (ecKey.priv != null) {
						return false;
					}
					return true;
				},
				testGetBitcoinPrivateKeyByteArray: function () {
					var key = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var bytes = [41, 38, 101, 195, 135, 36, 24, 173, 241, 218, 127, 250, 58, 100, 111, 47, 6, 2, 36, 109, 166, 9, 138, 145, 210, 41, 195, 33, 80, 242, 113, 139];
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinPrivateKeyByteArray().toString() != bytes.toString()) {
						return false;
					}
					return true;
				},
				testECKeyDecodeWalletImportFormat: function () {
					var key = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var bytes1 = [41, 38, 101, 195, 135, 36, 24, 173, 241, 218, 127, 250, 58, 100, 111, 47, 6, 2, 36, 109, 166, 9, 138, 145, 210, 41, 195, 33, 80, 242, 113, 139];
					var bytes2 = Bitcoin.ECKey.decodeWalletImportFormat(key);
					if (bytes1.toString() != bytes2.toString()) {
						return false;
					}
					return true;
				},
				testECKeyDecodeCompressedWalletImportFormat: function () {
					var key = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var bytes1 = [41, 38, 101, 195, 135, 36, 24, 173, 241, 218, 127, 250, 58, 100, 111, 47, 6, 2, 36, 109, 166, 9, 138, 145, 210, 41, 195, 33, 80, 242, 113, 139];
					var bytes2 = Bitcoin.ECKey.decodeCompressedWalletImportFormat(key);
					if (bytes1.toString() != bytes2.toString()) {
						return false;
					}
					return true;
				},
				testWifToPubKeyHex: function () {
					var key = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getPubKeyHex() != "0478982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB521F054FAD982AF4CC1933AFD1F1B563EA779A6AA6CCE36A30B947DD653E63E44"
						|| btcKey.getPubPoint().compressed != false) {
						return false;
					}
					return true;
				},
				testWifToPubKeyHexCompressed: function () {
					var key = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var btcKey = new Bitcoin.ECKey(key);
					btcKey.setCompressed(true);
					if (btcKey.getPubKeyHex() != "0278982F40FA0C0B7A55717583AFC99A4EDFD301A2729DC59B0B8EB9E18692BCB5"
						|| btcKey.getPubPoint().compressed != true) {
						return false;
					}
					return true;
				},
				testBase64ToECKey: function () {
					var key = "KSZlw4ckGK3x2n/6OmRvLwYCJG2mCYqR0inDIVDycYs=";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinBase64Format() != "KSZlw4ckGK3x2n/6OmRvLwYCJG2mCYqR0inDIVDycYs=") {
						return false;
					}
					return true;
				},
				testHexToECKey: function () {
					var key = "292665C3872418ADF1DA7FFA3A646F2F0602246DA6098A91D229C32150F2718B";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinHexFormat() != "292665C3872418ADF1DA7FFA3A646F2F0602246DA6098A91D229C32150F2718B") {
						return false;
					}
					return true;
				},
				testCompressedWifToECKey: function () {
					var key = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinWalletImportFormat() != "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S"
						|| btcKey.getPubPoint().compressed != true) {
						return false;
					}
					return true;
				},
				testWifToECKey: function () {
					var key = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinWalletImportFormat() != "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb") {
						return false;
					}
					return true;
				},
				testBrainToECKey: function () {
					var key = "bitaddress.org unit test";
					var bytes = Crypto.SHA256(key, { asBytes: true });
					var btcKey = new Bitcoin.ECKey(bytes);
					if (btcKey.getBitcoinWalletImportFormat() != "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb") {
						return false;
					}
					return true;
				},
				testMini30CharsToECKey: function () {
					var key = "SQE6yipP5oW8RBaStWoB47xsRQ8pat";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinWalletImportFormat() != "5JrBLQseeZdYw4jWEAHmNxGMr5fxh9NJU3fUwnv4khfKcg2rJVh") {
						return false;
					}
					return true;
				},
				testGetECKeyFromAdding: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "SQE6yipP5oW8RBaStWoB47xsRQ8pat";
					var ecKey = ninja.privateKey.getECKeyFromAdding(key1, key2);
					if (ecKey.getBitcoinWalletImportFormat() != "5KAJTSqSjpsZ11KyEE3qu5PrJVjR4ZCbNxK3Nb1F637oe41m1c2") {
						return false;
					}
					return true;
				},
				testGetECKeyFromAddingCompressed: function () {
					var key1 = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var key2 = "L1n4cgNZAo2KwdUc15zzstvo1dcxpBw26NkrLqfDZtU9AEbPkLWu";
					var ecKey = ninja.privateKey.getECKeyFromAdding(key1, key2);
					if (ecKey.getBitcoinWalletImportFormat() != "L3A43j2pc2J8F2SjBNbYprPrcDpDCh8Aju8dUH65BEM2r7RFSLv4") {
						return false;
					}
					return true;
				},
				testGetECKeyFromAddingUncompressedAndCompressed: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "L1n4cgNZAo2KwdUc15zzstvo1dcxpBw26NkrLqfDZtU9AEbPkLWu";
					var ecKey = ninja.privateKey.getECKeyFromAdding(key1, key2);
					if (ecKey.getBitcoinWalletImportFormat() != "5KAJTSqSjpsZ11KyEE3qu5PrJVjR4ZCbNxK3Nb1F637oe41m1c2") {
						return false;
					}
					return true;
				},
				testGetECKeyFromAddingShouldReturnNullWhenSameKey1: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var ecKey = ninja.privateKey.getECKeyFromAdding(key1, key2);
					if (ecKey != null) {
						return false;
					}
					return true;
				},
				testGetECKeyFromAddingShouldReturnNullWhenSameKey2: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var ecKey = ninja.privateKey.getECKeyFromAdding(key1, key2);
					if (ecKey != null) {
						return false;
					}
					return true;
				},
				testGetECKeyFromMultiplying: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "SQE6yipP5oW8RBaStWoB47xsRQ8pat";
					var ecKey = ninja.privateKey.getECKeyFromMultiplying(key1, key2);
					if (ecKey.getBitcoinWalletImportFormat() != "5KetpZ5mCGagCeJnMmvo18n4iVrtPSqrpnW5RP92Gv2BQy7GPCk") {
						return false;
					}
					return true;
				},
				testGetECKeyFromMultiplyingCompressed: function () {
					var key1 = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var key2 = "L1n4cgNZAo2KwdUc15zzstvo1dcxpBw26NkrLqfDZtU9AEbPkLWu";
					var ecKey = ninja.privateKey.getECKeyFromMultiplying(key1, key2);
					if (ecKey.getBitcoinWalletImportFormat() != "L5LFitc24jme2PfVChJS3bKuQAPBp54euuqLWciQdF2CxnaU3M8t") {
						return false;
					}
					return true;
				},
				testGetECKeyFromMultiplyingUncompressedAndCompressed: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "L1n4cgNZAo2KwdUc15zzstvo1dcxpBw26NkrLqfDZtU9AEbPkLWu";
					var ecKey = ninja.privateKey.getECKeyFromMultiplying(key1, key2);
					if (ecKey.getBitcoinWalletImportFormat() != "5KetpZ5mCGagCeJnMmvo18n4iVrtPSqrpnW5RP92Gv2BQy7GPCk") {
						return false;
					}
					return true;
				},
				testGetECKeyFromMultiplyingShouldReturnNullWhenSameKey1: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var ecKey = ninja.privateKey.getECKeyFromMultiplying(key1, key2);
					if (ecKey != null) {
						return false;
					}
					return true;
				},
				testGetECKeyFromMultiplyingShouldReturnNullWhenSameKey2: function () {
					var key1 = "5J8QhiQtAiozKwyk3GCycAscg1tNaYhNdiiLey8vaDK8Bzm4znb";
					var key2 = "KxbhchnQquYQ2dfSxz7rrEaQTCukF4uCV57TkamyTbLzjFWcdi3S";
					var ecKey = ninja.privateKey.getECKeyFromMultiplying(key1, key2);
					if (ecKey != null) {
						return false;
					}
					return true;
				},

				// EllipticCurve tests
				testDecodePointEqualsDecodeFrom: function () {
					var key = "04F04BF260DCCC46061B5868F60FE962C77B5379698658C98A93C3129F5F98938020F36EBBDE6F1BEAF98E5BD0E425747E68B0F2FB7A2A59EDE93F43C0D78156FF";
					var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
					var ecPoint1 = EllipticCurve.PointFp.decodeFrom(ecparams.getCurve(), Crypto.util.hexToBytes(key));
					var ecPoint2 = ecparams.getCurve().decodePointHex(key);
					if (!ecPoint1.equals(ecPoint2)) {
						return false;
					}
					return true;
				},
				testDecodePointHexForCompressedPublicKey: function () {
					var key = "03F04BF260DCCC46061B5868F60FE962C77B5379698658C98A93C3129F5F989380";
					var pubHexUncompressed = ninja.publicKey.getDecompressedPubKeyHex(key);
					if (pubHexUncompressed != "04F04BF260DCCC46061B5868F60FE962C77B5379698658C98A93C3129F5F98938020F36EBBDE6F1BEAF98E5BD0E425747E68B0F2FB7A2A59EDE93F43C0D78156FF") {
						return false;
					}
					return true;
				},
				// old bugs
				testBugWithLeadingZeroBytePublicKey: function () {
					var key = "5Je7CkWTzgdo1RpwjYhwnVKxQXt8EPRq17WZFtWcq5umQdsDtTP";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinAddress() != "1M6dsMZUjFxjdwsyVk8nJytWcfr9tfUa9E") {
						return false;
					}
					return true;
				},
				testBugWithLeadingZeroBytePrivateKey: function () {
					var key = "0004d30da67214fa65a41a6493576944c7ea86713b14db437446c7a8df8e13da";
					var btcKey = new Bitcoin.ECKey(key);
					if (btcKey.getBitcoinAddress() != "1NAjZjF81YGfiJ3rTKc7jf1nmZ26KN7Gkn") {
						return false;
					}
					return true;
				}
			}
		};
	})(ninja);
	</script>

	<script type="text/javascript">
		// run unit tests
		if (ninja.getQueryString()["unittests"] == "true" || ninja.getQueryString()["unittests"] == "1") {
			ninja.unitTests.runTests();
		}
	</script>
	<footer class="footer">
		<div class="footer_inner">
			<a href="https://github.com/openpaperwallet/walletprinter" title="OpenPaperWallet">OpenPaperWallet on github</a>
			This software is licensed under multiple open source licenses, see the source HTML.
		</div>
	</footer>	
	
</body>
</html>
